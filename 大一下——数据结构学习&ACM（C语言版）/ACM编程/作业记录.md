### 作业1——C语言复习

#### 1. ACM2024-第一章-C语言回顾-结构体2

#### 2. ACM2024-第一章-C语言回顾-结构体2

#### 3. ACM2024-第一章-C语言回顾-结构体1

#### 4. ACM2024-第一章-C语言回顾-数组最大值

#### 5. ACM2024-第一章-C语言回顾-数组1



### 作业2——顺序表

#### 1. ACM2023-第二章-线性表-交叉合并两个顺序表- LJD



```c
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0
#define MAXSIZE 20

typedef int Status;
typedef int ElemType;

typedef struct {
    ElemType data[MAXSIZE];
    int length;
} SqList;

// 遍历顺序表并打印元素
void TraverseList(SqList L) 
{
    for (int i = 0; i < L.length; i++) 
    {
        printf("%d ", L.data[i]);
    }
    printf("\n");
}

// 获取顺序表的长度
int GetListLength(SqList L) 
{
    return L.length;
}

// 获取指定位置的元素值
Status GetElemAt(SqList L, int i, ElemType *e) 
{
    if (i < 1 || i > L.length)
        return ERROR;
    *e = L.data[i - 1];
    return OK;
}

// 在指定位置插入元素
Status InsertIntoList(SqList *L, int i, ElemType e) 
{
    if (L->length >= MAXSIZE || i < 0 || i > L->length)
        return ERROR;
    for (int k = L->length - 1; k >= i; k--) 
    {
        L->data[k + 1] = L->data[k];
    }
    L->data[i] = e;
    L->length++;
    return OK;
}

// 将两个顺序表的元素交错到第三个顺序表中
void InterleaveLists(SqList *L3, SqList L1, SqList L2) 
{
    int i = 1;
    int e;
    while (i <= L1.length || i <= L2.length) 
    {
        int tag = i;//作为判断标志	是否已经插了L1	矫正i 的值
        if (i <= L1.length) 
        {
            GetElemAt(L1, i, &e);
            InsertIntoList(L3, L3->length, e);
            i++;
        }
        if (i - 1 <= L2.length) 
        {
            if (tag != i) i--;
            GetElemAt(L2, i, &e);
            InsertIntoList(L3, L3->length, e);
            i++;
        }
    }
}

int main() 
{
    SqList L1, L2, L3;
    Status i;
    int j, k, l;

    // 输入并创建第一个顺序表
    scanf("%d", &k);
    L1.length = 0;
    if (k > 0)
        for (j = 1; j <= k; j++) 
        {
            scanf("%d", &l);
            i = InsertIntoList(&L1, 0, l);
        }

    // 打印第一个顺序表及其长度
    TraverseList(L1);
    printf("%d \n", GetListLength(L1));

    // 输入并创建第二个顺序表
    scanf("%d", &k);
    L2.length = 0;
    if (k > 0)
        for (j = 1; j <= k; j++) 
        {
            scanf("%d", &l);
            i = InsertIntoList(&L2, 0, l);
        }

    // 打印第二个顺序表及其长度
    TraverseList(L2);
    printf("%d \n", GetListLength(L2));

    // 将两个顺序表的元素交错到第三个顺序表中
    L3.length = 0;
    InterleaveLists(&L3, L1, L2);

    // 打印交错后的顺序表及其长度
    TraverseList(L3);
    printf("%d \n", GetListLength(L3));

    return OK;
}

```



#### 2. ACM2023-第二章-线性表-顺序表的各种操作练习- LJD



```c
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE 0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
typedef int ElemType;

#define INIT_SIZE 100       // 初始分配空间的大小
#define LISTINCREMENT 10    // 分配增量

typedef struct {
    ElemType *elem;         // 存储空间的起始地址
    int length;             // 线性表中数据元素个数，即表长
    int listsize;           // 线性表所申请的存储空间的大小
} SqList;

// 创建一个空的线性表
SqList CreateList_Sq(SqList L)
{
    L.elem = (ElemType*)malloc(100 * sizeof(ElemType));  // 申请空间
    L.length = 0;         // 表长为0
    L.listsize = 100;     // 申请的空间为初始大小
    return L;
}

// 在线性表的第i个位置前插入元素e
void InsertList_Sq(SqList *L, int i, ElemType e)
{
    int *newbase, *q, *p;
    if ((i < 1) || (i > L->length + 1)) 
    {
        printf("i值不合法!\n");
        exit(ERROR);
    }
    // 当前空间已满，增加分配空间
    if (L->length >= L->listsize) 
    {   
        newbase = (ElemType*)realloc(L->elem, (L->listsize + LISTINCREMENT) * sizeof(ElemType));
        if (!newbase) exit(ERROR);
        L->elem = newbase;
        L->listsize = L->listsize + LISTINCREMENT;
    }
    //检查完错误	开始插值
    int j;
    for (j = L->length - 1; j >= i - 1; j--) 
    {
        L->elem[j + 1] = L->elem[j]; // 将元素后移
    }
    L->elem[i - 1] = e;
    L->length++;//插完后	莫忘更新线性表的长度
    return OK;
}

// 删除线性表中的第i个元素
void DeleteList_Sq(SqList *L, int i)
{
    int j;
    if ((i < 1) || (i > L->length)) {
        printf("i值不合法!\n");
        exit(ERROR);
    }
    for (j = i; j < L->length; j++) {
        L->elem[j - 1] = L->elem[j];
    }
    L->length--;
}

// 遍历顺序线性表并输出
void Print_Sq(SqList L)
{
    int i;
    for (i = 0; i < L.length; i++) {
        printf("%3d ", L.elem[i]);
    }
}

// 判两个元素是否相等
int equal(ElemType e1, ElemType e2)
{
    if (e1 == e2) return 1;
    else return 0;
}

// 查找元素在顺序表中的位置
int LocateElem_Sq(SqList L, ElemType e, int (* compare)(ElemType e1, ElemType e2))
{
    int i = 0;
    for (; i < L.length; i++) {
        if (compare(L.elem[i], e)) return i + 1;
    }
    return ERROR;
}

void Getelem(SqList L, int i, ElemType *e)
{
    if (i < 1 || i > L.length) return;
    *e = L.elem[i - 1];
    return;
}

int main()
{
    int i;
    ElemType e;
    SqList Lq;
    Lq = CreateList_Sq(Lq);
    InsertList_Sq(&Lq, 1, 21);
    InsertList_Sq(&Lq, 2, 18);
    InsertList_Sq(&Lq, 3, 30);
    InsertList_Sq(&Lq, 4, 75);
    InsertList_Sq(&Lq, 5, 42);
    InsertList_Sq(&Lq, 6, 56);
    printf("初始顺序表为\n");
    Print_Sq(Lq);
    InsertList_Sq(&Lq, 3, 67);
    printf("\n插入67后顺序表为\n");
    Print_Sq(Lq);
    DeleteList_Sq(&Lq, 6);
    printf("\n删除第6个元素后顺序表为\n");
    Print_Sq(Lq);
    if ((i = LocateElem_Sq(Lq, 75, equal)))
        printf("\n存在元素75且位置为%d\n", i);
    else
        printf("\n不存在元素75\n");
    free(Lq.elem);
    return 1;
}

```



#### 3. ACM2023-第二章-顺序表练习题 -合并两有序表 - LJD



```c
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE 0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10
typedef int ElemType;

typedef struct {
    ElemType *elem;
    int length;
    int listsize;
} SqList;

// Create an empty list
Status InitList_Sq(SqList *L)
{
    //学生添加
    L->elem = (int*)malloc(INIT_SIZE*sizeof(int));
    if (!L->elem) return OVERFLOW;
    L->length = 0;
    L->listsize = INIT_SIZE; 
}

// Create an array based list with n elements
Status CreateList_Sq(SqList *L, int a[], int n)
{
    //学生添加
    int j = 0;
    for(; j < n; j++)
    {
        L->elem[j] = a[j];
    }
    L->length = n;
}

// Get Element
Status GetElem(SqList L, int i, int *e)
{
    //学生添加
    if(i < 1 || i > L.length) return ERROR;
    *e = L.elem[i - 1];
    return OK;
}

// Insert
Status ListInsert(SqList *L, int i, int e)
{
    //学生添加
    if(i < 1 || i > L->length + 1) return ERROR;
    if(L->length == L->listsize) return ERROR;
    int j = L->length - 1;
    for(; j >= i - 1; j--)
    {
        L->elem[j + 1] = L->elem[j];
    }
    L->elem[i - 1] = e;
    L->length++;
    return OK;
}

// Merge two sequential lists 
Status MergeList_Sq(SqList L1, SqList L2, SqList *L3)
{  
    //学生添加
    int i = 0, j = 0, k = 0;
    
    
    while(i < L1.length && j < L2.length)
    {
        if(L1.elem[i] <= L2.elem[j])
        {
            L3->elem[k++] = L1.elem[i++];
        }
        else
        {
            L3->elem[k++] = L2.elem[j++];
        }
    }
    while(i < L1.length)
    {
        L3->elem[k++] = L1.elem[i++];
    }
    while(j < L2.length)
    {
        L3->elem[k++] = L2.elem[j++];
    }
    L3->length = k;
    
    
    //上面的三个while循环逻辑更加清晰	
    //下面一个看着很复杂
    //while (L3->length < L1.length + L2.length)
    //{
    //	if (len1 < L1.length && (L1.elem[len1] <= L2.elem[len2] || len2 >= L2.length))
    //	{
    //		L3->elem[len3++] = L1.elem[len1++];
    //		L3->length++;
    //	}
    //	else if (len2 < L2.length && (L2.elem[len2] < L1.elem[len1] || len1 >= L1.length))
    //	{
    //		L3->elem[len3++] = L2.elem[len2++];
    //		L3->length++;
    //	}
    //}
    
}

// Print out all elements
void PrintList_Sq(SqList L)
{ 
    //学生添加
    int j = 0;
    for(; j < L.length; j++)
    {
        printf("%d ", L.elem[j]);
    }
}

int main()
{
    int n1, n2, i, j;
    int a[20], b[20];
    SqList L1, L2, L3;

    scanf("%d", &n1);
    for(i = 0; i < n1; i++)
    {
        scanf("%d", &a[i]);
    }
    scanf("%d", &n2);
    for(i = 0; i < n2; i++)
    {
        scanf("%d", &b[i]);
    }

    InitList_Sq(&L1);
    InitList_Sq(&L2);
    InitList_Sq(&L3);

    CreateList_Sq(&L1, a, n1);
    CreateList_Sq(&L2, b, n2);

    MergeList_Sq(L1, L2, &L3);

    PrintList_Sq(L3);

    return 0;
}

```



#### 4. ACM2023-第二章-顺序表练习题 -删除顺序表指定位置n后的m个元素 - LJD



```C
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE  0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10  
typedef int ElemType;

typedef struct
{
    ElemType *elem;
    int length;
    int listsize;
}SqList;

// Initialize an empty list
Status InitList_Sq(SqList *L)
{
 //学生添加
 	L->elem = (int*)malloc(INIT_SIZE * sizeof(int));
    if (!L->elem) return OVERFLOW;
 	L->length = 0;
 	L->listsize = INIT_SIZE;
}
//Create an array based list with n elements
Status CreateList_Sq(SqList *L, int a[], int n)
{
 //学生添加
	int i = 0;
	for(;i < n;i ++)
	{
		L->elem[i] = a[i]; 
	}
	L->length = n;
    return OK;
}

// Delete the ith elements of sequential list L
Status DeleteList_Sq(SqList *L, int m,int k)
{    
 //学生添加
       if (m < 0 || m > L->length || k < 0)
        return ERROR;
 	int i = 0; 	
 	for(;m < L->length - k;m ++)
 	{
 		L->elem[m] = L->elem[m + k];
	 }
	 L->length -=k;
}

//print out all elements
void PrintList_Sq(SqList L)
{ 
 //学生添加
	 int i = 0;
	 for(;i < L.length;i ++)
	 {
	 	printf("%d ",L.elem[i]); 
	 }
}

int main()
{ 
	int n;
	scanf("%d",&n);
	int i,arr[n];
	for(i = 0;i < n;i ++)
	{
		scanf("%d",&arr[i]);
	 }
    
	 SqList sq;
	 InitList_Sq(&sq);	 
	 CreateList_Sq(&sq,arr,n);
	 
	 int m,k; 
	 scanf("%d%d",&m,&k);
	 
	 DeleteList_Sq(&sq,m,k);
	 
	 PrintList_Sq(sq);	 
	 return 0;
}

```



#### 5. ACM2023-第二章-顺序表练习题 -就地逆置顺序表 - LJD



```c
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE  0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10  
typedef int ElemType;

typedef struct {
    ElemType *elem;
    int length;
    int listsize;
} SqList;

// Create an empty list
Status InitList_Sq(SqList *L)
{
    //学生添加
    L->elem = (int*)malloc(INIT_SIZE * sizeof(int));
    L->length = 0;
    L->listsize = INIT_SIZE;
}

// Create an array based list with n elements
Status CreateList_Sq(SqList *L, int a[], int n)
{
    //学生添加
    int i = 0;
    for(; i < n; i++)
    {
        L->elem[i] = a[i];
    }
    L->length = n;
}

// Reverse the elements of sequential list L
void swap(int *a, int *b)
{
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;	
}

Status ReverseList_Sq(SqList *L)
{    
    //学生添加
    int i = 0;
    for(; i < L->length / 2; i++)
    {
        swap(&L->elem[i], &L->elem[L->length - i - 1]); 
    }
    return OK;
}

// print out all elements
void PrintList_Sq(SqList L)
{ 
    //学生添加
    int i = 0;
    for(; i < L.length; i++)
    {
        printf("%d ", L.elem[i]);
    }
}

int main()
{ 
    //学生添加
    int n;
    scanf("%d", &n);
    int arr[n];
    int i = 0;
    for(; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }
    SqList sq;
    InitList_Sq(&sq);
    CreateList_Sq(&sq, arr, n);
    ReverseList_Sq(&sq);
    PrintList_Sq(sq);
    return 0;
}

```



#### 6. ACM2023-第二章-顺序表练习题 -顺序表排序 - LJD



```C
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE 0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10  
typedef int ElemType;

typedef struct{
    ElemType *elem;
    int length;
    int listsize;
} SqList;

// Create an empty list
Status InitList_Sq(SqList *L)
{
    //学生添加
    L->elem = (int*)malloc(INIT_SIZE*sizeof(int));
    L->length = 0;
    L->listsize = INIT_SIZE;
}

// Create an array based list with n elements
Status CreateList_Sq(SqList *L, int a[], int n)
{
    //学生添加
    int i = 0;
    for(; i < n; i++)
    {
        L->elem[i] = a[i];
    }
    L->length = n;
}

// Sort the elements of sequential list L into ascending order
Status SortList_Sq(SqList *L)
{    
    //学生添加
    int i = 0, j = 0;
    for(; i < L->length - 1; i++)
    {
        for(j = 0; j < L->length - i - 1; j++)
        {
            if(L->elem[j] > L->elem[j + 1])
            {
                int temp = L->elem[j];
                L->elem[j] = L->elem[j + 1];
                L->elem[j + 1] = temp;
            }
        }
    }
}

// Print out all elements
void PrintList_Sq(SqList L)
{ 
    //学生添加
    int i = 0;
    for(; i < L.length; i++)
    {
        printf("%d ", L.elem[i]);
    }
}

int main()
{ 
    //学生添加
    int n;
    scanf("%d", &n);
    int i = 0, arr[n];
    for(; i < n; i++)
    {
        scanf("%d", &arr[i]);
    } 
    SqList sq;
    InitList_Sq(&sq);
    CreateList_Sq(&sq, arr, n);
    SortList_Sq(&sq);
    PrintList_Sq(sq);
    return 0;
}

```



#### 7. ACM2023-第二章-顺序表练习题 -在顺序表的指定位置插入指定元素 -LJD

```c
#include <stdio.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10  
typedef int ElemType;

typedef struct {
    ElemType *elem;
    int length;
    int listsize;
} SqList;

// 创建一个空的顺序表
Status InitList_Sq(SqList *L) 
{
    L->elem = (int *)malloc(INIT_SIZE * sizeof(int));
    if (!L->elem) 
    {
        printf("Memory allocation failed.\n");
        return OVERFLOW;
    }
    L->length = 0;
    L->listsize = INIT_SIZE;
    return OK;
}

// 创建一个带有 n 个元素的数组列表
Status CreateList_Sq(SqList *L, int a[], int n) 
{
    if (n > INIT_SIZE) 
    {
        printf("The number of elements exceeds the initial size.\n");
        return ERROR;
    }
    int i;
    for (i = 0; i < n; i++) 
    {
        InsertList_Sq(L, i + 1, a[i]);
    }
    return OK;
}

// 在顺序表 L 的特定位置插入元素
Status InsertList_Sq(SqList *L, int i, ElemType e) 
{    
    if (i < 1 || i > L->length + 1) 
    {
        printf("Invalid position.\n");
        return ERROR;
    }
    if (L->length >= L->listsize) 
    {
        printf("The list is full. No more space to insert.\n");
        return OVERFLOW; // 检查是否需要扩展顺序表的空间
    }
    int j;
    for (j = L->length - 1; j >= i - 1; j--) 
    {
        L->elem[j + 1] = L->elem[j]; // 将元素后移
    }
    L->elem[i - 1] = e;
    L->length++;
    return OK;
}

// 打印所有元素
void PrintList_Sq(SqList L) 
{
    int i;
    for (i = 0; i < L.length; i++) 
    {
        printf("%d ", L.elem[i]); 
    }
    printf("\n");
}

int main() 
{
    int n, e, k;
   // printf("Enter the number of elements: ");
    scanf("%d", &n);
    if (n <= 0) 
    {
       // printf("Invalid number of elements.\n");
        return ERROR;
    }
    int i, arr[n];
    //printf("Enter the elements: ");
    for (i = 0; i < n; i++) 
    {
        scanf("%d", &arr[i]);
    }
    SqList sq;
    if (InitList_Sq(&sq) != OK) 
    {
        return ERROR;
    }
    if (CreateList_Sq(&sq, arr, n) != OK) 
    {
        return ERROR;
    }
    //printf("Enter the element and the position to insert: ");
    scanf("%d%d", &e, &k);
    if (InsertList_Sq(&sq, k, e) != OK) 
    {
        return ERROR;
    }
    //printf("The list after insertion: ");
    PrintList_Sq(sq);
    return 0;
}

```

### 作业3——链表



#### 单链表学习代码：

```c
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0

typedef int ElemType;
typedef int Status;

typedef struct LNode
{
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// Initialize a linked list
Status InitList(LinkList *L)
{
    *L = (LinkList)malloc(sizeof(LNode));
    if (!(*L)) return ERROR;
    (*L)->next = NULL;
    return OK;
}

// Get the value at a given position
Status GetElem(LinkList L, int i, ElemType *e)
{
    LNode *p = L->next;
    int j = 1;
    while (p && j < i)
    {
        p = p->next;
        ++j;
    }
    if (!p || j > i) return ERROR;
    *e = p->data;
    return OK;
}

// Locate the element with a given value
LinkList LocateElem(LinkList L, ElemType e)
{
    LinkList p = L->next;
    while (p && p->data != e)
    {
        p = p->next;
    }
    return p;
}

// Insert an element at a given position
Status ListInsert(LinkList *L, int i, ElemType e)
{
    LinkList p = *L;
    int j = 0;
    while (p && j < i - 1)
    {
        p = p->next;
        ++j;
    }
    if (!p || j > i - 1) return ERROR;
    LinkList s = (LinkList)malloc(sizeof(LNode));
    if (!s) return ERROR;
    s->data = e;
    s->next = p->next;
    p->next = s;
    return OK;
}

// Delete the element at a given position
Status ListDelete(LinkList L, int i)
{
    LinkList p = L;
    int j = 0;
    while (p->next && j < i - 1)//循环终止后  p指向的第 i - 1个位置的结点
    {
        p = p->next;
        ++j;
    }
    if (!(p->next) || j > i - 1) return ERROR;//前者便是的是此链表最大长度小于 i，没有第i 个结点
    LinkList q = p->next;
    p->next = q->next;//不能直接使用p->next->next，会造成p->next的内存地址无法找到，内存泄漏
    free(q);
    return OK;
}

// Display the elements in the linked list
void DisplayList(LinkList L)
{
    LinkList p = L->next;
    while (p)
    {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}


/*逆序创建链表通常是为了更高效地插入元素。在逆序创建链表时，我们可以直接将新元素插入链表的头部，而不需要遍历整个链表找到尾部再插入。这样做的好处是，每次插入操作的时间复杂度为O(1)，而不是O(n)，因为不需要遍历链表。

如果采用正序创建链表，每次插入元素都需要遍历到链表的尾部，时间复杂度为O(n)，这在插入大量元素时会导致性能下降。*/

// Create a linked list with elements in reverse order
Status InverseCreateList(LinkList L, ElemType a[], int n)
{
    LNode *r = L;
    int i = 0;
    for(; i < n; i++)
    {
        LNode *p ;
        p = (LNode*)malloc(sizeof(LNode));
        p->data = a[n - i - 1]; // Insert elements in reverse order
        p->next = NULL;
        r->next = p; // Insert p into the linked list
        r = p; // Update r to point to p
    }
    return OK;
}

Status CreateList_L(LinkList L, ElemType a[ ], int n)
{
    LNode *r = L;
    int i = 0;
    for(;i < n;i ++)
    {
        LNode *p ;
        p = (LNode*)malloc(sizeof(LNode));//初始化指针，为其分配内存空间，防止出现内存泄漏和未定义行为
        p->data = a[i];//正序时：a[i]   逆序时：a[n - i - 1]
        p->next = NULL;
        r->next = p;//将p插入链表中
        r = p;//更新r的结点，变成指向p的结点
    }
    return OK;
}


//利用头插法对单链表进逆序
void reverse_List(LinkList L)
{
    LNode* p, * q, * r;
    q = L->next;
    p = L->next->next;
    while (p)
    {
        r = p->next;
        p->next = L->next;
        L->next = p;
        //p = p->next;之所以不能这样做，是因为p->next在之前被改了
        //这也是为什么需要额外的一个r来记录p->next
        p = r;
    }
    q->next = NULL;
}

int main()
{
    LinkList L;
    if (InitList(&L) == OK)
    {
        printf("List initialized successfully.\n");

        // Example usage
        ListInsert(&L, 1, 10);
        ListInsert(&L, 2, 20);
        ListInsert(&L, 3, 30);
        printf("Inserted elements: ");
        DisplayList(L);

        ElemType e;
        if (GetElem(L, 2, &e) == OK)
            printf("Element at position 2: %d\n", e);

        LinkList found = LocateElem(L, 20);
        if (found)
            printf("Element 20 found.\n");

        if (ListDelete(L, 2) == OK)
        {
            printf("Deleted element at position 2.\n");
            printf("Current list: ");
            DisplayList(L);
        }

        // Create a linked list with elements in reverse order
        ElemType arr[] = {1, 2, 3, 4, 5};
        if (InverseCreateList(L, arr, 5) == OK)
        {
            printf("Linked list created in reverse order: ");
            DisplayList(L);
        }
    }
    else
    {
        printf("Failed to initialize list.\n");
    }

    return 0;
}

```



#### 1.两个递增有序链表求交集

```c
#include <stdio.h>  
#include <stdlib.h>  

#define ERROR 0
#define OK 1

typedef int ElemType;  
typedef int Status; 

// definition of node structure of singly linked list
typedef struct LNode
{  
    ElemType data;           // data field
    struct LNode *next;      // pointer field
} LNode, *LinkList;

//===========================================
// Initialize a singly linked list L with head node
//===========================================
Status InitList_L(LinkList *L)//在初始化链表时，需要修改链表的头指针，所以需要传入的参数是指针的指针的类型
{
    *L = (LinkList)malloc(sizeof(LNode));
    if (!(*L)) return ERROR;
    (*L)->next = NULL;
    return OK;
}

//===========================================
// Create a singly linked list L with head node, and with n elements
//===========================================
Status CreateList_L(LinkList L, ElemType a[], int n)
{
    LNode *r = L;
    int i = 0;
    for (; i < n; i ++)
    {
        LNode *p = (LNode*)malloc(sizeof(LNode));
        if (!p) return ERROR;
        p->data = a[i];
        p->next = NULL;
        r->next = p;
        r = p;
    }
    return OK; 
}

//======================================
// Insert an element in a list
//=======================================
Status ListInsert_L(LinkList L,int i,ElemType e)
{
	LinkList r = L;
	int j = 0;
	while(r && j < i - 1)
	{
		r = r->next;
		++j;
	}
	if(!r || j > i - 1) return ERROR;
	LinkList s = (LNode*) malloc(sizeof(LNode));
	if(!s) return ERROR;
	s->data = e;
	s->next = r->next;
	r->next = s;
	r = s;
	return OK;
}

//===========================================
// 求两个递增链表La和Lb的交集，得到一个新的链表Lc
//===========================================
Status ListIntersection_L(LinkList La, LinkList Lb, LinkList Lc)
{
    int len_c = 0;
    LNode *ra = La->next;
    LNode *rb = Lb->next;
    LNode *rc = Lc; // 指向 Lc 的头结点
    while (ra && rb)
    {
        if (ra->data > rb->data) rb = rb->next;
        else if (ra->data < rb->data) ra = ra->next;
        else
        {
            ListInsert_L(Lc,++len_c,rb->data);
            //如果不用上面的插入函数，就直接插，
//			LNode *s ;
//			s = (LNode*)malloc(sizeof(LNode));
//			s->data = ra->data;
//			s->next = NULL;
//			rc->next = s;
//			rc = s;
            ra = ra->next;
            rb = rb->next;
        }
    }
    return OK;
}

//===========================================
// Print the elements in a list
//===========================================
void LinkedListPrint(LinkList L)
{
    if (L->next == NULL)//鲁棒性问题，
    {
        return;
    }
    LinkList p = L->next;
    while(p)
    {
        printf("%d ",p->data);
        p = p->next;
    }
    printf("\n");
}

int main()  
{  
    int n, m;
    LinkList La, Lb, Lc;
    //初始化指针，修改了链表的头指针，故要传入指针的指针的类型
    InitList_L(&La);
    InitList_L(&Lb);
    InitList_L(&Lc);
    
    scanf("%d", &n);
    int a[n];
    for (int i = 0; i < n; i++)
        scanf("%d", &a[i]);
    CreateList_L(La, a, n);
    
    scanf("%d", &m);
    int b[m];
    for (int i = 0; i < m; i++)
        scanf("%d", &b[i]);
    CreateList_L(Lb, b, m);

    ListIntersection_L(La, Lb, Lc);

    LinkedListPrint(Lc);
    
    return 0;
}

```



#### 2.将链表的最小值移动到链表的头部

```c
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

#define ERROR 0
#define OK 1

typedef int ElemType;
typedef int Status;

// Definition of a node structure for a singly linked list
typedef struct L_node 
{
    ElemType data;           // Data field
    struct L_node *next;     // Pointer field
} LNode, *LinkedList;

//===========================================
// Initialize a singly linked list L with a head node
//===========================================
Status InitList_L(LinkedList *L)
{
    *L = (LNode*)malloc(sizeof(LNode));
    if (!(*L))     return ERROR;
    (*L)->next = NULL;
    return OK;
}

//===========================================
// Create a singly linked list L with a head node, and with n elements
//===========================================
Status CreateList_L(LinkedList *L, ElemType a[], int n)
{
    if (n <= 0)    return ERROR;
    LNode *r = *L;  // r points to the head node
    int j = 0;
    for (; j < n; j++)
    {
        LNode *p = (LNode*)malloc(sizeof(LNode));  // Create a new node
        if (!p)   return ERROR; 
        p->data = a[j];  // Assign data to the new node
        p->next = NULL;  // Set next pointer to NULL

        r->next = p;     // Link the new node to the list
        r = p;           // Move r to the newly added node
    }
    return OK;
}

//===========================================
// Find the minimum value in an array
//===========================================
int find_Min(int arr[], int n)
{
    int min = arr[0], i = 1;
    for (; i < n; i++)
    {
        if (arr[i] < min)     min = arr[i];
    }
    return min;
}

//===========================================
// Move the node containing the minimum value to the head of the linked list
//===========================================
void MoveMinNode_L(LinkedList L, ElemType minval)
{
    // 如果链表为空或者输入无效，无需操作
    if (!L || !L->next)   return;
        
    // 用于跟踪最小值节点前面的节点
    LNode *prev = NULL;

    // 遍历链表的指针
    LNode *cur = L->next;

    // 寻找包含最小值的节点
    while (cur && cur->data != minval)
    {
        prev = cur;
        cur = cur->next;
    }

    // 如果找不到最小值或者最小值已经在链表头部，无需移动
    if (!cur || cur == L->next)    return;

    // 将包含最小值的节点从当前位置分离出来
    prev->next = cur->next;

    // 将分离的节点插入到链表头部
    cur->next = L->next;
    L->next = cur;
}


//void MoveMinNode_L(LinkedList L, ElemType minval)
//
//{
//	if(!L->next) return;
//	LNode* r = L;
//	while(r && r->next->data != minval)	r = r->next;//找到minval的前一个结点 
	//类似于进行一个删除操作 
//	LNode* p = r->next;
//	r->next = p->next;
// 	free(p);
	//类似进行一个插入操作 
// 	LNode *s = L;
//	LNode*q;
//	q = (LNode*)malloc(sizeof(LNode));
//	q->data = minval;
//	q->next = s->next;
//	s->next = q;
//}


//===========================================
// Print the elements in a linked list
//===========================================
void LinkedListPrint(LinkedList L)
{
    LNode *p = L->next;
    while (p)
    {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}

int main()
{
    int n;
    scanf("%d", &n);

    int arr[n];
    int i; 
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    int min = find_Min(arr, n);
    //printf("Minimum value: %d\n", min);
    printf("%d\n",min);

    LinkedList L;
    if (InitList_L(&L) == ERROR)
    {
        printf("Error: Failed to initialize the list.\n");
        return 1;
    }

    if (CreateList_L(&L, arr, n) == ERROR)
    {
        printf("Error: Failed to create the list.\n");
        return 1;
    }

    MoveMinNode_L(L, min);
    //printf("List after moving the minimum value to the head: ");
    LinkedListPrint(L);

    return 0;
}

```



#### 3. 单链表基本操作与应用



```c
#include <stdio.h>
#include <stdlib.h>

// 定义函数执行结果状态代码
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE 0

// 定义新的函数运行结果类型
typedef int Status;

// 动态单链表的结点结构体定义
typedef int ElemType;
typedef struct LNode 
{
    ElemType data;          // 数据域
    struct LNode* next;     // 指针域
} LNode, *LinkList;

// 初始化链表
Status InitList(LinkList *L) 
{
    int x, i;
    // 创建头结点
    *L = (LinkList)malloc(sizeof(LNode));
    if (*L == NULL) 
    {
        printf("内存分配失败\n");
        return ERROR;
    }
    (*L)->next = NULL;

    // 根据键盘输入构建链表
    LinkList r = *L;
    for (i = 0;; i++) 
    {
        scanf("%d", &x);
        if (x == -1)
            break;
        LinkList p = (LinkList)malloc(sizeof(LNode));
        if (!p) 
        {
            printf("初始化失败\n");
            return ERROR;
        }
        p->data = x;
        p->next = NULL;
        r->next = p;
        r = p;
    }
    return OK;
}

// 销毁链表
Status DestroyList(LinkList *L) 
{
    LinkList p;
    while (*L) 
    {
        p = (*L)->next; // p指向下一个结点
        free(*L);       // 释放L
        *L = p;
    }
    return OK;
}

// 判断链表是否为空
Status ListEmpty(LinkList L) 
{
    return (L->next == NULL);
}

// 清空链表
Status ClearList(LinkList L) 
{
    LinkList p, q;
    p = L->next; // p指向链表第一个结点
    while (p)    // 当p指向空时循环结束
    {
        q = p->next;
        free(p);
        p = q;
    }
    L->next = NULL; // 头结点指针域为空
    return OK;
}

// 获取链表的长度
int ListLength(LinkList L) 
{
    LNode *p = L;
    int len = 0;
    while (p->next) 
    {
        len++;
        p = p->next;
    }
    return len;
}

// 删除链表中的第i个元素，并将删除的元素值存储到e中
Status ListDelete(LinkList L, int i, ElemType* e) 
{
    LinkList p = L;
    int j = 0; // 计数器
    // 当第i个结点为空，或者j = i-1时结束循环，此时p指向第i-1个结点
    while (p->next && j < i - 1) 
    {
        p = p->next;
        j++;
    }

    if (!(p->next) || j > i - 1)    return ERROR;

    LinkList q = p->next;   // q保存删除结点地址
    p->next = p->next->next; // 删除
    *e = q->data;           // e存放删除节点的数据
    free(q);                // 释放
    return OK;
}

// 遍历输出链表
Status ListTraverse(LinkList L) 
{
    LinkList p = L->next;
    while (p) // 当p为空时结束循环
    {
        printf("%d ", p->data); // 每一个数据都进行visit函数操作，例如visit可以是打印函数
        p = p->next;
    }
    printf("\n");
    return OK;
}

// 在第i个位置插入元素e
Status ListInsert(LinkList L, int i, ElemType e) 
{
    LinkList p = L;
    int j = 0;
    while (p && j < i - 1) 
    {
        p = p->next;
        ++j;
    }
    if (!p || j > i - 1)   return ERROR;
    LNode *r = (LNode*)malloc(sizeof(LNode));
    if (!r)      return ERROR;
    r->data = e;
    r->next = p->next;
    p->next = r;
    return OK;
}

// 对链表进行操作
Status ListOperate(LinkList L) 
{
    if (ListEmpty(L)) 
    {
        printf("0 0\n");
        return OK;
    }

    int max = L->next->data, min = L->next->data;
    LNode *p = L->next;
    while (p) 
    {
        if (max < p->data)        max = p->data;
        if (min > p->data)		  min = p->data;
        p = p->next;
    }

    ListInsert(L, 1, max);
    ListInsert(L, ListLength(L) + 1, min);
    return OK;
}

int main() 
{
    // 初始化链表
    LinkList L;
    if (InitList(&L) == ERROR)       return 0;
    ListTraverse(L);    // 打印输出初始链表
    printf("%d\n", ListLength(L)); // 打印链表长度

    ListOperate(L);     // 对链表进行操作

    ListTraverse(L);    // 打印输出操作后的链表
    DestroyList(&L);    // 销毁链表

    return 0;
}

```



#### 4.使用链栈检验括号匹配

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 100

typedef int Status;
typedef char SElemType;

// 定义链表栈节点结构
typedef struct StackNode {
    SElemType data;
    struct StackNode *next;
} StackNode, *LinkStack;

// 函数声明
Status InitStack(LinkStack *S);
Status StackEmpty(LinkStack S);
Status Push(LinkStack *S, char ch);
Status Pop(LinkStack *S, char *ch);
Status GetTop(LinkStack S, char *e);
Status match(char element_l, char element_r);

// 初始化链表栈
Status InitStack(LinkStack *S) {
    (*S) = (LinkStack)malloc(sizeof(StackNode));
    if (!(*S))
        return ERROR;
    (*S)->next = NULL;
    return OK;
}

// 判断栈是否为空
Status StackEmpty(LinkStack S) {
    return S->next == NULL ? TRUE : FALSE;
}

// 元素入栈
Status Push(LinkStack *S, char ch) {
    LinkStack s = (LinkStack)malloc(sizeof(StackNode));
    if (!s)
        return ERROR;
    s->data = ch;
    s->next = (*S)->next;
    (*S)->next = s;
    return OK;
}

// 元素出栈
Status Pop(LinkStack *S, char *ch) {
    if (StackEmpty(*S))
        return ERROR;
    LinkStack p = (*S)->next;
    *ch = p->data;
    (*S)->next = p->next;
    free(p);
    return OK;
}

// 获取栈顶元素
Status GetTop(LinkStack S, char *e) {
    if (StackEmpty(S))
        return ERROR;
    *e = S->next->data;
    return OK;
}

// 检查两个括号是否匹配
Status match(char element_l, char element_r) {
    if (element_l == '(') {
        return (element_r == ')') ? TRUE : FALSE;
    } else if (element_l == '[') {
        return (element_r == ']') ? TRUE : FALSE;
    } else if (element_l == '{') {
        return (element_r == '}') ? TRUE : FALSE;
    } else {
        exit(0);
    }
}

int main() {
	//SetConsoleOutputCP(65001);
    LinkStack S;
    char e;
    int length = 0,i;
    char str[MAXSIZE];

    InitStack(&S);
    scanf("%s", str); // 输入一串括号
    length = strlen(str);

    for (i = 0; i < length; i++) {
        switch (str[i]) {
            case '(':
            case '[':
            case '{':
                Push(&S, str[i]);
                break;
            case ')':
            case ']':
            case '}':
                if (StackEmpty(S)) {
                    printf("右括号多余\n");
                    exit(0);
                } else {
                    GetTop(S, &e);
                    if (match(e, str[i])) {
                        Pop(&S, &e);
                    } else {
                        printf("左右括号不匹配\n");
                        exit(0);
                    }
                }
                break;
            default:
                exit(0);
        }
    }

    if (StackEmpty(S)) {
        printf("括号匹配\n");
    } else {
        printf("左括号多余\n");
    }

    return 0;
}


```



#### 5. 合并两个有序链表

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef int ElemType;
typedef int Status;

// Definition of node structure of singly linked list
typedef struct L_node
{
    ElemType data;           // data field 
    struct L_node *next;     // pointer field
} LNode, *LinkedList;

// Initialize a singly linked list L with head node
Status InitLinkList(LinkedList *L)
{
    (*L) = (LNode *) malloc(sizeof(LNode));
    if (!(*L))     return ERROR;
    (*L)->next = NULL;
    return OK;
}

// Create a singly linked list L with head node, and with n elements
Status CreateList_L(LinkedList L, int a[], int n)
{
    LNode *p = L;
    int i = 0;
    for (i = 0; i < n; i++)
    {
        LNode *r = (LNode *) malloc(sizeof(LNode));
        if (!r)
            return ERROR;
        r->data = a[i];
        r->next = NULL;
        p->next = r;
        p = r;
    }
    return OK;
}

// Merge two singly linked lists La and Lb into Lc
void Merge_L(LinkedList *La, LinkedList *Lb, LinkedList *Lc)
{
    LNode *a = (*La)->next;
    LNode *b = (*Lb)->next;
    LNode *c = (*Lc);
    LNode *c1;

    while (a && b)
    {
        c1 = (LNode *) malloc(sizeof(LNode));
        if (!c1)    return; // Allocation failed

        if (a->data <= b->data)
        {
            c1->data = a->data;
            a = a->next;
        } else
        {
            c1->data = b->data;
            b = b->next;
        }
        c1->next = NULL;
        c->next = c1;
        c = c1;
    }

    while (a)
    {
        c1 = (LNode *) malloc(sizeof(LNode));
        if (!c1)    return; // Allocation failed
        c1->data = a->data;
        c1->next = NULL;
        c->next = c1;
        c = c1;
        a = a->next;
    }

    while (b)
    {
        c1 = (LNode *) malloc(sizeof(LNode));
        if (!c1)   return;
		c1->data = b->data;
        c1->next = NULL;
        c->next = c1;
        c = c1;
        b = b->next;
    }
}

// Print the elements in a list
void LinkedListPrint(LinkedList L)
{
    LNode *p = L->next;
    while (p)
    {
        printf("%d ", p->data);
        p = p->next;
    }
}

int main()
{
    LNode *La, *Lb, *Lc;
    InitLinkList(&La);
    InitLinkList(&Lb);
    InitLinkList(&Lc);

    int n, m;
    scanf("%d", &n);
    int a[n];
    int i = 0;
    for (i = 0; i < n; i++)     scanf("%d", &a[i]);

    CreateList_L(La, a, n);

    scanf("%d", &m);
    int b[m];
    for (i = 0; i < m; i++)     scanf("%d", &b[i]);

    CreateList_L(Lb, b, m);

    Merge_L(&La, &Lb, &Lc);

    LinkedListPrint(Lc);

    return OK;
}  

```



#### 6.链表删除



```c
#include <stdio.h>   
#include <stdlib.h>   
#include <malloc.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef int ElemType;
typedef int Status;

// definition of node structure of singly linked list
typedef struct L_node
{
    ElemType data;           // data field 
    struct L_node* next;       // pointer field
}LNode, * LinkList;

//===========================================
// Initialize  a singly linked list L with head node
//===========================================

Status InitList_L(LinkList *L)

{
	(*L) = (LNode*)malloc(sizeof(LNode));
	(*L)->next = NULL;
	return OK;
}

//===========================================
// Create a singly linked list L with head node, and with n elements
//===========================================

Status CreateList_L(LinkList* L, ElemType a[], int n)
{
	LNode *p = *L;
	int j = 0;
	for(;j < n;j ++)
	{
		LNode*r ;
		r = (LNode*)malloc(sizeof(LNode));
		r->data = a[j];
		r->next = NULL;
		p->next = r;
		p = r;
	}
	return OK;
}

void Delete_List(LinkList L,int i)
{
	LNode*prev = L;
	int j = 0;
	while(prev && j < i - 1)
	{
		prev = prev->next;
		j ++;
	}
	if(!prev || j > i - 1) return ;
	LinkList r = prev->next;
	prev->next = r->next;
	free(r);
	return ;
}
//===========================================
//  删除位序为偶数的结点，并返回删除结点的总数
//===========================================

int Delete_L(LinkList *L,int len)
{
	int i = len / 2;
	int j = 2 * i;
	int count = 0;
	for(;j >1;j -=2)	
	{
		Delete_List(*L,j);
		count ++;
	}
	return count;
}
//======================================
// Print the elements in a list
//=======================================

void LinkedListPrint(LinkList L)

{
	LNode *p = L->next;
	while(p)
	{
		printf("%d ",p->data);
		p = p->next;
	}
	return;
}

int main()
{
	LNode *L;
	InitList_L(&L);
	int i = 0,n;
	scanf("%d",&n);
	int arr[n];
	for(;i < n;i ++) scanf("%d",&arr[i]);
	CreateList_L(&L,arr,n);
	int tot = Delete_L(&L,n);
	printf("%d\n",tot);
	LinkedListPrint(L);
	return OK;
}
```



#### 7.链表拼接

```c
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef int ElemType;
typedef int Status;

// definition of node structure of singly linked list
typedef struct L_node
{
    ElemType data;           // data field 
    struct L_node *next;       // pointer field
} LNode, *LinkedList;

//===========================================
// Initialize  a singly linked list L with head node
//===========================================
Status InitList_L(LinkedList *L)
{
    *L = (LNode *) malloc(sizeof(LNode));
    if (!(*L)) return ERROR;
    (*L)->next = NULL;
    return OK;
}

//===========================================
// Create a singly linked list L with head node, and with n elements
//===========================================

Status CreateList_L(LinkedList *L, int a[], int n)
{
    LNode *r = (*L);
    int i = 0;
    for (; i < n; i++)
    {
        LNode *p;
        p = (LNode *) malloc(sizeof(LNode));
        p->data = a[i];
        p->next = NULL;
        r->next = p;
        r = p;
    }
    return OK;
}

//===========================================
//  Merge two singly linked lists 
//===========================================

int Merge_L(LinkedList *ha, int len_a, LinkedList *hb, int len_b, LinkedList *hc)
{
    LNode *a = (*ha)->next;
    LNode *b = (*hb)->next;
    LNode *c = *hc;
    LNode *c1;
    c1 = (LNode *) malloc(sizeof(LNode));
    if (len_a > len_b)
    {
        while (b)
        {
            c1 = b;
            c->next = c1;
            c = c1;
            b = b->next;
        }
        while (a)
        {
            c1 = a;
            c->next = c1;
            c = c1;
            a = a->next;
        }
    } 
    else
    {
        while (a)
        {
            c1 = a;
            c->next = c1;
            c = c1;
            a = a->next;
        }
        while (b)
        {
            c1 = b;
            c->next = c1;
            c = c1;
            b = b->next;
        }
    }
}

//======================================
// Print the elements in a list
//=======================================

void LinkedListPrint(LinkedList L)
{
    LNode *p = L->next;
    while (p)
    {
        printf("%d ", p->data);
        p = p->next;
    }
}

int main()
{
    LNode *La;
    LNode *Lb;
    LNode *Lc;
    InitList_L(&La);
    InitList_L(&Lb);
    InitList_L(&Lc);
    int n, m, i = 0;
    scanf("%d", &n);
    int a[n];
    for (; i < n; i++) scanf("%d", &a[i]);
    CreateList_L(&La, a, n);
    scanf("%d", &m);
    int b[m];
    for (i = 0; i < m; i++) scanf("%d", &b[i]);
    CreateList_L(&Lb, b, m);
    Merge_L(&La, n, &Lb, m, &Lc);
    LinkedListPrint(Lc);
	return OK;
}  
```



#### 双向链表学习代码：

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1

typedef int ElemType;
typedef int Status;

typedef struct DuLNode
{
    ElemType data;          // 数据域
    struct DuLNode *prior;  // 指向直接前驱
    struct DuLNode *next;   // 指向直接后继
} DuLNode, *DuLinkList;

Status GetElem_DuL(DuLinkList L, int i, ElemType *e)
{
    int j;
    DuLinkList p;
    p = L->next; // p指向第一个结点
    j = 1;
    while (p && j < i)
    {
        p = p->next;
        ++j;
    }
    if (!p || j > i)
        return ERROR; // 第i个元素不存在
    *e = p->data;     // 取第i个元素的数据
    return OK;
}

Status ListInsert_DuL(DuLinkList *L, int i, ElemType e)
{
    DuLinkList p, s;
    if (i < 1) // 如果位置不合法
        return ERROR;

    s = (DuLinkList) malloc(sizeof(DuLNode));
    if (!s)
        exit(EXIT_FAILURE); // 内存分配失败，退出程序
    s->data = e;

    if (i == 1 || !(*L)->next)
    { // 在第一个位置插入或者链表为空时
        s->next = (*L)->next;
        if ((*L)->next) // 如果链表不为空
            (*L)->next->prior = s;
        s->prior = *L;
        (*L)->next = s;
        return OK;
    }

    p = (*L)->next;
    while (--i && p) p = p->next; // 找到第 i-1 个节点
    if (!p) // 如果位置超出链表长度
        return ERROR;

    s->next = p->next;
    s->next->prior = s;
    s->prior = p;
    p->next = s;
    return OK;
}


Status ListDelete_DuL(DuLinkList *L, int i)
{
    DuLinkList p, q;
    int j = 1;
    p = *L; // 将 p 指向头节点
    while (p->next && j < i)
    {
        p = p->next;
        ++j;
    }
    if (!p->next || j > i)
        return ERROR; // 第i个元素不存在
    q = p->next;
    p->next = q->next;
    if (q->next) // 如果 q 的下一个节点不为空
        q->next->prior = p;
    free(q);
    return OK;
}


int main()
{
    DuLinkList L;
    L = (DuLinkList) malloc(sizeof(DuLNode));
    if (!L)
        exit(EXIT_FAILURE); // 内存分配失败，退出程序
    L->next = NULL;
    ElemType e;
    if (ListInsert_DuL(&L, 1, 10) == OK)
        printf("Insert successful!\n");
    if (GetElem_DuL(L, 1, &e) == OK)
        printf("The first element is: %d\n", e);
    if (ListDelete_DuL(&L, 1) == OK)
        printf("Delete successful!\n");
    //system("pause");
    return 0;
}

```



### 作业4——栈



#### 学习代码：

```c
#include <stdio.h>
#include <malloc.h>
#include <string.h>

typedef int SElemType ;
typedef int Status;

#define ERROR 0
#define OK 1
#define MAXSIZE 100
typedef struct
{
    SElemType *base;
    SElemType *top;
    int stackSize;
}SqStack;

Status InitStack(SqStack *S)
{
    S->base = (SElemType*) malloc(sizeof (SqStack));
    if(!S->base)    return ERROR;
    S->top = S->base;//top 初始为 base ,空栈
    S->stackSize = MAXSIZE;
    return OK;
}

Status Push(SqStack *S,SElemType e)
{
    if(S->top - S->base == S->stackSize)    return ERROR;//栈满
    *S->top ++= e;//将元素e压入栈顶，栈顶指针加1
    return OK;
}

Status Pop(SqStack *S,SElemType *e)
{
    if(S->base == S->top)   return ERROR;//栈空
    *e = *--S->top;//栈顶指针减1，将栈顶元素赋给e
    return OK;
}

SElemType GetTop(SqStack S)
{//返回S的栈顶元素，不修改栈顶指针
    if(S.top != S.base)   return *(S.top - 1);//返回栈顶元素的值，栈顶指针不变
}

Status destorystack(stack *p)//毁坏
{
	free(p->base);
	p->base=NULL;
	p->top=NULL;
	p->stacksize=0;
	if(!p->base)
		printf("栈被毁坏成功！！！\n");
	return OK;
}

```



```c
//将中缀表达式转化为逆波兰表达式
#include <stdio.h>
#include <stdlib.h>


typedef struct
{
	char *base;
	char *top;
	int stackSize;
}sqStack;

void InitStack(sqStack *s)
{
	s->base = (char *)malloc(100*sizeof(char));
	s->top = s->base;
	s->stackSize = 100; 
}

void Push(sqStack *s, char e)
{
	*(s->top) = e;
	s->top++; 
}

int Pop(sqStack *s, char *e)
{
	if(s->top == s->base)
	{
		return 0;	
	}
	*e = *--(s->top);	
	return 0;
} 

int StackLen(sqStack s)
{
	return (s.top - s.base);
}

int main(void)
{
	sqStack s;
	char c, e;
	
	InitStack(&s);
	printf("Input: \n");
	scanf("%c", &c);
	
	while(c != '#')
	{
		while(c>='0' && c<='9')
		{
			printf("%c", c);
			scanf("%c", &c);
			if(c<'0' || c>'9')
			{
				printf(" ");
			}
		}
		
		if(c == ')')
		{
			Pop(&s, &e);
			while(e != '(')
			{
				printf("%c", e);
				Pop(&s, &e);
			}
		}
		else if('+' == c || c=='-')
		{
			if(StackLen(s) == 0)
			{
				Push(&s, c);
			}
			else
			{
				do
				{
					Pop(&s, &e);
					if(e == '(')
					{
						Push(&s, e);
					}
					else
					{
						printf("%c", e);
					}
				}while(StackLen(s) && e != '(');
				Push(&s, c);
			}
		}
		else if('*' == c || '/'==c || '('==c)
		{
			Push(&s, c);
		}
		else if('#' == c)
		{
			break;
		}
		else
		{
			printf("error!");
			return -1;
		}
		scanf("%c", &c);	
	}
	while(StackLen(s) != 0)
	{
		Pop(&s, &e);
		printf("%c ", e);
	}
	return 0;	
} 
```



```c
//计算逆波兰表达式的result

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

typedef struct
{
	double *base;
	double *top;
	int stackSize;
}sqStack;

void InitStack(sqStack *s)
{
	s->base = (double *)malloc(100*sizeof(double));
	s->top = s->base;
	s->stackSize = 100;
}

void Push(sqStack *s, double e)
{
	*(s->top) = e;
	s->top++;
}

void Pop(sqStack *s, double *e)
{
	s->top = s->top-1;
	*e = *(s->top);
}

int main(void)
{
	char c;
	double d, e, f, g;
	char str[100];
	int i = 0;
	
	sqStack s;
	InitStack(&s);
	
	printf("input: \n");
	scanf("%c", &c);
	while(c != '#' )
	{
		while(isdigit(c) || c=='.')
		{
			str[i++] = c;
			str[i] = '\0';
			scanf("%c", &c);
			if(c == ' ')
			{
				d = atof(str);
				Push(&s, d);
				i = 0;
				break;
			}
		}
		switch(c)
		{
			case '+':
				Pop(&s, &e);
				Pop(&s, &f);
				g = f+e;
				Push(&s, g);
				break;
			case '-':
				Pop(&s, &e);
				Pop(&s, &f);
				g = f-e;
				Push(&s, g);
				break;
			case '*':
				Pop(&s, &e);
				Pop(&s, &f);
				g = f*e;
				Push(&s, g);
				break;
			case '/':
				Pop(&s, &e);
				Pop(&s, &f);
				if(e != 0)
				{
					g = f/e;
					Push(&s, g);
					break;
				}
				else
				{
					printf("error!\n");
					break;
				}
	 
		}
		scanf("%c", &c);
	}
	
	Pop(&s, &d);
	printf("Result is: %f\n", d);
	return 0;
}
```



#### 1.堆栈练习题

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0

struct Stack
{
    int top;
    unsigned capacity;
    char *array;
};

struct Stack* createStack(unsigned capacity)
{
    struct Stack *stack = (struct Stack *)malloc(sizeof(struct Stack));
    if (stack == NULL) 
    {
        printf("Memory allocation failed!\n");
        exit(EXIT_FAILURE);
    }
    stack->capacity = capacity;
    stack->top = -1;
    stack->array = (char*)malloc(stack->capacity * sizeof(char));
    if (stack->array == NULL) 
    {
        printf("Memory allocation failed!\n");
        exit(EXIT_FAILURE);
    }
    return stack;
}

int isFull(struct Stack stack)
{
	int full = 0;   
	/*在表达式 (int)stack.capacity 中，stack.capacity 是 unsigned 类型的无符号整数，
	  而 (int) 是将其强制转换为有符号整数类型 int。
	  这个强制转换的目的是为了避免比较不同类型的数据时出现警告或错误*/
	full = (stack.top == (int)stack.capacity - 1)?1:0;
	return full;
}

int isEmpty(struct Stack stack)
{
	return (stack.top == -1) ? 1 :0;
}

void push(struct Stack *stack, char item)
{
    if (!isFull(*stack)) 
    {
        stack->array[++stack->top] = item;
    } 
    else 
    {
        printf("Stack is full. Cannot push element.\n");
    }
}

char pop(struct Stack *stack)
{
    if (!isEmpty(*stack)) 
    {
        return stack->array[stack->top--];
    } 
    else 
    {
        printf("Stack is empty. Cannot pop element.\n");
        return '\0';
    }
}

void reverseStr(char *str)
{
    int length = strlen(str);
    struct Stack* stack = createStack(length + 1);
    for (int i = 0; i < length; i++) 
    {
        push(stack, str[i]);
    }
    for (int i = 0; i < length; i++) 
    {
        str[i] = pop(stack);
    }
    printf("%s\n", str);
}

int main()
{
    char str[] = "ILoveChina, ILoveBJTU, ILoveGJCXSJXL";
    reverseStr(str);
    return 0;
}

```



####    2. 栈-创建堆栈

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef int SElemType;
typedef int Status;

#define STACK_INIT_SIZE   100     // 初始栈大小
#define STACKINCREMENT    10      // 栈增量大小

typedef struct {
    SElemType *base;    // 栈底指针
    SElemType *top;     // 栈顶指针
    int stacksize;      // 当前栈容量
} SqStack;

Status InitStack(SqStack *S) 
{
    S->base = (SElemType *)malloc(sizeof(SElemType) * STACK_INIT_SIZE);
    if (!S->base)      return ERROR;
    S->top = S->base;
    S->stacksize = STACK_INIT_SIZE;
    return OK;
}

Status StackEmpty(SqStack S) 
{
    return (S.top == S.base) ? TRUE : FALSE;
}

int StackLength(SqStack S) 
{
    return (S.top - S.base);
}

Status GetTop(SqStack S, SElemType *e) 
{
  if (StackEmpty(*S))      return ERROR;
    *e = *(S.top - 1);
    return OK;
}

Status Pop(SqStack *S, SElemType *e) 
{
    if (StackEmpty(*S))      return ERROR;
    *e = *(--S->top);
    return OK;
}

Status Push(SqStack *S, SElemType e) 
{
    if (S->top - S->base >= S->stacksize) 
    {
        //内存不够，重新分配空间
        S->base = (SElemType *)realloc(S->base, (S->stacksize + STACKINCREMENT) * sizeof(SElemType));
        if (!S->base)        return ERROR;
        S->top = S->base + S->stacksize;
        S->stacksize += STACKINCREMENT;
    }
    *(S->top++) = e;
    return OK;
}

void PrintStack(SqStack S) 
{
    int len = StackLength(S);
    for (int i = 0; i < len; i++) 
    {
        SElemType e;
        Pop(&S, &e);
        printf("%d ", e);
    }
    printf("\n");
}

int reverseOutput(SqStack S) 
{
    if (StackEmpty(S))      return ERROR;
    PrintStack(S);
    return StackLength(S);
}

int main() 
{
    SqStack S;
    InitStack(&S);
    int n, i = 0;
    scanf("%d", &n);
    int arr[n];
    for (; i < n; i++) 
    {
        scanf("%d", &arr[i]);
        Push(&S, arr[i]);
    }
    printf("%d", reverseOutput(S));
    return OK;
}

```



#### 3. 栈-比较含退格的字符串

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef char ElemType;
typedef int Status;

#define STACK_INIT_SIZE   100          // Initial size for memory allocation
#define STACKINCREMENT    10           // Incremental size

typedef struct 
{
    ElemType  *base;    // Base pointer
    ElemType  *top;     // Top pointer
    int        stacksize;     // Current size
} SqStack;

Status InitStack(SqStack *S) 
{
    S->base = (ElemType *)malloc(STACK_INIT_SIZE * sizeof(ElemType));
    if (!S->base) return ERROR;
    S->top = S->base;
    S->stacksize = STACK_INIT_SIZE;
    return OK;
}

Status StackEmpty(SqStack S)
{
    return S.base == S.top ? TRUE : FALSE;
}

int StackLength(SqStack S) 
{
    return S.top - S.base;
}

Status GetTop(SqStack S, ElemType *e) 
{
    if (StackEmpty(S)) return ERROR;
    *e = *(S.top - 1);
    return OK;
}

Status Pop(SqStack *S, ElemType *e)
{
    if (StackEmpty(*S)) return ERROR;
    *e = *--S->top;
    return OK;
}

Status Push(SqStack *S, ElemType e) 
{
    if (S->top - S->base >= S->stacksize)
    {
        S->base = (ElemType *)realloc(S->base, (S->stacksize + STACKINCREMENT) * sizeof(ElemType));
        if (!S->base) return ERROR;
        S->top = S->base + S->stacksize;
        S->stacksize += STACKINCREMENT;
    }
    *S->top++ = e;
    return OK;
}

int CompareString(char *S,  char *T)
{
    SqStack stack_S, stack_T;
    InitStack(&stack_S);
    InitStack(&stack_T);
    
    for (int i = 0; S[i] != '\0'; i++) 
    {
        if (S[i] != '#')     Push(&stack_S, S[i]);
        else 
        {
            if (!StackEmpty(stack_S)) 
            {
                ElemType temp;
                Pop(&stack_S, &temp);
            }
        }
    }
    
    for (int i = 0; T[i] != '\0'; i++) 
    {
        if (T[i] != '#')        Push(&stack_T, T[i]); 
        else 
        {
            if (!StackEmpty(stack_T)) 
            {
                ElemType temp;
                Pop(&stack_T, &temp);
            }
        }
    }
    
    if (StackLength(stack_S) != StackLength(stack_T))      return FALSE;
    while (!StackEmpty(stack_S)) 
    {
        ElemType charS, charT;
        Pop(&stack_S, &charS);
        Pop(&stack_T, &charT);
        if (charS != charT)      return FALSE;
    }
    return TRUE;
}

int main() 
{
    char s[1000], t[1000];
    scanf("%s", s);
    scanf("%s", t);
    
    int res = CompareString(s, t);
    if (res)   printf("true");
    else 		printf("false");

    return 0;
}

```



#### 4. 820230003栈基本操作与应用



```c
#define BASE 17

#include <stdio.h>
#include <stdlib.h>

#define Status int
#define SElemType char

#define STACK_INIT_SIZE 100        //存储空间的初始分配量
#define STACKINCREMENT  10          //存储空间的分配增量
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0

//栈数据结构
typedef struct Stack 
{
    SElemType *base;    //栈底指针
    SElemType *top;     //栈顶指针
    int stacksize;      //栈可用的最大容量
} SqStack;

//初始化函数
Status InitStack(SqStack *S) 
{
    S->base = (SElemType *)malloc(STACK_INIT_SIZE * sizeof(SElemType));
    if (!S->base) 
    {
        printf("init fail\n");
        return ERROR;
    }
    S->top = S->base;     //栈顶指针与栈底相同
    S->stacksize = STACK_INIT_SIZE;
    return OK;
}

//销毁 
Status DestroyStack(SqStack *S) 
{
    //补全代码
	free(S->base);
	S->base = NULL;
	S->top = NULL;  
	S->stacksize = 0;
	if(S->base)	
	{
		printf("Fail Destroy");
		return ERROR;
	}
	return OK;
}

//清空 
Status ClearStack(SqStack *S) 
{
    S->top = S->base;
    return OK;
}

//判断是否为空 
Status StackEmpty(SqStack S) 
{
    if (S.top == S.base) 
        return TRUE;
    else
        return FALSE;
}

int StackLength(SqStack S) 
{
    return S.top - S.base;
}

//得到栈顶元素，不修改指针
Status GetTop(SqStack S, SElemType *e) 
{ 
    if (S.top == S.base) 
        return ERROR;
    *e = *(S.top - 1);
    return OK;
}

//入栈
Status Push(SqStack *S, SElemType e) 
{
    if (S->top - S->base >= S->stacksize) 
    {  //栈满,追加存储空间
        S->base = (SElemType *)realloc(S->base, (S->stacksize + STACKINCREMENT) * sizeof(SElemType));
        if (!S->base) 
            return ERROR;
        S->top = S->base + S->stacksize;
        S->stacksize += STACKINCREMENT;
    }
    *S->top++ = e;
    return OK;
}

//出栈
Status Pop(SqStack *S, SElemType *e) 
{
    if (S->top == S->base) 
        return ERROR;    //栈空
    *e = *--S->top;
    return OK;
}

//遍历栈
Status StackTraverse(SqStack S) 
{
    if (S.base == NULL)
        return ERROR;
    if (S.top == S.base)
        printf("empty\n");
    SElemType *p;
    p = S.top;
    while (p > S.base) 
    {
        p--;
        printf("%c", *p);//从栈顶开始打印，而且未修改栈顶指针 
    }
    return OK;
}

void conversion(SqStack *S) 
{
    //补全代码
    int decimal = 0;
    scanf("%d",&decimal);
    char base17[20] = "0123456789ABCDEFG";
    while(decimal)
    {
    	int index = decimal % 17;
    	Push(S,base17[index]);
    	decimal /=17;
	}
	StackTraverse(*S);
}

//主函数
int main() 
{
    SqStack S;
    InitStack(&S);
    conversion(&S);
    DestroyStack(&S);
    return 0;
}

```



#### 5. 实验4 栈实验1



```c
#include <stdio.h>

#include <string.h>

#include <stdlib.h>


#define STACK_INIT_SIZE    20     /*存储空间的初始分配量*/

#define STACK_INCREMENT    10     /*存储空间的分配增量*/

//#define CHAR_MAX 127

#define DBL_MAX 100

#define ERROR 0

#define OK 1


/*数据栈结构体定义，要求：

包括栈底指针，栈顶指针和当前分配的存储容量*/

typedef struct
{

    double *Dbase;

    double *Dtop;

    int Dstacksize;

} DataStack;


/*操作符结构体定义，要求包括栈底指针，栈顶指针和当前分配的存储容量*/

typedef struct
{

    char *Obase;

    char *Otop;

    int Ostacksize;

} OpStack;


/*静态二维优先级数组：static char OperationPreceder[7][7]   

定义操作符＋、－、＊、／、（、）、=的运算优先级*/

static char OperationPreceder[7][7] =

        {{'>', '>', '<', '<', '<', '>', '>'},

         {'>', '>', '<', '<', '<', '>', '>'},

         {'>', '>', '>', '>', '<', '>', '>'},

         {'>', '>', '>', '>', '<', '>', '>'},

         {'<', '<', '<', '<', '<', '=', 'x'},

         {'>', '>', '>', '>', 'x', '>', '>'},

         {'<', '<', '<', '<', '<', 'x', '='}

        };


/*函数接口定义为：int TransOPtoCD(char op_temp)   

* 输入参数：操作符x   

* 处理规则及返回值：将操作符转化为运算优先级静态表的坐标，并返回；   

* 输入参数非＋、－、＊、／、（、）、=，则返回－1*/

int TransOPtoCD(char op_temp)
{

    switch (op_temp)
    {

        case '+':
            return (0);

        case '-':
            return (1);

        case '*':
            return (2);

        case '/':
            return (3);

        case '(':
            return (4);

        case ')':
            return (5);

        case '=':
            return (6);

        default:
            return (-1);  /*当输入参数不是四则运算、括号、等号时，返回－1*/

    }


}


/*函数接口定义为：char Precede(char op1, char op2)   

* 输入参数：进行比较的运算符op1和op2；   

* 处理规则及返回值：将op1和op2转化为二维数组OperationPreceder的坐标，查找该坐标存储的符号，并作为返回值输出；   

* 如果无法找到坐标则返回0*/

char Precede(char op1, char op2)
{

    int x, y;

    x = y = -1;

    x = TransOPtoCD(op1);

    y = TransOPtoCD(op2);

    if (x != -1 && y != -1)
    {

        //    printf("%c\n", OperationPreceder[x][y]);       

        return OperationPreceder[x][y];

    } else

        return 0;

}


/*函数接口定义为：int checkch (char c)   

* 输入参数：表达式字符c；   

* 处理规则及返回值：判断字符c是数字还是操作符；   

* 如果c是数字返回1，如果是小数点返回2，如果是运算符返回3，否则为无效字符返回－1；   

* 假设：表达式中的所有云算数均为正数*/

int checkch(char c)
{

    if (c >= '0' && c <= '9')

        return 1;

    if (c == '.')

        return 2;

    if (c == '+' || c == '-' || c == '*' || c == '/' || c == '(' || c == ')' || c == '=')

        return 3;

    else

        return 0;

}


/*函数接口定义为：double Operate(double x,double y, char op)；   

* 输入参数：运算数x，被运算数y，操作符op；   

* 处理规则及返回值：进行x op y运算，返回运算结果；默认返回0.0*/

double Operate(double x, double y, char op)
{

    switch (op)
    {

        case '+':

            return x + y;

        case '-':

            return x - y;

        case '*':

            return x * y;

        case '/':

            if (y != 0)

                return x / y;

            else

                printf("The divisor cannot be 0!\n");

            exit(-1);

        default:

            break;

    }

    return 0.0;

}


/*数据栈初始化函数定义，要求：   

* 函数接口定义为：int InitDataStack(DataStack *DS)   

* 输入参数：数据栈DS   

* 处理规则及返回值：从内存堆中申请STACK_INIT_SIZE个整型空间，将栈顶指针与栈底指针都指向初始地址，给Dstacksize赋值STACK_INIT_SIZE   

* 初始化成功返回1，否则返回0.*/

int InitDataStack(DataStack *DS)
{


    //根据注释, 将该函数补充完整
    DS->Dbase = (double*)malloc(sizeof(double));
    if(!DS->Dbase)	return ERROR;
    DS->Dtop = DS->Dbase;
	DS->Dstacksize =  STACK_INIT_SIZE;
	return OK;
	
	
}


/* 数据栈入栈函数定义，要求：   

* 函数接口定义为：int PushDataStack(DataStack *DS,int e)   

* 输入参数：待操作数据栈DS，插入数据e；   

* 处理规则及返回值：在栈顶指针位置存储e，并将栈顶指针位置后移，返回1；   

如果数据栈不存在或者数据栈上溢，返回错误（0）。*/

int PushDataStack(DataStack *DS, double e)
{
	if(!DS->Dbase)	return ERROR;//数据栈不存在
	if(DS->Dtop - DS->Dbase >= DS->Dstacksize)
	{//据栈上溢,重新分配内存 
		DS->Dbase = (double*)realloc(DS->Dbase,(DS->Dstacksize +STACK_INCREMENT ) * sizeof(double));
		if(!DS->Dbase)	return ERROR;
		DS->Dtop = DS->Dbase + DS->Dstacksize;
		DS->Dstacksize += STACK_INCREMENT;
	}
	*(DS->Dtop++) = e;
	return OK;
   // 根据注释, 将该函数补充完整


}


/*数据栈出栈函数定义，要求：   

* 函数接口定义为：int PopDataStack(DataStack *DS, int *e)   

* 输入参数：数据栈DS, 输出整型指针变量e；   

* 处理规则及返回值：将栈顶指针减1，将该地址存储的变量付给＊e，返回1；   

如果数据栈不存在或数据栈为空，返回0。*/

int PopDataStack(DataStack *DS, double *e)
{

    //根据注释, 将该函数补充完整
    if(!DS->Dbase)	return ERROR;
    *e = *--DS->Dtop;
	return OK; 

}


/*数据栈查看栈顶元素函数定义，要求：   

* 函数接口定义为：int GetDataTop(DataStack *DS)   

* 输入参数：数据栈DS, 记录栈顶元素变量e；   

* 处理规则及返回值：如果数据栈不存在或数据栈为空，返回DBL_MAX; 否则，返回栈顶元素。*/

double GetDataTop(DataStack *DS)
{


    //根据注释, 将该函数补充完整
	if(!DS->Dbase)	return DBL_MAX;
	return *(DS->Dtop - 1);
	
}


/*数据栈销毁函数定义，要求：   

* 函数接口定义为：int DestroyDataStack(DataStack *DS   

* 输入参数：数据栈DS   

* 处理规则及返回值：释放栈底指针所指空间，并将数据栈的栈底和栈顶指针置空，数据栈Dstacksize置为0。最后返回1*/

int DestroyDataStack(DataStack *DS)
{

    //根据注释, 将该函数补充完整
    free(DS->Dbase);
	DS->Dbase = NULL;
	DS->Dtop = NULL;
	DS->Dstacksize = 0;
	if(DS->Dbase)	return ERROR;
	return OK;

}


/*符号栈初始化函数定义，要求：   

* 函数接口定义为：int InitOpStack(OpStack *OS)   

* 输入参数：符号栈OS   

* 处理规则及返回值：从内存堆中申请STACK_INIT_SIZE个整型空间，将栈顶指针与栈底指针都指向初始地址，给Dstacksize赋值STACK_INIT_SIZE   

* 初始化成功返回1，否则返回0.*/

int InitOpStack(OpStack *OS)
{

    //根据注释, 将该函数补充完整
    OS->Obase = (char*)malloc(sizeof(char));
    if(!OS->Obase)	return ERROR;
    OS->Otop = OS->Obase;
    OS->Ostacksize = STACK_INIT_SIZE;
    return OK;

}


/* 符号栈入栈函数定义，要求：   

* 函数接口定义为：int PushOpStack(OpStack *OS,int e)   

* 输入参数：待操作符号栈DS，插入符号e；   

* 处理规则及返回值：在栈顶指针位置存储e，并将栈顶指针位置后移，返回1；   

如果符号栈不存在或者符号栈上溢，返回0。*/

int PushOpStack(OpStack *OS, char e)
{


//    根据注释, 将该函数补充完整
	if(!OS->Obase)	return OK;
	if(OS->Otop - OS->Obase >= OS->Ostacksize)	
	{
		OS->Obase = (char*)realloc(OS->Obase,(OS->Ostacksize + STACK_INCREMENT)*sizeof(char));
		
	}
	*OS->Otop++ = e;
}


/* 符号栈出栈函数定义，要求：   

* 函数接口定义为：int PopOpStack(OpStack *OS, int *e)   

* 输入参数：符号栈DS, 输出符号指针变量e；   

* 处理规则及返回值：将栈顶指针减1，将该地址存储的变量付给＊e，返回1；   

如果符号栈不存在或符号栈为空，返回0。*/

int PopOpStack(OpStack *OS, char *e)
{

    //根据注释, 将该函数补充完整
    if(!OS->Obase)	return ERROR;
    *e = *--OS->Otop;
    return OK;

}


/* 符号栈查看栈顶元素函数定义，要求：   

* 函数接口定义为：char GetOpTop(OpStack *OS)   

* 输入参数：数据栈DS, 记录栈顶元素变量e；   

* 处理规则及返回值：如果数据栈不存在或数据栈为空，返回CHAR_MAX; 否则，返回栈顶元素。*/

char GetOpTop(OpStack *OS)
{


    //根据注释, 将该函数补充完整
	if(!OS->Obase)	return ERROR;
	return *(OS->Otop - 1);

}


/* 符号栈销毁函数定义，要求：   

* 函数接口定义为：int DestroyOpStack(OpStack *OS)   

* 输入参数：符号栈DS   

* 处理规则及返回值：释放栈底指针所指空间，并将符号栈的栈底和栈顶指针置空，符号栈Dstacksize置为0。最后返回1*/

int DestroyOpStack(OpStack *OS)
{

    //根据注释, 将该函数补充完整
	free(OS->Obase);
	OS->Obase = NULL;
	OS->Otop = NULL;
	OS->Ostacksize = 0;
	if(OS->Obase)	return ERROR;
	return OK; 

}


int main()
{

    OpStack OPTR = {0};      /*运算符栈*/

    DataStack OPND = {0};    /*操作数栈*/

    char op = 0;             /*当前运算符*/

    double value = 0.0;        /*数字字符的组合结果*/

    double b = 0.0;         /*当前运算的操作数*/

    double a = 0.0;         /*当前运算的被操作数*/

    char expression[1001] = {0};          /*表达式缓存，表达式长度不大于1000个字符*/

    int i = 0;                            /*表达式缓存的当前读取位置*/



    /*数据栈初始化函数定义，要求：   

    * 函数接口定义为：int InitDataStack(DataStack *DS)   

    * 输入参数：数据栈DS   

    * 处理规则及返回值：从内存堆中申请STACK_INIT_SIZE个整型空间，将栈顶指针与栈底指针都指向初始地址，给Dstacksize赋值STACK_INIT_SIZE   

    * 初始化成功返回1，否则返回0.*/

    if (InitDataStack(&OPND) == 0)
    {

        printf("InitDataStack Wrong\n");

        return 1;

    }



    /*符号栈初始化函数定义，要求：   

    * 函数接口定义为：int InitOpStack(OpStack *OS)   

    * 输入参数：符号栈OS   

    * 处理规则及返回值：从内存堆中申请STACK_INIT_SIZE个整型空间，将栈顶指针与栈底指针都指向初始地址，给Dstacksize赋值STACK_INIT_SIZE   

    * 初始化成功返回1，否则返回0.*/

    if (InitOpStack(&OPTR) == 0)
    {

        printf("InitOpStack Wrong\n");

        return 1;

    }



    /*符号栈栈底压入'＝'*/

    PushOpStack(&OPTR, '=');

    /*提示输入表达式，以等号结束*/

    printf("Please input the expression:\n");

    /*从标准输入获得表达式存入数组expression*/

    gets(expression);

    /*防护代码：当用户遗漏＝时提示*/

    if (expression[strlen(expression) - 1] != '=')
    {

        printf("Error: Please make sure the expression is ended with '='!");

        return 0;

    }


    while (i < strlen(expression) - 1 || GetOpTop(&OPTR) != '=')
    {

        //防护无效输入       

        if (checkch(expression[i]) == 0)
        {

            printf("Error: Invalid Input!");

            return 0;

        }

        //当表达式当前字符是数字时，逐位读入并组合       

        if (checkch(expression[i]) == 1)
        {

            while (checkch(expression[i]) == 1)
            {

                value = 10 * value + expression[i] - '0';

                i++;

            }

            /*如果表达式当前字符是小数，小数点后的数字处理后与小数点之前的数字相加*/

            if (checkch(expression[i]) == 2)
            {

                int r = 10;

                i++;

                while (checkch(expression[i]) == 1)
                {

                    value += (double) (expression[i] - '0') / r;

                    r = 10 * r;

                    i++;

                }

            }

            //数字压入数字栈OPND        

            PushDataStack(&OPND, value);

            value = 0.0;

        }



        /*如果表达式当前字符是运算符，则需要判断当前运算符与符号栈栈顶运算符的优先级*/

        if (checkch(expression[i]) == 3)
        {


            switch (Precede(GetOpTop(&OPTR), expression[i]))
            {

                /*如果符号栈栈顶运算符的优先级 < 表达式当前字符，则将表达式当前字符压入符号栈*/

                case '<':

                    PushOpStack(&OPTR, expression[i]);

                    i++;

                    break;

                    /*如果符号栈栈顶运算符的优先级 = 表达式当前字符，删去该栈顶符号*/

                case '=':

                    PopOpStack(&OPTR, &op);

                    i++;

                    break;

                    /*如果符号栈栈顶运算符的优先级 > 表达式当前字符，则计算栈顶运算符子式*/

                case '>':

                    PopOpStack(&OPTR, &op);

                    PopDataStack(&OPND, &b);

                    PopDataStack(&OPND, &a);

                    PushDataStack(&OPND, Operate(a, b, op));  /*运算结果入数据栈*/

                    break;

                default:

                    break;

            }

        }

    }

    /*打印表达式计算结果*/

    printf("The result is:%.2f\n", GetDataTop(&OPND));

    /*主动释放数据栈和符号栈的空间*/

    DestroyDataStack(&OPND);

    DestroyOpStack(&OPTR);

    return 0;

} 
```





#### 6. 实验4 栈实验2

```c
#include<stdio.h>
#include<stdlib.h>

#define OK 1
#define ERROR 0

typedef int SElemType;

typedef struct StackNode 
{
    SElemType data;
    struct StackNode *next;
} StackNode, *LinkStack;

void InitStack(LinkStack *S) 
{
    *S = (LinkStack)malloc(sizeof(StackNode));
    if(!(*S))	return;
    (*S)->next = NULL; 
    //下面是错误的内存开辟，sizeof(LinkStack)是一个指针变量的大小，存的就地址值，无法为StackNode开辟空间
    //S = (LinkStack*)malloc(sizeof(LinkStack));
    //if(!S)	return ;
    //(*S)->next = NULL; 
}

int StackEmpty(LinkStack S) 
{
    if (S->next == NULL) 
    {
        return 1;
    } 
    else 
    {
        return 0;
    }
}

void Push(LinkStack *S, SElemType e) 
{
    LinkStack p = *S;	
    LinkStack r;
    r = (LinkStack)malloc(sizeof(StackNode));
    if(!r)	return;
    r->data = e;
    r->next = p->next;
    p->next = r;
}

int Pop(LinkStack *S, SElemType *e) 
{
    if(StackEmpty(*S)) return ERROR;
    LinkStack p = *S;
    LinkStack q = p->next;
    *e = q->data;
    p->next = q->next;
    free(q);
    return OK;
}

void Conversion() 
{
    LinkStack S;
    InitStack(&S);
    printf("请输入非负十进制数\n");
    int N;
    N = 1348;
    while (N != 0) 
    {
        int mod = N % 8;
        Push(&S, mod);
        N = N / 8;
    }
    printf("八进制形式为: ");
    int e;
    while (StackEmpty(S) != 1) 
    {
        if(Pop(&S, &e) == OK)//判断是否pop成功
            printf("%d", e);
    }
    printf("\n");
}

int main() 
{
    Conversion();
    return 1;
}

```



#### 7. 栈-棒球比赛



```c
#include <stdio.h>  

#include <stdlib.h>  

#include <malloc.h>

 

#define ERROR 0

#define OK 1

#define TRUE 1

#define FALSE 0

 

typedef int SElemType;  

typedef int Status;

 

typedef struct L_node{

     SElemType     data;  //data field

     struct L_node  *next;   //pointer field

}LNode, *LinkList;

 

typedef struct{

   LinkList  Head;  //head pointer

   int  length;  //length

}LinkStack;

 

//========================================== 

// initialization of linked list based stack

//=========================================== 

Status InitStack(LinkStack *S)
{
	
	S->Head = (LinkList)malloc(sizeof(LNode));
	if(!(S->Head))	return ERROR; 
	S->Head->next = NULL;
	S->length = 0;
	return OK;
}

//========================================

//Test empty stack

//========================================

Status StackEmpty (LinkStack S)
{

	return (S.length == 0)?TRUE:FALSE;

}

 

//===============================================

// Get the length of a stack

//==============================================

int StackLength (LinkStack S)
{
 	               

}

 

//=====================================

// Get top item of a stack

//====================================

int GetTop(LinkStack S)
{
	if(S.length == 0) return ERROR;
	return S.Head->next->data;

}

 

//===================================================

// Delete an item from the stack

//====================================================

Status Pop(LinkStack *S, SElemType *e)
{
	if(S->length == 0)	return ERROR;
	LinkList p = S->Head->next;
	LinkList r = S->Head;
	*e = p->data;
	r->next = p->next;
	S->length --;
	free(p);
	return OK;
}

 

//======================================

// Insert an item into the stack

//=======================================

Status Push(LinkStack *S, SElemType e)
{
	LinkList p = S->Head;
	LinkList r;
	r = (LinkList)malloc(sizeof(LNode));
	if(!r) return ERROR;
	r->data = e;
	r->next = p->next;
	p->next = r;
	S->length ++;
	return OK;

}

 

//======================================

// Print the elements in a stack

//=======================================

void PrintStack (LinkStack S)
{

	LinkList p = S.Head->next;
	while(p)
	{
		printf("%d ",p->data);
		p = p->next;
	 } 
	 
}

//=========================

// 计算分值，s为字符串数组，nSize为数组的长度

//========================

int CalPoints(char *s,  int nSize)

{
	LinkStack Sstack;
	InitStack(&Sstack);
	int count = 0,i = 0,e;
	for(;i < nSize;i ++)
	{
		if(s[i] <= '9' && s[i] >= '0')	Push(&Sstack,s[i] - '0');
		else if(s[i] == '+')	
		{
			LinkList p = Sstack.Head->next;
			//while(p->next->next)	p = p->next;
			Push(&Sstack,p->data + p->next->data);
		}
		else if(s[i] == 'D')	Push(&Sstack,2 * GetTop(Sstack));
		else if(s[i] == 'C')	Pop(&Sstack,&e);
	}
	
	LinkList q = Sstack.Head->next;
	while(q)	
	{
		count +=q->data;
		q = q->next; 
	}
	return count;

} 



int main()  

{  
	int n,i = 0;
	char str[n + 1];
	scanf("%d",&n);
	for(;i < n;i ++)	
	{
		getchar(); 
		scanf("%c",&str[i]);
	}
	str[n] = '\0';
	printf("%s",str); 
	printf("%d",CalPoints(str,n));
	
	return OK;

 } 
```



#### 8. 栈-判断操作序列是否合法

```c
#include <stdio.h>  

#include <stdlib.h>  

#include <malloc.h>

 

#define ERROR 0

#define OK 1

#define TRUE 1

#define FALSE 0

typedef char SElemType;  

typedef int Status;

 

// definition of array based stack

#define STACK_INIT_SIZE   100          //Initial size for memory allocation

#define STACKINCREMENT  10          //incremental size

typedef struct{

   SElemType  *base;    //base pointer

   SElemType  *top;      //top pointer

   int        stacksize;     //current size

}SqStack;

 

//========================================== 

// initialization of array-based stack

//=========================================== 

Status InitStack(SqStack *S)
{

	S->base = (char*)malloc(STACK_INIT_SIZE*sizeof(char));
	if(!S->base)	return ERROR;
	S->top = S->base;
	S->stacksize =  STACK_INIT_SIZE;
	return OK;
}

 

//========================================

//Test empty stack

//========================================

Status StackEmpty (SqStack S)
{

	return (S.base == S.top)?TRUE:FALSE;

}

 

//===============================================

// Get the length of a stack

//==============================================

int StackLength (SqStack S)
{

	return S.top - S.base;                            

}

 

//=====================================

// Get top item of a stack

//====================================

Status GetTop(SqStack S, SElemType *e)
{
	if(StackEmpty(S))	return ERROR;
	*e = *(S.top - 1);
 	return OK;

}

 

//===================================================

// Delete an item from the stack

//====================================================

Status Pop(SqStack *S)
{

	if(StackEmpty(*S))	return ERROR;
	--S->top; 
	return OK;
}

 

//======================================

// Insert an item into the stack

//=======================================

Status Push(SqStack *S,SElemType e)
{

	if(S->stacksize == StackLength(*S)) 
	{
		S->base = (char*)realloc(S->base,(S->stacksize + STACKINCREMENT) *sizeof(char));
		if(!S->base)	return ERROR;
		S->top = S->base + S->stacksize;
		S->stacksize += STACKINCREMENT; 
	 } 
	 *S->top ++ = e;
	return OK;
}

 

//======================================

// Print the elements in a stack

//=======================================

void PrintStack (SqStack S)
{
	
	SElemType *p = S.base;
	while(p < S.top)
	{
		printf("%c",*p++);
	}
	printf("\n"); 
}

 

//======================================

// 检查操作序列是否合法, 如果合法，返回1，否则返回0

//=======================================

int isLegal(char *s)

{
	SqStack T; 
	InitStack(&T);
	
	int i = 0;
	for(;s[i] != '\0';i ++)
	{
		if(s[i] == 'I')	Push(&T,s[i]);
		else if(s[i] == 'O')	if(!Pop(&T)) return ERROR;
	}
	return StackEmpty(T);
}



int main( )  

{  
	char str[10010];
	scanf("%s",str);
	int tag = isLegal(str);
	if(tag)	printf("True");
	else printf("False");
	return OK;


 } 
```



#### 9. 栈-删除元素



> ```c
> #include <stdio.h>  
> #include <stdlib.h>  
> #include <malloc.h>
> 
> #define ERROR 0
> #define OK 1
> #define TRUE 1
> #define FALSE 0
> 
> typedef int SElemType;  
> typedef int Status;
> 
> typedef struct L_node {
>     SElemType data;  //data field
>     struct L_node *next;   //pointer field
> } LNode, *LinkList;
> 
> typedef struct {
>     LinkList Head;  //head pointer
>     int length;  //length
> } LinkStack;
> 
> //========================================== 
> // initialization of linked list based stack
> //=========================================== 
> Status InitStack(LinkStack *S)
> {
>    S->Head = (LinkList)malloc(sizeof(LNode));
>    if(!S->Head)	return ERROR;
>    S->Head->next = NULL;
>    S->length = 0;
>    return OK; 
> }
> 
> //========================================
> // Test empty stack
> //========================================
> Status StackEmpty(LinkStack S)
> {
> 	return (!S.length);
> }
> 
> //===============================================
> // Get the length of a stack
> //==============================================
> int StackLength(LinkStack S)
> {
> 	return S.length;
> }
> 
> //=====================================
> // Get top item of a stack
> //====================================
> Status GetTop(LinkStack S, SElemType *e)
> {
> 	if(StackEmpty(S))	return ERROR;
> 	*e = S.Head->next->data;
> }
> 
> //===================================================
> // Delete an item from the stack
> //====================================================
> Status Pop(LinkStack *S, SElemType *e)
> {
> 	if(StackEmpty(*S))	return ERROR;
> 	LinkList p = S->Head;
> 	LinkList r = p->next;
> 	p->next = r->next;
> 	*e = r->data;
> 	free(r);
> 	S->length --;
> 	return OK;
> }
> 
> //======================================
> // Insert an item into the stack
> //=======================================
> Status Push(LinkStack *S, SElemType e)
> {
> 	LinkList p = S->Head;
> 	LinkList r;
> 	r = (LinkList)malloc(sizeof(LNode));
> 	r->data = e;
> 	r->next = p->next;
> 	p->next = r;
> 	S->length ++;
> 	return OK;
> }
> 
> //======================================
> // Print the elements in a stack
> //=======================================
> void PrintStack(LinkStack S)
> {
> 	LinkList p = S.Head->next;
> 	while(p)
> 	{
> 		printf("%d ",p->data);
> 		p = p->next;
> 	 } 
> 	 printf("\n");
> }
> 
> //======================================
> // 删除堆栈中值为x的元素（可能有多个），返回堆栈的长度
> //=======================================
> int DeleteElem(LinkStack *S, SElemType x)
> {
> 	LinkList p = S->Head;
> 	while(p->next)
> 	{
> 		if(p->next->data != x)	p = p->next;
> 		else
> 		{
> 			LinkList r = p->next;
> 			p->next = r->next;
> 			free(r);
> 			 S->length --;
> 		  }  
> 	}
> 	return S->length;
> }
> 
> int main()  
> {  
> 	LinkStack S;
> 	InitStack(&S);
> 	int n,i = 0;
> 	scanf("%d",&n);
> 	int arr[n];
> 	for(;i < n;i ++)	
> 	{
> 		scanf("%d",&arr[i]);
> 		Push(&S,arr[i]);
> 	}
> 	int x;
> 	scanf("%d",&x);
> 	
> 	int tag = DeleteElem(&S,x);
> 	PrintStack(S);
> 	printf("%d",tag);
> }
> 
> ```
>



### 作业5——队列

#### 学习代码：

##### 循环队列式：

```c
//循环队列
#include <stdio.h>
#include <stdlib.h>

#define MAXQSIZE 100
#define OVERFLOW -1
#define ERROR 0
#define OK 1

typedef int QElemType;
typedef int Status;

// 循环队列
typedef struct {
    QElemType *base;
    int front;
    int rear;
} SqQueue;

Status InitQueue(SqQueue *Q) 
{
    Q->base = (QElemType*) malloc(MAXQSIZE * sizeof(QElemType));
    if (!Q->base) 
    {
        exit(OVERFLOW);
    }
    Q->front = Q->rear = 0;
    return OK;
}

int QueueLength(SqQueue Q) 
{
    return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;
}

Status EnQueue(SqQueue *Q, QElemType e) 
{
    if ((Q->rear + 1) % MAXQSIZE == Q->front) 
    {
        return ERROR; // 队列已满
    }
    Q->base[Q->rear] = e;
    Q->rear = (Q->rear + 1) % MAXQSIZE;
    return OK;
}

Status DeQueue(SqQueue *Q, QElemType *e) 
{
    if (Q->front == Q->rear) 
    {
        return ERROR; // 队列为空
    }
    *e = Q->base[Q->front]; // 保存值
    Q->front = (Q->front + 1) % MAXQSIZE;
    return OK;
}

QElemType GetHead(SqQueue Q) 
{
    if (Q.front != Q.rear) 
    { // 队列不为空
        return Q.base[Q.front]; // 返回值
    }
    // 处理空队列
    return -1; // 或其他适当值
}

void DestroyQueue(SqQueue *Q) 
{
    free(Q->base);
    Q->base = NULL;
    Q->front = Q->rear = 0;
}

int main() 
{
    SqQueue Q;
    InitQueue(&Q);
    EnQueue(&Q, 1);
    EnQueue(&Q, 2);
    EnQueue(&Q, 3);

    printf("队列长度: %d\n", QueueLength(Q));

    QElemType head;
    if (DeQueue(&Q, &head)) 
    {
        printf("出队元素: %d\n", head);
    }

    printf("出队后队列长度: %d\n", QueueLength(Q));

    printf("队列头部元素: %d\n", GetHead(Q));

    DestroyQueue(&Q);

    return 0;
}

```

##### 链队列式：

```c
//链队列
#include <stdio.h>
#include <stdlib.h>

#define MAXQSIZE 100
#define OVERFLOW -1
#define ERROR 0
#define OK 1

typedef int QElemType;
typedef int Status;

// 循环队列
typedef struct {
    QElemType *base;
    int front;
    int rear;
} SqQueue;

Status InitQueue(SqQueue *Q) 
{
    Q->base = (QElemType*) malloc(MAXQSIZE * sizeof(QElemType));
    if (!Q->base) 
    {
        exit(OVERFLOW);
    }
    Q->front = Q->rear = 0;
    return OK;
}

int QueueLength(SqQueue Q) 
{
    return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;
}

Status EnQueue(SqQueue *Q, QElemType e) 
{
    if ((Q->rear + 1) % MAXQSIZE == Q->front) 
    {
        return ERROR; // 队列已满
    }
    Q->base[Q->rear] = e;
    Q->rear = (Q->rear + 1) % MAXQSIZE;
    return OK;
}

Status DeQueue(SqQueue *Q, QElemType *e) 
{
    if (Q->front == Q->rear) 
    {
        return ERROR; // 队列为空
    }
    *e = Q->base[Q->front]; // 保存值
    Q->front = (Q->front + 1) % MAXQSIZE;
    return OK;
}

QElemType GetHead(SqQueue Q) 
{
    if (Q.front != Q.rear) 
    { // 队列不为空
        return Q.base[Q.front]; // 返回值
    }
    // 处理空队列
    return -1; // 或其他适当值
}

void DestroyQueue(SqQueue *Q) 
{
    free(Q->base);
    Q->base = NULL;
    Q->front = Q->rear = 0;
}

int main() 
{
    SqQueue Q;
    InitQueue(&Q);
    EnQueue(&Q, 1);
    EnQueue(&Q, 2);
    EnQueue(&Q, 3);

    printf("队列长度: %d\n", QueueLength(Q));

    QElemType head;
    if (DeQueue(&Q, &head)) 
    {
        printf("出队元素: %d\n", head);
    }

    printf("出队后队列长度: %d\n", QueueLength(Q));

    printf("队列头部元素: %d\n", GetHead(Q));

    DestroyQueue(&Q);

    return 0;
}

```



#### 课外拓展题：

##### 判断字符串回文：

```c
#include <stdio.h>
#include <stdlib.h>

/* run this program using the console pauser or add your own getch, system("pause") or input loop */


#define MAXSIZE 100
#define OVERFLOW -1
#define ERROR 0
#define OK 1

typedef struct
{
    char *base;
    char *top;
    int stackSize;
}SqStack;

typedef struct
{
    char *base;
    int front;
    int rear;
}SqQueue;

void InitStack(SqStack *S)
{
    S->base = (char*)malloc(sizeof (char)*MAXSIZE);
    if(!S->base)
    {
        return;
    }
    S->top = S->base;
    S->stackSize = MAXSIZE;
    return ;
}
void Push(SqStack *S,char e)
{
    if(S->top - S->base == S->stackSize)
    {
        return ;
    }
    *S->top ++= e;
}

void Pop(SqStack *S,char*e)
{
    if(S->top - S->base == 0)
    {
        return;
    }
    *e = *--S->top;
}


void InitQueue(SqQueue *Q)
{
    Q->base = (char *) malloc(MAXSIZE*sizeof (char));
    if(!Q->base)
    {
        return ;
    }
    Q->front = Q->rear = 0;
}

void EnQueue(SqQueue *Q,char e)
{
    if((Q->rear + 1)%MAXSIZE == Q->front)
    {
        printf("队列已满\n");
        return ;
    }
    Q->base[Q->rear] = e;
    Q->rear = (Q->rear + 1 )% MAXSIZE;
}
void DeQueue(SqQueue *Q,char *e)
{
    if(Q->front == Q->rear)
    {
        printf("队列为空\n");
        return ;
    }
    *e = Q->base[Q->front];
    Q->front = (Q->front + 1)%MAXSIZE;
}


int main(int argc, char *argv[])
{
    SqStack S;
    SqQueue Q;
    InitStack(&S);
    InitQueue(&Q);
    char s,c,q;
    while((c = getchar())!= '@')
    {
        Push(&S,c);
        EnQueue(&Q,c);
    }
    while(0 != S.top - S.base)
    {
        Pop(&S,&s);
        DeQueue(&Q,&q);
        if(s != q)
        {
            printf("不是回文字符串\n");
            return 0;
        }
    }
    printf("是回文字符串\n");
    return 0;
}
```

##### 医院排队：

```c
#include <stdio.h>
#include <malloc.h>
#include <string.h>

typedef int QElemType ;
typedef int Status;

#define ERROR 0
#define OK 1
#define MAXSIZE 100

typedef struct
{
    QElemType *base;
    int front;
    int rear;
}SqQueue;

void InitQueue(SqQueue *Q)
{
    Q->base = (int*) malloc(sizeof (int)*MAXSIZE);
    if(!Q->base)
    {
        return ;
    }
    Q->front = 0 ;
	Q->rear = 0;
}

int QueueLength(SqQueue Q)
{
    return ((Q.rear - Q.front + MAXSIZE) % MAXSIZE);
}

void EnQueue(SqQueue *Q,QElemType e)
{
    if((Q->rear + 1) %MAXSIZE == Q->front)
    {
        return ;
    }
    Q->base[Q->rear] = e;
    Q->rear = (Q->rear + 1)%MAXSIZE;
}

void DeQueue(SqQueue *Q,QElemType *e)
{
    if(Q->front == Q->rear)
    {
        return;
    }
    *e = Q->base[Q->front];
    Q->front = (Q->front - 1)%MAXSIZE;
}


void SeeDoctor()
{
    SqQueue Q;
    int n;
    InitQueue(&Q);
    int flag = 1;
    while(flag)
    {
    	char ch;
        printf("请输入命令\n");
        scanf("%c",&ch);
        getchar();
        switch(ch)
        {
            case 'a' :
	            {
	                printf("病例号：\n");
	                scanf("%d",&n);
	                getchar();
	                EnQueue(&Q,n);
	                break;
	            }
            case 'n':
            {
                if(QueueLength(Q) != 0)
                {
                    DeQueue(&Q,&n);
                    printf("病历号为%d的病人就诊\n",n);
                }
                else
                {
                    printf("无病人等待就诊\n");
                }
                break;
            }
            case 'q':
            {
                printf("今天停止挂号，下列病人依次就诊\n");
                while(QueueLength(Q) == 0)
                {
                    DeQueue(&Q,&n);
                    printf("%d",n);
                }
                flag = 0;
                break;
            }
            default:
                break;
        }
    }
}

int main()
{
    SeeDoctor();
    return 0;
}
```



#### 1. 基于顺序表的队列基本操作

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1

typedef int QElemType;
typedef int Status;

#define MAXQSIZE 100

typedef struct {
    QElemType *base;
    int front;
    int rear;
} SqQueue;

Status InitQueue(SqQueue *Q) 
{
    Q->base = (QElemType*)malloc(MAXQSIZE * sizeof(QElemType));
    if (!Q->base) 
    {
        exit(ERROR);
    }
    Q->front = Q->rear = 0;
    return OK;
}

Status QueueEmpty(SqQueue Q) 
{
    return Q.front == Q.rear ? OK : ERROR;
}

int QueueLength(SqQueue Q) 
{
    return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;
}

Status GetHead(SqQueue Q, QElemType *e) 
{
    if (QueueEmpty(Q)) 
    {
        return ERROR;
    }
    *e = Q.base[Q.front];
    return OK;
}

Status DeQueue(SqQueue *Q, QElemType *e) 
{
    if (QueueEmpty(*Q)) 
    {
        return ERROR;
    }
    *e = Q->base[Q->front];
    Q->front = (Q->front + 1) % MAXQSIZE;
    return OK;
}

Status EnQueue(SqQueue *Q, QElemType e) 
{
    if ((Q->rear + 1) % MAXQSIZE == Q->front) 
    {
        return ERROR;
    }
    Q->base[Q->rear] = e;
    Q->rear = (Q->rear + 1) % MAXQSIZE;
    return OK;
}

void PrintQueue(SqQueue Q) 
{
    int i = Q.front;
    while (i != Q.rear) 
    {
        printf("%d ", Q.base[i]);
        i = (i + 1) % MAXQSIZE;
    }
    printf("\n");
}

int main() 
{
    SqQueue Q;
    InitQueue(&Q);
    int e;
    while (1) 
    {
        scanf("%d", &e);
        if (e == -1) 
        {
            break;
        }
        EnQueue(&Q, e);
    }
    PrintQueue(Q);
    printf("%d\n", QueueLength(Q));
    int n = QueueLength(Q);
    for (int i = 0; i < n; ++i) 
    {
        if (DeQueue(&Q, &e)) 
        {
            printf("%d ", e);
        }
    }
    printf("\n");
    return OK;
}

```



#### 2. 基于链表的队列合并



```c
//自己写的代码及老师给的代码模板
#include <stdio.h>  
#include <stdlib.h>  
#include <malloc.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef struct 
{
    char name;    
    int arriveTime;  
} QElemType;

typedef int Status;

typedef struct Qnode 
{
    QElemType   data;
    struct Qnode* next;
} QNode, * QueuePtr;

typedef struct
{
    QueuePtr  front;  //front pointer
    QueuePtr  rear;   //rear pointer
} LinkQueue;

Status InitQueue(LinkQueue* Q)
{
    Q->front = (QNode*)malloc(sizeof(QNode));
    if (Q->front == NULL)
        return ERROR;
    Q->rear = Q->front;
    Q->rear->next = NULL;
    return OK;
}

Status QueueEmpty(LinkQueue Q)
{
    if (Q.front == Q.rear)
        return OK;
    else
        return ERROR;
}

int QueueLength(LinkQueue Q) 
{
    QNode* p;
    p = Q.front->next;
    int length = 0;
    for (; p->next != NULL; p = p->next)
        length++;
    return length;
}

Status GetHead(LinkQueue Q, QElemType* e) 
{
    if (Q.front == Q.rear)
        return ERROR;
    *e = Q.front->next->data;
    return OK;
}

Status DeQueue(LinkQueue *Q, QElemType* e) 
{
    QNode* p;
    if (Q->front == Q->rear)
        return ERROR;
    p = Q->front->next;
    *e = Q->front->next->data;
    Q->front->next = Q->front->next->next;
    if (p == Q->rear)
        Q->rear = Q->front;
    return OK;
}

Status EnQueue(LinkQueue* Q, QElemType e) 
{
    QNode* p;
    p = (QNode*)malloc(sizeof(QNode));
    if (p == NULL)
        return ERROR;
    p->data = e;
    p->next = NULL;
    Q->rear->next = p;
    Q->rear = Q->rear->next;
    return OK;
}

void PrintQueue(LinkQueue Q) 
{
    QNode* p;
    p = Q.front->next;
    while (p != NULL) 
    {
        printf("(%c,%d)\n", p->data.name, p->data.arriveTime);
        p = p->next;
    }
}

void mergeQueue(LinkQueue *Q1, LinkQueue* Q2, LinkQueue* Q3) 
{
    QElemType e1,e2,e3;
    while(!QueueEmpty(*Q1) && !QueueEmpty(*Q2))
    {
        GetHead(*Q1,&e1);
        GetHead(*Q2,&e2);
        if(e1.arriveTime > e2.arriveTime)  
        {
            EnQueue(Q3,e2);
            DeQueue(Q2,&e2);
        }
        else 
        {
             EnQueue(Q3,e1);
             DeQueue(Q1,&e1);
        }
    }
    while(!QueueEmpty(*Q1))
    {
        GetHead(*Q1,&e1);
        EnQueue(Q3,e1);
        DeQueue(Q1,&e1);
    }
    while(!QueueEmpty(*Q2))
    {
        GetHead(*Q2,&e2);
        EnQueue(Q3,e2);
        DeQueue(Q2,&e2);
    }
}

int main()
{
    LinkQueue Q1, Q2, Q3;
    char c;
    int length1, length2;
    QElemType QData;
    InitQueue(&Q1);
    InitQueue(&Q2);
    InitQueue(&Q3);
    scanf("%d", &length1);
    c=getchar();
    int i = 0;
    for (; i <= length1 - 1; i++) 
    {
        scanf("%c%d", &QData.name, &QData.arriveTime);
        EnQueue(&Q1, QData);
        c = getchar();
    }
    scanf("%d", &length2);
    c = getchar();
    for (i = 0; i <= length2 - 1; i++)
    {
        scanf("%c%d", &QData.name, &QData.arriveTime);
        EnQueue(&Q2, QData);
        c = getchar();
    }
    mergeQueue(&Q1, &Q2, &Q3);
    printf("%d\n", length1 + length2);
    PrintQueue(Q3);
}

```



```c
//AI优化后的代码
#include <stdio.h>  
#include <stdlib.h>  

#define ERROR 0
#define OK 1

typedef struct {
    char name;    
    int arriveTime;  
} QElemType;

typedef int Status;

typedef struct Qnode {
    QElemType   data;
    struct Qnode* next;
} QNode, * QueuePtr;

typedef struct {
    QueuePtr  front;  //front pointer
    QueuePtr  rear;   //rear pointer
    int length;       // Length of the queue
} LinkQueue;

// initialization of linked list based queue
Status InitQueue(LinkQueue* Q) 
{
    Q->front = (QNode*)malloc(sizeof(QNode));
    if (Q->front == NULL)
        return ERROR;
    Q->rear = Q->front;
    Q->rear->next = NULL;
    Q->length = 0; // Initialize length to 0
    return OK;
}

// Test empty queue
Status QueueEmpty(LinkQueue Q) 
{
    if (Q.front == Q.rear)
        return OK;
    else
        return ERROR;
}

// Get the length of a queue
int QueueLength(LinkQueue Q) 
{
    return Q.length; // Return length directly
}

// Get front item of a queue
Status GetHead(LinkQueue Q, QElemType* e) 
{
    if (Q.front == Q.rear)
        return ERROR;
    *e = Q.front->next->data;
    return OK;
}

// Delete an item from the queue
Status DeQueue(LinkQueue *Q, QElemType* e) 
{
    QNode* p;
    if (Q->front == Q->rear)
        return ERROR;
    p = Q->front->next;
    *e = Q->front->next->data;
    Q->front->next = Q->front->next->next;
     /*下一行是检查被出队的节点 (p) 是否是队列中唯一的节点。
	如果 p 是队列中唯一的节点，意味着在出队这个节点后，队列将变为空。在这种情况下，队列的前后指针都应该指向同一个节点（即头节点）。这是因为在空队列中，前后指针都应该指向同一个节点以表示队列为空。*/
    if (p == Q->rear)
        Q->rear = Q->front;
    Q->length--; // Update length
    free(p); // Free memory
    return OK;
}

// Insert an item into the queue
Status EnQueue(LinkQueue* Q, QElemType e) 
{
    QNode* p;
    p = (QNode*)malloc(sizeof(QNode));
    if (p == NULL)
        return ERROR;
    p->data = e;
    p->next = NULL;
    Q->rear->next = p;
    Q->rear = Q->rear->next;
    Q->length++; // Update length
    return OK;
}

// Print the elements in a queue
void PrintQueue(LinkQueue Q) 
{
    QNode* p;
    p = Q.front->next;
    while (p != NULL) {
        printf("(%c,%d)\n", p->data.name, p->data.arriveTime);
        p = p->next;
    }
}

// Merge two queues
void mergeQueue(LinkQueue *Q1, LinkQueue* Q2, LinkQueue* Q3) 
{
    QElemType e1, e2;
    while (!QueueEmpty(*Q1) && !QueueEmpty(*Q2)) 
    {
        GetHead(*Q1, &e1);
        GetHead(*Q2, &e2);
        if (e1.arriveTime > e2.arriveTime) 
        {
            EnQueue(Q3, e2);
            DeQueue(Q2, &e2);
        } 
        else 
        {
            EnQueue(Q3, e1);
            DeQueue(Q1, &e1);
        }
    }
    while (!QueueEmpty(*Q1)) 
    {
        GetHead(*Q1, &e1);
        EnQueue(Q3, e1);
        DeQueue(Q1, &e1);
    }
    while (!QueueEmpty(*Q2)) 
    {
        GetHead(*Q2, &e2);
        EnQueue(Q3, e2);
        DeQueue(Q2, &e2);
    }
}

int main() 
{
    LinkQueue Q1, Q2, Q3;
    char c;
    int length1, length2;
    QElemType QData;
    
    // Initialize queues
    InitQueue(&Q1);
    InitQueue(&Q2);
    InitQueue(&Q3);

    // Input for queue 1
    scanf("%d", &length1);
    c = getchar(); // consume newline character
    for (int i = 0; i < length1; i++) 
    {
        scanf("%c%d", &QData.name, &QData.arriveTime);
        EnQueue(&Q1, QData);
        c = getchar(); // consume newline character
    }

    // Input for queue 2
    scanf("%d", &length2);
    c = getchar(); // consume newline character
    for (int i = 0; i < length2; i++) 
    {
        scanf("%c%d", &QData.name, &QData.arriveTime);
        EnQueue(&Q2, QData);
        c = getchar(); // consume newline character
    }

    // Merge queues
    mergeQueue(&Q1, &Q2, &Q3);

    // Output total length and merged queue
    printf("%d\n", length1 + length2);
    PrintQueue(Q3);

    return 0;
}
```



#### 3. 队列9-约瑟夫环问题

```c
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 36 //存储空间的初始分配量 

typedef struct {
    int data[MAXSIZE];
    int front;
    int rear;
} SqQueue; 

void InitQueue(SqQueue *Q) 
{
    Q->front = Q->rear = 0;
}

int QueueLength(SqQueue Q) 
{
    return ((Q.rear - Q.front + MAXSIZE) % MAXSIZE);
}

void EnQueue(SqQueue *Q, int e) 
{
    if ((Q->rear + 1) % MAXSIZE == Q->front) return; // 队列已满
    Q->data[Q->rear] = e;
    Q->rear = (Q->rear + 1) % MAXSIZE;
}

void DeQueue(SqQueue *Q, int *e) 
{
    if (Q->front == Q->rear) return; // 队列为空
    *e = Q->data[Q->front];
    Q->front = (Q->front + 1) % MAXSIZE;
}

void joseph_ring(int n, int m, int k) 
{
    SqQueue Q;
    InitQueue(&Q);
    int i, e;
    for (i = 0; i < n; i++) 
    {
        EnQueue(&Q, i + 1);
    }
    for (i = 0; i < k - 1; i++) 
    {
        int e;
        DeQueue(&Q, &e);
        EnQueue(&Q, e);
    }
    while (QueueLength(Q)) 
    {
        for (i = 0; i < m - 1; i++) 
        {
            DeQueue(&Q, &e);
            EnQueue(&Q, e);
        }
        DeQueue(&Q, &e);
        printf("%d ", e);
    }
    printf("\n");
}

int main(int argc, char *argv[]) 
{
    int m, n, k;
    scanf("%d%d%d", &n, &m, &k);
    joseph_ring(n, m, k);
    return 0;
}

```



#### 4. 队列7-杨辉三角

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

typedef struct {
    int data[MAX_SIZE];
    int front;
    int rear;
} Queue;

void initQueue(Queue *q) {
    q->front = q->rear = 0;
}

int isEmpty(Queue *q) {
    return q->front == q->rear;
}
int QueueLength(Queue Q)
{
    return (Q.rear - Q.front+ MAX_SIZE )%MAX_SIZE;
}

void enqueue(Queue *q, int value) {
    if(QueueLength(*q) == MAX_SIZE - 1)	return ;
    q->data[q->rear] = value;
    q->rear = (q->rear + 1) % MAX_SIZE;
}

int dequeue(Queue *q) {
    if(isEmpty(q))	return 0;
    int value = q->data[q->front];
    q->front = (q->front + 1) % MAX_SIZE;
    return value;
}

void printYanghuiTriangle(int n) {
    Queue q;
    initQueue(&q);
    
    enqueue(&q, 1);  // 第一行的1
    
    for (int i = 0; i < n; i++) {
        int previous = 0;
        for (int j = 0; j <= i; j++) {
            int current = dequeue(&q);
            printf("%4d", current);
            
            // 计算下一行的数字并入队
            enqueue(&q, current + previous);
            previous = current;
        }
        enqueue(&q, 1);  // 每行最后一个数字是1
        printf("\n");
    }
}

int main() {
    int n;
    //printf("请输入一个数字(2到9之间): ");做题时要加入判断
    scanf("%d", &n);

    printYanghuiTriangle(n);

    return 0;
}

```



#### 5. 数据结构和ACM2023-第四章-循环队列判断回文- LJD

```c
#include "stdio.h"
#include "stdlib.h"
#include "string.h"

#define OK 1
#define ERROR 0
#define TURE 1
#define FALSE 0
#define MAXSIZE 36 //存储空间的初始分配量

typedef int Status;
typedef char QElemType;

typedef struct {
    QElemType data[MAXSIZE];
    int front;
    int rear;
} SqQueue;

int QueueLength(SqQueue Q) 
{
    return ((Q.rear - Q.front + MAXSIZE) % MAXSIZE); 
}

Status EnQueue(SqQueue *Q, QElemType d) 
{
    if (QueueLength(*Q) == MAXSIZE) 
    {
        return ERROR;
    }
    Q->data[Q->rear] = d;
    Q->rear = (Q->rear + 1) % MAXSIZE;
    return OK;
}

Status DeQueue(SqQueue *Q, QElemType *d) 
{
    if (!QueueLength(*Q)) 
    {
        return ERROR;
    }
    *d = Q->data[Q->front];
    Q->front = (Q->front + 1) % MAXSIZE;
    return OK;
}

int main() 
{
    int i, j, d = 1;
    char a[20];
    SqQueue Q;
    Q.front = 0;
    Q.rear = 0;

    for (i = 0;; i++) 
    {
        scanf("%c", &a[i]);
        if (a[i] == '@')
            break;
        else
            EnQueue(&Q, a[i]);
    }

    j = QueueLength(Q);

    for (i = 0; i < (j + 1) / 2; i++) 
    {
        if (Q.data[Q.front + i] == Q.data[Q.rear - i - 1])
            d = 1;
        else 
        {
            d = 0;
            break;
        }
    }

    if (d == 0)  
    {
        printf("此字符串不是回文\n");
    }
    else if (d == 1) 
    {
        printf("此字符串为回文\n");
    }

    return 0;
}
```



#### 6. 队列实验

```c
#include <stdio.h>
#include "stdlib.h"
#include <malloc.h>
#include <string.h>

#define OK 1
#define ERROR 0
#define OVERFLOW -1
#define TRUE 1
#define FALSE -2

/*定义队列节点结构体类型、和队列节点结构体指针类型*/ 
typedef struct QUEUE_NODE 
{ 
	int data;
	struct QUEUE_NODE *next; 
//    补充完整
} QUEUE_NODE, *QUEUE_NODE_PTR; 

/*队列结构体类型、和队列结构体指针类型定义，包括：
  队列真实长度；
  队头位置指针；
  队尾位置指针*/ 
typedef struct 
{ 
    int Len; 
    QUEUE_NODE_PTR front;
    QUEUE_NODE_PTR rear;
//    补充完整
} LINK_QUEUE, *LINK_QUEUE_PTR; 

/*队列初始化函数，要求生成头结点，并将队列头指针、尾指针和长度正确赋值*/ 
int InitQueue(LINK_QUEUE *q) 
{  
	q->front = (QUEUE_NODE_PTR)malloc(sizeof(QUEUE_NODE));
	if(!q->front) return ERROR;
	q->rear = q->front;
	q->rear->next = NULL;
	return OK;
//    补充完整
    return 1; /*初始化成功返回1*/ 
} 

/*.队列判空函数，要求：
函数接口定义为：int IsQueueEmpty(LINK_QUEUE *q)；
2.输入参数：待判空队列q；
3 处理规则及返回值：通过队列长度元素判空。
                     队列为空返回1；队列非空返回0.*/
int IsQueueEmpty(LINK_QUEUE *q) 
{ 
	return ((q->Len == 0)?1:0); 
//    补充完整
}

/*.入队列函数，要求：
1.函数接口定义为：int EnQueue(LINK_QUEUE *q, int MRN)；
2.输入参数：待操作队列名q，待入队列数值（病例号）MRN；
3 处理规则及返回值：从内存堆中申请一个队列结点大小的存储空间作为新的队列结点newNode，给节点数据域赋值MRN，指针域为空。
    将队列队尾结点的指针域指向新节点newNode，队尾指针指向新节点newNode。
    入队列成功时返回1，入队列失败时返回0.*/
int EnQueue(LINK_QUEUE *q, int MRN) 
{ 
	QUEUE_NODE_PTR p ;
	p = (QUEUE_NODE_PTR)malloc(sizeof(QUEUE_NODE));
	if(!p)	return ERROR;
	p->data = MRN;
	p->next = q->rear->next;
	q->rear->next = p;
	q->rear = q->rear->next;
	q->Len ++;
	return OK;
//    补充完整
} 
 

/*.出队列函数，要求：
.函数接口定义为：int DeQueue(LINK_QUEUE *q)；
2.输入参数：待操作队列q；
3 处理规则及返回值：取队头节点，将其数据域数值作为返回值输出。
                     删除队头结点，并将头节点的next指针指向新的队头节点；
                     当出队列失败时返回0；成功时返回原队头结点的数据域数值。*/
int DeQueue(LINK_QUEUE *q) 
{  
	if(IsQueueEmpty(q))	return ERROR;
    int mn;
    QUEUE_NODE_PTR p = q->front->next;
    mn = p->data;
    q->front->next = q->front->next->next;
	if(p == q->rear ) q->rear = q->front;
	q->Len --;
	free(p);	 
//    补充完整
    return mn;//返回原队头结点的病历号 
} 

/*.销毁队列函数，要求：
函数接口定义为：int DestroyQueue(LINK_QUEUE *q)
2.输入参数：待销毁队列q；
3 处理规则及返回值：在队尾指针的辅助下，从头至尾逐一释放队列结点空间。
                     销毁成功返回1；否则，返回0.*/
int DestroyQueue(LINK_QUEUE *q) 
{ 
    /*一般防护：如果队列不存在，返回错误*/ 
    if(q->front == NULL) 
    { 
        return 0; 
    } 
    /*在队尾指针的辅助下，从头至尾逐一释放队列结点空间*/
    while(q->Len)
    {
    	DeQueue(q);
	}
    q->front = q->rear = NULL; 
//    补充完整
    return 1; 
} 

/*.队列遍历函数，要求：
.函数接口定义为：int QTraverse(LINK_QUEUE *q)
2.输入参数：进行遍历的队列q；
3 处理规则及返回值：从首至尾遍历队列，依次打印输出所有队列结点数据域数值。数值之间间隔一个制表符位置；
                     遍历成功返回1；队列不存在或为空返回0*/
int QTraverse(LINK_QUEUE *q) 
{ 
    QUEUE_NODE_PTR p; 
    /*队列不存在或为空返回0*/ 
    if(q->front == NULL || q->Len == 0) 
    { 
        return 0; 
    } 
    /*从队列第一个元素开始遍历队列，依次打印输出所有队列结点数据域数值，每次循环结束p后移一个节点*/ 
    for(p=q->front->next; p!=NULL; p= p->next) 
    { 
        printf("%d\t", p->data); 
    } 
    return 1; 
} 

/**************************************************************************/ 
/*                                                                        */ 
/**************************************************************************/ 

int main() 
{ 
    LINK_QUEUE QPatient ={0};//定义病人队列 
    int flag = 1; /*上下班标志位： 1为上班，0为下班*/ 
    int Medical_Record_NO = 0; 
    char ch = 0; 
    char a[100];
    int length;
    int index;
    //初始化病人对列 
    InitQueue(&QPatient); 
    //输入处理命令 
    gets(a); 
    length = strlen(a); 
    index = 0; 
    /*上班时，依次处理各个输入命令*/ 
    while( (flag==1) && (index<length) ) 
    { 
        ch = a[index] &0xff; /*从控制台接收命令*/ 
        index++; 
        switch (ch) 
        { 
            case 'a': 
                /*新增病人排至队尾*/ 
                Medical_Record_NO=Medical_Record_NO+1;  /*记录病人数量*/
                EnQueue(&QPatient, Medical_Record_NO); 
                printf("\nYour patient's No. is:%d.\t", Medical_Record_NO); 
                printf("There are %d patient(s) waiting ahead of you.", QPatient.Len); 
                break; 
            case 'n': 
                /*队头病人出队看病*/ 
                if(!IsQueueEmpty(&QPatient)) 
                { 
                    Medical_Record_NO = DeQueue(&QPatient); 
                    printf("\nPatient No. %d, please go to the clinic", Medical_Record_NO); 
                } 
                else 
                { 
                    printf("\n No patient is waiting in line.\n"); 
                } 
                break; 
            case 'q': 
                /*下班：如果队列中还有病人则依次出队，否则打印hello*/ 
                if(!IsQueueEmpty(&QPatient)) 
                { 
                    printf("\nIt is the end of today. Following patients please go to the clinic in turn: "); 
                    QTraverse(&QPatient); 
                    printf("\n"); 
                } 
                else 
                {                    
                    printf("hello\n"); 
                } 
                flag = 0;//置下班标志 
                //销毁队列 
                DestroyQueue(&QPatient); 
                break; 
            default: 
                printf("ERROR\n"); 
                break; 
        }// end of switch(ch) 
    }//end of while() 
    return 0; 
} 

```



### 作业6——串

#### 学习代码：

##### 定长顺序存储：

```c
#include <stdio.h>
#include <string.h>

#define MAXSTRLEN 255
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

typedef int Status;
typedef unsigned char SString[MAXSTRLEN + 1];

// Function to clear the string
Status ClearString(SString S) {
    S[0] = '\0';
    return OK;
}

// Function to get the length of the string
int StrLength(SString S) {
    return S[0];
}

// Function to check if the string is empty
Status StrEmpty(SString S) {
    return (S[0] == 0) ? TRUE : FALSE;
}

// Function to assign a character array to the string
Status StrAssign(SString T, char *chars) {
    int len = strlen(chars);
    
    //在不能使用 strlen函数的情况下，求chars的长度i
    //for(int i = 0,c = chars;*c != '\0';++i, ++c)    
    
    if (len > MAXSTRLEN) return ERROR;
    T[0] = len;
    for (int i = 1; i <= len; i++) {
        T[i] = *(chars + i - 1);
    }
    return OK;
}

// Function to copy one string to another
Status StrCopy(SString T, SString S) {
    for (int i = 0; i <= S[0]; i++) {
        T[i] = S[i];
    }
    return OK;
}

// Function to compare two strings
int StrCompare(SString S, SString T) {
    for (int i = 1; i <= S[0] && i <= T[0]; ++i) {
        if (S[i] != T[i]) return S[i] - T[i];
    }
    return S[0] - T[0];
}

// Function to concatenate two strings
Status Concat(SString T, SString S1, SString S2) {
    if (S1[0] + S2[0] <= MAXSTRLEN) {//未截断
        StrCopy(T, S1);
        for (int i = 1; i <= S2[0]; i++) {
            T[S1[0] + i] = S2[i];
        }
        T[0] = S1[0] + S2[0];
        return OK;
    } 
    else {
        return ERROR;
    }
}

Status Concat(SString T, SString S1, SString S2) 
{
    StrCopy(T, S1);
    memmove(T + S1[0] + 1, S2 + 1, MAXSTRLEN - S1[0]);
    if (S1[0] + S2[0] <= MAXSTRLEN) 
    {
        T[0] = S1[0] + S2[0];
        return OK;
    } 
    else 
    {
        T[0] = MAXSTRLEN;
        T[MAXSTRLEN] = '\0';
        return ERROR;
    }
}


// Function to concatenate two strings
Status Concat(SString T, SString S1, SString S2) {
    if (S1[0] + S2[0] <= MAXSTRLEN) 
    { // 未截断
        StrCopy(T, S1);
        for (int i = 1; i <= S2[0]; i++) 
        {
            T[S1[0] + i] = S2[i];
        }
        T[0] = S1[0] + S2[0];
        return OK;
    } 
    else 
    {
            StrCopy(T, S1);
            for (int i = 1; i <= MAXSTRLEN - S1[0]; i++) 
            {
                T[S1[0] + i] = S2[i];
            }
            T[0] = MAXSTRLEN; // 设置T的长度为最大长度
         	T[MAXSTRLEN] = '\0'; // 添加字符串结束符
            return ERROR;
    }
}



// Function to extract a substring from a string
Status SubString(SString Sub, SString S, int pos, int len) {
    if (pos < 1 || pos > S[0] || len < 0 || pos + len - 1 > S[0]) return ERROR;
    for (int i = 1; i <= len; i++) {
        Sub[i] = S[pos + i - 1];
    }
    Sub[0] = len;
    return OK;
}

// Function to insert a string into another string at a specified position
Status StrInsert(SString S, int pos, SString T) {
    if (pos < 1 || pos > S[0] + 1) return ERROR;
    if (S[0] + T[0] <= MAXSTRLEN) {//完全插入
        for (int i = S[0]; i >= pos; i--) {
            S[i + T[0]] = S[i];
        }
        for (int i = pos; i < pos + T[0]; i++) {
            S[i] = T[i - pos + 1];
        }
        S[0] = S[0] + T[0];
        return OK;
    } 
    else 
    {//部分插入
        //这段貌似也没什么用，后续还是被T给替换掉了
        // 	        for (int i = MAXSTRLEN; i >= pos + T[0]; i--) {
		//            S[i] = S[i - T[0]];
		//        }

        for (int i = pos; i < pos + T[0]; i++) {
            S[i] = T[i - pos + 1];
        }
        S[0] = MAXSTRLEN;
        return ERROR;
    }
}

// Function to delete a substring from a string
Status StrDelete(SString S, int pos, int len) {
    if (pos < 1 || pos + len - 1 > S[0] || len < 0) return ERROR;
    for (int i = pos + len; i <= S[0]; i++) {
        S[i - len] = S[i];
    }
    S[0] -= len;
    return OK;
}

// Function to find the first occurrence of a substring in a string
int Index(SString S, SString T, int pos) {
    int n, m;
    if (pos < 0) return ERROR;
    n = StrLength(S);
    m = StrLength(T);
    int i = pos;
    while (i <= n - m + 1) {
        SString sub;
        SubString(sub, S, i, m);
        if (StrCompare(sub, T) != 0) {
            ++i;
        } else {
            return i;
        }
    }
    return 0;
}

// Function to replace all occurrences of a substring in a string with another substring
Status Replace(SString S, SString T, SString V) {
    int i = 1;
    if (StrEmpty(T)) return ERROR;
    do {
        i = Index(S, T, i);
        if (i) {
            StrDelete(S, i, StrLength(T));
            StrInsert(S, i, V);
            i += StrLength(V);
        }
    } while (i);
    return OK;
}

int main() {
    SString s, t, v;

    // Example usage
    StrAssign(s, "Hello");
    StrAssign(t, "l");
    StrAssign(v, "XYZ");

    Replace(s, t, v);

    printf("%s\n", s + 1); // Output should be "HeXYZo"

    return 0;
}
```

##### 堆分配存储表示：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef int Status;

#define MAXSTRLEN 255

#define OK 1
#define ERROR 0
#define FALSE -1
#define TRUE 2
#define OVERFLOW -2

typedef struct {
    char *ch;   // Pointer to the dynamic array storing the characters of the string
    int length; // Length of the string
} HString;

// Function to initialize a string
Status InitString(HString *T) {
    T->length = 0;
    T->ch = NULL;
    return OK;
}

// Function to clear the string
Status ClearString(HString *S) {
    if (S->ch) {
        free(S->ch);
        S->ch = NULL; // Set the pointer to NULL after freeing the memory
        S->length = 0;
    }
    return OK;
}

// Function to assign a character array to a string
Status StrAssign(HString *T, char *chars) {
    int i = strlen(chars);
    if (!i) {
        T->ch = NULL;
        T->length = 0;
    } else {
        T->ch = (char*)malloc((i + 1) * sizeof(char)); // Allocate memory for the string including '\0'
        if (!T->ch) exit(OVERFLOW);
        strcpy(T->ch, chars); // Use strcpy to copy characters from chars to T->ch
        T->length = i;
    }
    return OK;
}

// Function to copy a string
Status StrCopy(HString *T, HString S) {
    T->ch = (char*)malloc((S.length + 1) * sizeof(char)); // Allocate memory for the string including '\0'
    if (!T->ch) return ERROR;
    strcpy(T->ch, S.ch); // Use strcpy to copy characters from S.ch to T->ch
    T->length = S.length;
    return OK;
}

// Function to check if a string is empty
Status StrEmpty(HString S) {
    return (S.length == 0 && S.ch == NULL) ? TRUE : FALSE;
}

// Function to get the length of a string
int StrLength(HString S) {
    return S.length;
}

// Function to compare two strings

//使用strcmp函数的字符串比较
//int StrCompare(HString S, HString T) {
//    return strcmp(S.ch, T.ch); // Use strcmp to compare strings
//}

//不使用函数的字符串比较
int StrCompare(HString S, HString T) {
    int i = 0;
    while (S.ch[i] != '\0' && T.ch[i] != '\0') {
        if (S.ch[i] != T.ch[i]) {
            return S.ch[i] - T.ch[i];
        }
        i++;
    }
    // 如果两个字符串中的所有字符都相等，但其中一个字符串长度更长，则返回长度差值
    return S.length - T.length;
}

// Function to insert a string into another string at a specified position
Status StrInsert(HString *S, int pos, HString T) {
    if (pos < 1 || pos > S->length + 1) return ERROR;
    if (T.length) 
    {
        S->ch = (char*)realloc(S->ch, (S->length + T.length + 1) * sizeof(char)); // Reallocate memory
        if (!S->ch) return ERROR;
        
        memmove(S->ch + pos + T.length - 1, S->ch + pos - 1, (S->length - pos + 2) * sizeof(char)); // Move characters to make space for insertion
      
        memcpy(S->ch + pos - 1, T.ch, T.length * sizeof(char)); // Copy characters of T to the specified position in S
        S->length += T.length;
    }
    return OK;
}

Status StrInsert(HString *S, int pos, HString T) {
    if (pos < 1 || pos > S->length + 1) return ERROR; // 检查插入位置是否合法
    if (T.length) {
        // 重新分配内存空间
        S->ch = (char*)realloc(S->ch, (S->length + T.length + 1) * sizeof(char));
        if (!S->ch) return ERROR; // 内存分配失败
        
        // 后移字符以腾出插入位置
        for (int i = S->length; i >= pos; i--) {
            S->ch[i + T.length] = S->ch[i - 1];
        }
        
        // 插入字符串T
        for (int i = 0; i < T.length; i++) {
            S->ch[pos + i - 1] = T.ch[i];
        }
        
        S->length += T.length; // 更新长度
    }
    return OK;
}


// Function to delete a substring from a string
Status StrDelete(HString *S, int pos, int len) {
    if (pos < 1 || pos + len - 1 > S->length) return ERROR;
    memmove(S->ch + pos - 1, S->ch + pos + len - 1, (S->length - pos - len + 2) * sizeof(char)); // Move characters to remove the substring
    S->length -= len;
    S->ch = (char*)realloc(S->ch, (S->length + 1) * sizeof(char)); // Reallocate memory
    return OK;
}

// Function to replace all occurrences of a substring in a string with another substring
Status Replace(HString *S, HString T, HString V) {
    int i = 1;
    if (StrEmpty(T)) return ERROR;
    do {
        i = StrIndex(*S, T, i); // Call StrIndex function
        if (i) {
            StrDelete(S, i, T.length);
            StrInsert(S, i, V);
            i += V.length;
        }
    } while (i);
    return OK;
}

// Function to find the first occurrence of a substring in a string
int StrIndex(HString S, HString T, int pos) {
    int i = pos, j = 1;
    while (i <= S.length && j <= T.length) {
        if (S.ch[i - 1] == T.ch[j - 1]) {
            ++i;
            ++j;
        } 
        else {
            i = i - j + 2;
            j = 1;
        }
    }
    if (j > T.length) return i - T.length;
    else return 0;
}

int main() {
    HString s, t, v;

    // Initialize strings
    InitString(&s);
    InitString(&t);
    InitString(&v);

    // Assign values to strings
    StrAssign(&s, "Hello");
    StrAssign(&t, "l");
    StrAssign(&v, "XYZ");

    // Replace all occurrences of string t in string s with string v
    Replace(&s, t, v);

    // Output the modified string s
    printf("%s\n", s.ch);

    // Clear memory
    ClearString(&s);
    ClearString(&t);
    ClearString(&v);

    return 0;
}
```



##### BF算法：

```c
int Index(SString S,SString T,int pos)
{
    if(pos >= 1 && pos <= S[0])
    {
        int i = pos;
        int j = 1;
        while(i <= S[0] && j <= T[0])
        {
            if(S[i] == T[j])
            {
                ++i;++j;
            }
            else
            {
                i = i - j + 2;
                j = 1;
            }
        }
        if(j > T[0])    return i - T[0];//返回 离pos 的距离
        else return 0;
    }
    else return 0;
}
```



##### KMP算法

```c
// 计算子串T的next数组
void GetNext(SString T, int *next) {
    int i = 1;
    int j = 0;
    next[1] = 0;
    while (i < T[0]) 
    {
        if (j == 0 || T[i] == T[j]) 
        {
            ++i; ++j;
            next[i] = j;
        } 
        else    j = next[j];
    }
}

// 使用KMP算法在字符串S中查找子串T
int Index(SString S, SString T, int pos) {
    int i = pos;
    int j = 1;
    int s_len = S[0];
    int t_len = T[0];
    int next[MAXSTRLEN];
    GetNext(T, next); // 获取子串T的next数组

    while (i <= s_len && j <= t_len) 
    {
        if (j == 0 || S[i] == T[j]) 
        {
            ++i; ++j;
        }
        else   j = next[j]; // 根据next数组进行回溯
    }
    if (j > t_len)    return i - t_len;
    else 	   return 0;
}
```



#### 1. 串的基本操作

```c
//AIxi
#include <stdio.h>
#include <string.h>

#define MAIN_STR_LEN 100
#define SUB_STR_LEN 20

int MyStrCompare(char* Str1, char* Str2) 
{ 
    int i;
    int result = 0;
    for (i = 1; (i <= Str1[0]) && (i <= Str2[0]); i++) 
    {
        if (Str1[i] > Str2[i]) 
        {
            result = 1;
            break;
        } 
        else if (Str1[i] < Str2[i]) 
        {
            result = -1;
            break;
        } 
    }
    if (result == 0) 
    {
        if (Str1[0] > Str2[0]) 
        {
            result = 1;
        } 
        else if (Str1[0] < Str2[0]) 
        {
            result = -1;
        } 
    } 
    return result;
}

int MySubStrIndex(char* MainStr , char* SubStr , int pos) 
{
    int i, j, result;
    if ((pos < 0) || (pos > (MainStr [0] - SubStr[0] + 1))) 
    {
        return 0;
    } 
    i = pos;
    j = 1;
    while (i <= MainStr [0] && j <= SubStr [0]) 
    {
        if (MainStr[i] == SubStr[j]) 
        {
            i++;
            j++;
        } 
        else 
        {
            i = i - j + 2;
            j = 1;
        }
    }
    if (j > SubStr [0]) 
    {
        result = i - SubStr [0];
    } 
    else 
    {
        result = 0;
    }
    return result;
}

char MyStrDelete(char* S, int pos , int len) 
{
    int i;
    if (pos < 1 || pos > S[0] - len + 1 || len < 0)
        return -1;
    for (i = pos + len; i <= S[0]; i++)
        S[i - len] = S[i];
    S[0] -= len;
    return 1;
}

char MyStrInsert(char* S, int pos , char* T) 
{
    int i;
    if (pos < 1 || pos > S[0] + 1)
        return -1;
    if (S[0] + T[0] <= MAIN_STR_LEN) 
    {
        for (i = S[0]; i >= pos; i--) 
        {
            S[i + T[0]] = S[i];
        }
        for (i = pos; i < pos + T[0]; i++) 
        {
            S[i] = T[i - pos + 1];
        }
        S[0] = S[0] + T[0];
        return 1;
    } 
    else 
    {
        for (i = MAIN_STR_LEN; i <= pos; i--) 
        {
            S[i] = S[i - T[0]];
        }
        for (i = pos; i < pos + T[0]; i++) 
        {
            S[i] = T[i - pos + 1];
        }
        S[0] = MAIN_STR_LEN;
        return 0;
    }
}

int MyStrAssign(char * StrTobeAssigned , char * StrInput)

{
    int len = strlen(StrInput);
    if (len > MAIN_STR_LEN)
        return -1;
    StrTobeAssigned[0] = len;
    strcpy(&StrTobeAssigned[1], StrInput);
    return 1;
}

int MyStrReplace(char * MainStr , char * SubStr1 , char * SubStr2)

{
    int i = 1, tot = 0;
    do 
    {
        i = MySubStrIndex(MainStr, SubStr1, i);
        if (i)
        {
            MyStrDelete(MainStr, i, SubStr1[0]);
            MyStrInsert(MainStr, i, SubStr2);
            i += strlen(SubStr2);
            tot++;
        }
    } while (i);
    return tot;
}

int main() 
{
    char MainStr[MAIN_STR_LEN + 1];
    char SubStr1[SUB_STR_LEN + 1];
    char SubStr2[SUB_STR_LEN + 1];
    int i;
    int compareResult;
    int pos;
    int replaceCounter = 0;
    char InputBuf[3][MAIN_STR_LEN + 1];

    printf("please input 3 strings as MainStr , SubStr1 and SubStr2\n");
    scanf("%s %s %s", InputBuf[0], InputBuf[1], InputBuf [2]);

    if (MyStrAssign(MainStr, InputBuf[0]) == -1 || MyStrAssign(SubStr1, InputBuf[1]) == -1 || MyStrAssign(SubStr2, InputBuf[2]) == -1)
    {
        printf("Error: String length exceeds maximum length\n");
        return -1;
    }

    printf("MainStr =:%d,", MainStr[0]);
    for (i = 1; i <= MainStr[0]; i++) 
    {
        printf("%c,", MainStr[i]);
    }
    printf("\n");
    printf("SubStr1 =:%d,", SubStr1[0]);
    for (i = 1; i <= SubStr1[0]; i++) 
    {
        printf("%c,", SubStr1[i]);
    }
    printf("\n");
    printf("SubStr2 =:%d,", SubStr2[0]);
    for (i = 1; i <= SubStr2[0]; i++) 
    {
        printf("%c,", SubStr2[i]);
    }
    printf("\n");

    compareResult = MyStrCompare(SubStr1, SubStr2);
    printf("SubStr1 compare with SubStr2 is %d\n", compareResult);

    pos = MySubStrIndex(MainStr, SubStr1, 1);
    printf("pos of SubStr1 in MainStr is %d\n", pos);

    pos = MySubStrIndex(MainStr, SubStr2, 1);
    printf("pos of SubStr2 in MainStr is %d\n", pos);

    replaceCounter = MyStrReplace(MainStr, SubStr1, SubStr2);
    printf("The content of MainStr after %d times of replacing SubStr1 with SubStr2 is :\n%d,", replaceCounter , MainStr[0]);
    for (i = 1; i <= MainStr[0]; i++) 
    {
        printf("%c,", MainStr[i]);
    }
    printf("\n");
    return 0;
}
```



#### 2. 统计字符数



```c
//自己写的代码

#include <stdio.h>
#include <string.h>

#define MAXSTRLEN 100
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

typedef char SString[MAXSTRLEN + 1];

void SStringAssign(SString S,char*str)
{
	int i = 1,len = 0;
	for(;str[len] != '\0';len ++)
	for(;str[i - 1] != '\0';i ++)
	{
		S[i] = str[i - 1];
	}
	S[0] = len;
	S[len + 1] = '\0'; 
}

void CountStr(SString S,int *total)
{
	int i = 1;
	for(;i <= S[0];i ++)
	{
		total[S[i] - 'a'] ++;
	}
}

void PrintMax(int *total)
{
	int max = total[0],i = 0,max_n = 0;
	for(;i < 26;i ++)
	{
		if(max < total[i])
		{
			max = total[i] ;
			max_n = i;
		}
	}
	printf("%c %d\n",max_n + 'a',max);
}

int main(int argc, char *argv[]) 
{
	int n ;
	scanf("%d",&n);
	getchar();
	while(n --)
	{
		SString S;
		char str[MAXSTRLEN + 1000];
		scanf("%s",str); 
        str[100] = '\0';
		getchar();
		//printf("%s",str); 
		SStringAssign(S,str);
		
		int total[26] = {0};
		CountStr(S,total);
		
		PrintMax(total);			
	} 
	return 0;
}
```



```c
//AI修改的代码

#include <stdio.h>
#include <string.h>

#define MAXSTRLEN 100
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

typedef char SString[MAXSTRLEN + 2]; // 加一位存储字符串长度，一位存储字符串结尾标记

void SStringAssign(SString S, char *str) {
    int len = strlen(str);
    S[0] = len;
    strncpy(&S[1], str, MAXSTRLEN); // 将字符串复制到 SString 结构体中
    S[len + 1] = '\0'; // 添加字符串结尾标记
}

void CountStr(SString S, int *total) {
    int i;
    for (i = 1; i <= S[0]; i++) {
        total[S[i] - 'a']++;
    }
}

void PrintMax(int *total) {
    int max = total[0], i, max_n = 0;
    for (i = 0; i < 26; i++) {
        if (max < total[i]) {
            max = total[i];
            max_n = i;
        }
    }
    printf("%c %d\n", max_n + 'a', max);
}

int main(int argc, char *argv[]) {
    int n;
    scanf("%d", &n);
    getchar(); // 清除换行符
    while (n--) {
        SString S;
        char str[MAXSTRLEN + 1]; // 调整字符数组大小
        scanf("%100s", str); // 限制输入的最大长度为100个字符
        getchar(); // 清除换行符

        SStringAssign(S, str);

        int total[26] = {0};
        CountStr(S, total);

        PrintMax(total);
    }
    return 0;
}
```



#### 3.字符串连接

```c
//自编代码

#include <stdio.h>
#include <string.h>
#define MAXSTRLEN 100
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

typedef char SString[MAXSTRLEN + 1];

void StrAssign(SString S,char*str)
{
	int i = 1;
	for(;str[i - 1] != '\0';i ++)
	{
		if(str[i - 1] == '#')	break;
		S[i] = str[i - 1];
	}
	S[0] = i;
	S[i + 1] = '\0';
}

int StrConcat(SString S, SString T) {
    if (S[0] + T[0] > MAXSTRLEN) {
        return ERROR;
    }
    int i = 1;
	for(;S[i] != '\0';i++)
	{
		T[T[0] + i] = S[i];
	}
    
    T[0] += S[0];

    return OK;
}

int main(int argc, char *argv[]) 
{
	int n = 1000,i;
	char str1[n],str2[n];
       
	//scanf("%s %s",str1,str2);  //这样输入出问题了，中间有空格，就间断输入了
   
    // 读取两个字符串，以 '#' 结束
    scanf("%[^#]#", str1);
    getchar();  // 读取并丢弃换行符
    scanf("%[^#]#", str2);
    
	//printf("%s\n",str1);
	//printf("%s\n",str2);
    
	SString S,T;
	StrAssign(S,str1);
	StrAssign(T,str2);
	
	StrConcat(S,T);
	
	for(i = 1;i <= T[0];i ++)
	{
		printf("%c",T[i]);
	}
	printf("\n");
	return 0;
}
```



#### 4. 词频统计

```c
//AI跑得代码   
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_WORD_LENGTH 50
#define HASH_SIZE 1000

// 定义单词节点结构体
typedef struct WordNode {
    char word[MAX_WORD_LENGTH];
    int count;
    struct WordNode* next;
} WordNode;

// 定义哈希表结构体
typedef struct {
    WordNode* buckets[HASH_SIZE];
} HashTable;

// 哈希函数，将单词转换为哈希值
int hash(char *word) {
    int hash = 0;
    while (*word) {
        hash = (hash * 31 + *word) % HASH_SIZE;
        word++;
    }
    return hash;
}

// 创建单词节点
WordNode* createWordNode(char *word) {
    WordNode* newNode = (WordNode*)malloc(sizeof(WordNode));
    if (newNode == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }
    strcpy(newNode->word, word);
    newNode->count = 1;
    newNode->next = NULL;
    return newNode;
}

// 在哈希表中查找单词节点，如果不存在则返回NULL
WordNode* findWord(HashTable* hashTable, char *word) {
    int index = hash(word);
    WordNode* current = hashTable->buckets[index];
    while (current != NULL) {
        if (strcmp(current->word, word) == 0) {
            return current;
        }
        current = current->next;
    }
    return NULL;
}

// 向哈希表中插入单词节点，如果已存在则增加计数，否则创建新节点插入
void insertWord(HashTable* hashTable, char *word) {
    int index = hash(word);
    WordNode* current = hashTable->buckets[index];
    WordNode* previous = NULL;
    while (current != NULL) {
        if (strcmp(current->word, word) == 0) {
            current->count++;
            return;
        }
        previous = current;
        current = current->next;
    }
    // 单词不存在，创建新节点插入
    WordNode* newNode = createWordNode(word);
    if (previous == NULL) {
        hashTable->buckets[index] = newNode;
    } else {
        previous->next = newNode;
    }
}

// 比较函数，用于qsort排序
int compare(const void *a, const void *b) {
    const WordNode *word1 = *(const WordNode **)a;
    const WordNode *word2 = *(const WordNode **)b;
    // 先比较出现次数，出现次数相同时按照字典序排序
    if (word1->count != word2->count) {
        return word2->count - word1->count;
    } else {
        return strcmp(word1->word, word2->word);
    }
}

// 释放哈希表
void freeHashTable(HashTable* hashTable) {
    for (int i = 0; i < HASH_SIZE; i++) {
        WordNode* current = hashTable->buckets[i];
        while (current != NULL) {
            WordNode* temp = current;
            current = current->next;
            free(temp);
        }
    }
    free(hashTable);
}

int main() {
    // 打开文件
    FILE *file = fopen("article.txt", "r");
    if (file == NULL) {
        fprintf(stderr, "Failed to open file\n");
        return 1;
    }

    // 创建哈希表
    HashTable* hashTable = (HashTable*)malloc(sizeof(HashTable));
    if (hashTable == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        return 1;
    }
    memset(hashTable->buckets, 0, sizeof(hashTable->buckets));

    char word[MAX_WORD_LENGTH];
    // 读取文件中的每个单词并进行统计
    while (fscanf(file, "%s", word) == 1) {
        // 转换为小写
        for (int i = 0; word[i]; i++) {
            word[i] = tolower(word[i]);
        }
        // 去除单词末尾的标点符号
        int len = strlen(word);
        while (len > 0 && ispunct(word[len - 1])) {
            word[len - 1] = '\0';
            len--;
        }
        // 插入哈希表
        insertWord(hashTable, word);
    }
    fclose(file);

    // 将哈希表中的单词节点存入数组
    WordNode* wordArray[HASH_SIZE];
    int count = 0;
    for (int i = 0; i < HASH_SIZE; i++) {
        WordNode* current = hashTable->buckets[i];
        while (current != NULL) {
            wordArray[count++] = current;
            current = current->next;
        }
    }

    // 对单词节点数组按照出现次数进行排序
    qsort(wordArray, count, sizeof(WordNode*), compare);

    // 输出前100个单词及其出现次数
    int numWords = count < 100 ? count : 100;
    for (int i = 0; i < numWords; i++) {
        printf("%s %d\n", wordArray[i]->word, wordArray[i]->count);
    }

    // 释放内存
    freeHashTable(hashTable);

    return 0;
}

```



#### 5. 字符串中的第一个唯一字符

```c
//我的代码
#include <stdio.h>
#include <string.h>

#define MAXSTRLEN 300000
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

typedef char SString [MAXSTRLEN + 1]; 

void StrAssign(SString S,char*str)
{
	int i = 1;
	for(;str[i - 1] != '\0';i ++)
	{
		S[i] = str[i - 1];
	}
	S[0] = i - 1;
	S[i] = '\0';
}

int Unique_Index(SString S)
{
	if(S[0] == 0)	return -1;
	int i,j,tag;
	for(i = 1;i <= S[0];i ++)
	{
		for(j = 1;j <= S[0];j ++)
		{
			tag = -1;
			if(j == i)	continue;	
			else if(S[i] == S[j])	break;
			if(S[i] != S[j])	tag = i;
		}
		if(tag != -1)	return i - 1;
	}
	return -1;
}

int main(int argc, char *argv[]) 
{
	char str[MAXSTRLEN + 1];
	scanf("%s",str);
	
	SString S;
	StrAssign(S,str);
	
	int a = Unique_Index(S);
	printf("%d",a); 
	
	return 0;
}
```



```c
//AI跑的代码
#include <stdio.h>
#include <string.h>

#define MAXSTRLEN 300000
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

typedef char SString[MAXSTRLEN + 1];

void StrAssign(SString S, char *str) {
    int i = 1;
    for (; str[i - 1] != '\0'; i++) {
        S[i] = str[i - 1];
    }
    S[0] = i - 1; // 修正字符串长度
    S[i] = '\0';
}

int Unique_Index(SString S) {
    if (S[0] == 0) return -1; // 如果字符串为空，则返回 -1
    int i;
    int char_count[256] = {0}; // 哈希表，用于记录每个字符的出现次数
    // 第一次遍历字符串，统计每个字符出现的次数
    for (i = 1; i <= S[0]; i++) {
        char_count[(int)S[i]]++; // 将字符映射到哈希表中，并统计出现次数
    }
    // 第二次遍历字符串，找到第一个出现次数为1的字符，返回其下标
    for (i = 1; i <= S[0]; i++) {
        if (char_count[(int)S[i]] == 1) {
            return i - 1;
        }
    }
    return -1;
}

int main(int argc, char *argv[]) {
    char str[MAXSTRLEN + 1];
    scanf("%s", str);

    SString S;
    StrAssign(S, str);

    int a = Unique_Index(S);
    printf("%d", a);

    return 0;
}

```



#### 6. 求一个串中出现的第一个最长重复子串

```c
#include <stdio.h>
#include <string.h>
#include<malloc.h>

#define MAXSTRLEN 255
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

int check(char *s, int x, int n,int *pos) 
{
	int j = 0,i,k;

	for(;j < n - x + 1;j ++)
	{
		char substr[x + 1];
		for(i = j,k=0;i < x + j; i ++,k++)
		{
			substr[k] = s[i];
		}
		substr[x] = '\0';
	    int count = 0;
		for (i = 0; i <= n - x; i++) 
		{
	        if (strncmp(s + i, substr, x) == 0) 
			{
	            count++;
	        }
	        if(count == 2)
	        {
	        	*pos = j;
	        	return 1;
			}
	    } 
	}
	return 0;
}

char *search_longest_repeated_substring(char *s, int n) {
    int l = 0, r = n,pos = 0;
    while (l < r) {
        int mid = l + (r - l + 1) / 2;
        if (check(s, mid, n, &pos))    l = mid;
        else      r = mid - 1;
    }
    if (l == 0) {
        return NULL;
    }
    char *result;
	result = (char*)malloc((l + 1) * sizeof(char));
    if (result == NULL) {
        printf("内存分配失败\n");
        return NULL;
    }
    strncpy(result, s + pos, l);
    result[l] = '\0';
    return result;
}

int main() {
    char *s = malloc(MAXSTRLEN * sizeof(char));
    if (s == NULL) 
	{
        printf("内存分配失败\n");
        return 1;
    }
    scanf("%s", s);

    char *result = search_longest_repeated_substring(s, strlen(s));
    
    if (result == NULL) 
	{
        printf("没有最长重复子串\n");
    }
	 else 
	 {
        printf("%s\n", result);
        free(result);
    }

    free(s);

    return 0;
}

```



```c
//AI优化的hash算法
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAXSTRLEN 255
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

// Function to compute the hash value of a substring
unsigned long long hash(char *s, int start, int end) {
    unsigned long long hash_value = 0;
    for (int i = start; i <= end; i++) {
        hash_value = hash_value * 31 + s[i];
    }
    return hash_value;
}

// Function to check if a substring appears more than once in the string
int check(char *s, int x, int n, int *pos) {
    unsigned long long *hashes = malloc((n - x + 1) * sizeof(unsigned long long));
    if (hashes == NULL) {
        printf("内存分配失败\n");
        return ERROR;
    }

    // Precompute hashes for all substrings of length x
    for (int i = 0; i <= n - x; i++) {
        hashes[i] = hash(s, i, i + x - 1);
    }

    // Search for repeated substrings using the hashes
    for (int i = 0; i <= n - x; i++) {
        unsigned long long target_hash = hashes[i];
        int count = 0;
        for (int j = i + 1; j <= n - x; j++) {
            if (hashes[j] == target_hash) {
                count++;
                if (count == 1) {
                    *pos = i;
                    free(hashes);
                    return TRUE;
                }
            }
        }
    }

    free(hashes);
    return FALSE;
}

char *search_longest_repeated_substring(char *s, int n) {
    int l = 0, r = n, pos = 0;
    while (l < r) {
        int mid = l + (r - l + 1) / 2;
        if (check(s, mid, n, &pos))    l = mid;
        else      r = mid - 1;
    }
    if (l == 0) {
        return NULL;
    }
    char *result;
    result = (char *)malloc((l + 1) * sizeof(char));
    if (result == NULL) {
        printf("内存分配失败\n");
        return NULL;
    }
    strncpy(result, s + pos, l);
    result[l] = '\0';
    return result;
}

int main() {
    char *s = malloc(MAXSTRLEN * sizeof(char));
    if (s == NULL) {
        printf("内存分配失败\n");
        return 1;
    }
    scanf("%s", s);

    char *result = search_longest_repeated_substring(s, strlen(s));

    if (result == NULL) {
        printf("没有最长重复子串\n");
    } else {
        printf("%s\n", result);
        free(result);
    }

    free(s);

    return 0;
}

```



#### 7. Caesar密码

```c
//AI	跑的代码
#include <stdio.h>
#include <string.h>

// 函数用于解密Caesar密码
void decrypt_caesar(char *cipher_text) {
    // 定义字母替换表
    char mapping[26] = {
        'V', 'W', 'X', 'Y', 'Z', 'A', 'B', 'C', 'D', 'E',
        'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
        'P', 'Q', 'R', 'S', 'T', 'U'
    };

    // 对密码消息中的每个字符进行解密
    for (int i = 0; cipher_text[i] != '\0'; i++) {
        // 如果是字母，则进行解密
        if (cipher_text[i] >= 'A' && cipher_text[i] <= 'Z') {
            cipher_text[i] = mapping[cipher_text[i] - 'A'];
        }
    }
}

int main() {
    char line[200];

    // 读取输入直到遇到ENDOFINPUT
    while (1) {
        scanf("%s", line);
        if (strcmp(line, "ENDOFINPUT") == 0) {
            break;
        }

        if (strcmp(line, "START") == 0) {
            getchar(); // 消耗掉换行符
            fgets(line, 200, stdin); // 读取密码消息
            decrypt_caesar(line); // 解密消息
            printf("%s", line); // 输出原始消息
        }
    }

    return 0;
}

```



#### 8.判断等值子串

```c
//算法1 —— 贪心
#include <stdio.h>
#include <string.h>

void longest_equal_substring(char *s) {
    int max_length = 0;
    char *max_substring = NULL;
    
    int current_length = 1,i;
    char *current_start = s;
    for ( i = 1; s[i] != '!'; i++) {
        if (s[i] == s[i - 1]) {
            current_length++;
        } else {
            if (current_length > max_length) {
                max_length = current_length;
                max_substring = current_start;
            }
            current_length = 1;
            current_start = s + i;
        }
    }
    
    // Check the last substring
    if (current_length > max_length) {
        max_length = current_length;
        max_substring = current_start;
    }

    if (max_length > 1) {
        for (i = 0; i < max_length; i++) {
            printf("%c", max_substring[i]);
        }
    } else {
        printf("no");
    }
}

int main() {
    char input_str[1000];
    scanf("%s", input_str);
    longest_equal_substring(input_str);
    return 0;
}

```



```c
//算法2 —— 双指针
#include <stdio.h>
#include <string.h>

void longest_equal_substring(char *s) {
    int n = strlen(s);
    int max_length = 0;
    int max_start = 0;

    int start = 0; // 记录当前等值子串的起始位置
    for (int i = 1; i <= n; i++) {
        if (s[i] != s[i - 1]) {
            int length = i - start; // 计算当前等值子串的长度
            if (length > max_length) {
                max_length = length;
                max_start = start;
            }
            start = i; // 更新当前等值子串的起始位置
        }
    }

    if (max_length > 1) {
        for (int i = max_start; i < max_start + max_length; i++) {
            printf("%c", s[i]);
        }
    } else {
        printf("no");
    }
}

int main() {
    char input_str[1000];
    scanf("%s", input_str);
    longest_equal_substring(input_str);
    return 0;
}

```



```c
//算法3 —— 动态规划
#include <stdio.h>
#include <string.h>

void longest_equal_substring(char *s) {
    int n = strlen(s);
    int max_length = 0;
    int max_start = 0;
    
    int current_length = 1;
    for (int i = 1; i < n; i++) {
        if (s[i] == s[i - 1]) {
            current_length++;
        } else {
            if (current_length > max_length) {
                max_length = current_length;
                max_start = i - max_length;
            }
            current_length = 1;
        }
    }
    
    // Check the last substring
    if (current_length > max_length) {
        max_length = current_length;
        max_start = n - max_length;
    }

    if (max_length > 1) {
        for (int i = max_start; i < max_start + max_length; i++) {
            printf("%c", s[i]);
        }
    } else {
        printf("no");
    }
}

int main() {
    char input_str[1000];
    scanf("%s", input_str);
    longest_equal_substring(input_str);
    return 0;
}

```



#### 9.判断两个字符串是否匹配



```c
//我的代码 + AI优化
#include <stdio.h>
#include <stdbool.h>

#define TRUE 1
#define FALSE 0

bool isMatch(char *str1, char *str2) {
    // 当两个字符串都为空时，它们是匹配的
    if (*str1 == '\0' && *str2 == '\0')
        return TRUE;
    
    // 当其中一个字符串为空时，另一个不为空，它们不匹配
    if (*str1 == '\0' || *str2 == '\0')
        return FALSE;

    // 如果当前字符匹配或者是 '?'，则继续比较下一个字符
    if (*str1 == *str2 || *str2 == '?')
        return isMatch(str1 + 1, str2 + 1);

    // 如果遇到 '*'，则递归地尝试所有可能的情况
    if (*str2 == '*') {
        // 将 '*' 后面的子串作为模式串
        char *pattern = str2 + 1;
        
		while(*pattern == '*')	
		{
			pattern ++; 
			str1++;
		}
		       
		if(*pattern == '\0')	return TRUE;
		
		while(*pattern == '?')
		{
			pattern++;
        	str1++;
        	
        	// 当两个字符串都为空时，它们是匹配的
   			if (*str1 == '\0' && *pattern == '\0')
        		return TRUE;
        		
        	// 当其中一个字符串为空时，另一个不为空，它们不匹配
    		if (*str1 == '\0' || *str2 == '\0')
        		return FALSE;
		}
		

		
        // 在 str1 中查找所有可能的匹配
        while (*str1 != '\0') {
            if (isMatch(str1, pattern))
                return TRUE;
            str1++;
        }

        // 如果在 str1 中没有找到匹配，则返回 FALSE
        return FALSE;
    }

    // 如果当前字符不匹配，且不是通配符，则说明不匹配
    return FALSE;
}


int main() {
    char str1[1000], str2[1000];

    // 读取两个字符串，以 '#' 结束
    scanf("%[^#]#", str1);
    getchar();  // 读取并丢弃换行符
    scanf("%[^#]#", str2);
    
//    puts(str1);
//	puts(str2); 
    
    // 调用匹配函数进行匹配
    if (isMatch(str2, str1)) {
        printf("yes\n");
    } else {
        printf("no\n");
    }

    return 0;
}
```



```c
//AI跑得	有bug
#include <stdio.h>
#include <stdbool.h>
#include <string.h>

// Function to check if two strings match considering wildcard characters
bool isMatch(char *str1, char *str2) {
    // Pointers to traverse both strings
    char *s1 = str1, *s2 = str2;
    // Pointers to store the positions when '*' and '?' are encountered
    char *star = NULL, *ques = NULL;

    // Traverse until the end of the first string
    while (*s1 != '\0' && *s2 != '\0') {
        // If current characters match or '?' is encountered
        if (*s2 == *s1 || *s2 == '?') {
            s1++;
            s2++;
        }
        // If '*' is encountered in the second string
        else if (*s2 == '*') {
            star = s2; // Store the position of '*'
            ques = s1; // Store the position of corresponding character in the first string
            s2++;      // Move to the next character in the second string
        }
        // If characters don't match and there is no '*' in the second string
        // Go back to the last '*' position and try to match from there
        else if (star != NULL) {
            s2 = star + 1; // Move to the next character after '*'
            s1 = ++ques;   // Move to the next character in the first string from the last '*' position
        } else {
            return false; // If no '*' encountered and characters don't match, return false
        }
    }

    // Ignore any extra '*' characters in the second string
    while (*s2 == '*') {
        s2++;
    }

    // If both strings have reached the end, return true
    return (*s1 == '\0' && (*s2 == '\0' || (*s2 == '*' && *(s2+1) == '\0')));
}

int main() {
    // Input two strings terminated by '#'
    char str1[100], str2[100];
    scanf("%[^#]#%[^#]#", str1, str2);

    // Check if the strings match and print the result
    if (isMatch(str1, str2)) {
        printf("yes\n");
    } else {
        printf("no\n");
    }

    return 0;
}

```

```c
//leetcode 官方解答 —— 动态规划方案	仍有bug
#include <stdio.h>
#include<string.h>
#include <stdbool.h>

bool isMatch(char* s, char* p) {
    int m = strlen(s),j;
    int n = strlen(p),i;
    int dp[m + 1][n + 1];
    memset(dp, 0, sizeof(dp));
    dp[0][0] = true;
    for (i = 1; i <= n; ++i) {
        if (p[i - 1] == '*') {
            dp[0][i] = true;
        } else {
            break;
        }
    }
    for (i = 1; i <= m; ++i) {
        for (j = 1; j <= n; ++j) {
            if (p[j - 1] == '*') {
                dp[i][j] = dp[i][j - 1] | dp[i - 1][j];
            } else if (p[j - 1] == '?' || s[i - 1] == p[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            }
        }
    }
    return dp[m][n];
}


int main() {
    char str1[1000], str2[1000];

    // 读取两个字符串，以 '#' 结束
    scanf("%[^#]#", str1);
    getchar();
    scanf(" %[^#]#", str2);
    
    //putchar(ch);
	
//	scanf("%s",str1);
//	scanf("%s",str2);
	//puts(str1);
	//puts(str2); 
	
    // 调用匹配函数进行匹配
    if (isMatch(str1, str2)) {
        printf("yes\n");
    } else {
        printf("no\n");
    }

    return 0;
}

```



### 作业7——递归



#### 学习代码：

```c
void reverse_List_recursive(LNode *prev, LNode *curr, LNode **head) {
    if (curr == NULL) {
        *head = prev; // 更新逆序后的链表头结点
        return;
    }
    reverse_List_recursive(curr, curr->next, head);
    curr->next = prev;
}

void reverse_List(LinkList L) {
    LNode *head = NULL; // 逆序后的链表头结点
    reverse_List_recursive(NULL, L->next, &head);
    L->next = head; // 更新原链表的头结点
}
```



#### 1. 递归实验--阶乘

```c
#include <stdio.h>

#include <stdlib.h>

#include <string.h>

#include <math.h>

 

int JieCheng(int n)

{

/* 代码填在这里 */
    if(n == 1)    return n;
    if(n > 15)
    {
        printf("无法计算\n");
        return 0;
    }
    return n*JieCheng(n - 1);
}

 

int main()

{

    int a;

    int n;

    a=0;

    printf("Input n:\n");

    scanf("%d",&n);

    a = JieCheng(n);

    printf("%d的阶乘为%d",n,a);

}

```



#### 2.用递归方法创建单链表-副本

```c
#include <stdio.h>   
#include <stdlib.h>   
#include <malloc.h>

#define ERROR 0
#define OK 1

typedef int ElemType;   
typedef int Status;

// definition of node structure of singly linked list
typedef struct L_node 
{
    ElemType data;           // data field 
    struct L_node *next;     // pointer field
} LNode, *LinkedList;

// Initialize a singly linked list L with head node
Status InitList_L(LinkedList *L) 
{
    // Allocate memory for head node
	(*L) = (LinkedList)malloc(sizeof(LNode));
	if (!(*L)) return ERROR;
	(*L)->next = NULL;
	return OK; 
}

// 输入若干整数（以输入-1作为结束条件，-1不包含在单链表中），用递归方法创建一个不带头结点的单链表。
Status CreateList_L(LinkedList L) 
{
    ElemType input;
	scanf("%d", &input);
	if (input == -1) {
        // Set the next pointer of the last node to NULL
		L->next = NULL;
		return OK;
	}
    // Allocate memory for the next node
	L->next = (LinkedList)malloc(sizeof(LNode));
	if (!L->next) return ERROR;
    // Assign input value to the data field of the next node
	L->next->data = input;
    // Recursively create the next node
	CreateList_L(L->next);
	return OK;
}

// Print the elements in a list
void LinkedListPrint(LinkedList L) 
{
    // Base case: If the next node is NULL, return
	if (!L->next) return;
    // Print the data of the next node
	printf("%d ", L->next->data); 
    // Recursively print the rest of the list
	LinkedListPrint(L->next);
}

int main() 
{   
	LinkedList La;
	
    // Initialize the linked list
	InitList_L(&La);
	
    // Create the linked list using recursion
	CreateList_L(La);
	
    // Print the linked list
	LinkedListPrint(La);
	
	return 0;
}

```



#### 3. 递归实验--汉诺塔

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static int step = 0;

//移动函数
void move(int n, char *A, char *B)
{
    printf("将%d从%c移动到%c.\n", n, *A, *B);
    step++;
    return;
}

//将n层汉诺塔从A移动到C，B作为辅助
void Hanoi(int n, char *A, char *B, char *C)
{
   if (n == 1)    move(n, A, C); // 只有一层时直接从 A 移动到 C
   else 
   {
        Hanoi(n - 1, A, C, B); // 将 n-1 层汉诺塔从 A 移动到 B，以 C 为辅助
        move(n, A, C); // 将第 n 层从 A 移动到 C
        Hanoi(n - 1, B, A, C); // 将 n-1 层汉诺塔从 B 移动到 C，以 A 为辅助
    }
}

int main()
{
    int n;
    char axle[3] = {'A', 'B', 'C'};

    printf("输入层数n:");
    scanf("%d", &n);

    Hanoi(n, axle, axle + 1, axle + 2);

    printf("移完%d层汉诺塔所用总步数为%d\n", n, step);
    return 0;
}

```



#### 4. 递归实现单链表的反转

```c
#include <stdio.h>

#include <stdlib.h>

#include <string.h>

#define ERROR 0
#define OK 1

typedef struct L_Node
{
	int data;
	struct L_Node *next;
}LNode,*LinkList;

void InitList_L(LinkList* L)
{
	(*L) = (LinkList)malloc(sizeof(LNode));
	if(!(*L))	return ;
	(*L)->next = NULL;
}

void CreateList_L(LinkList L)
{
	int input;
	if(scanf("%d",&input) == EOF)	
	{
		L->next = NULL;
		return ;
	}	
	L->next = (LinkList)malloc(sizeof(LNode));
	if(!L->next)	return ;
	L->next->data = input;
	
	CreateList_L(L->next);
}

void reverse_List(LinkList L)
{
    if (L == NULL || L->next == NULL || L->next->next == NULL) {
        return;
    }

    // 递归反转除头结点之外的部分
    reverse_List(L->next);

    // 找到反转后的尾节点
    LNode *tail = L->next;
    while (tail->next != NULL) 
	{
        tail = tail->next;
    }

    // 将头结点后的节点（反转后的尾节点）移到头结点之前
    tail->next = L->next;
    L->next = L->next->next;
    tail->next->next = NULL;
}


void LinkListPrint(LinkList L)
{
	if(!L->next)	return ;
	printf("%d ",L->next->data);
	LinkListPrint(L->next);
}


int main()

{

    int n;
	
	scanf("%d",&n);
	
	LinkList La;
	
	InitList_L(&La);
	
	CreateList_L(La);
	
	reverse_List(La);
	
	LinkListPrint(La);

    return 0;

}
```



#### 5. 递归实现求链表中的最大整数

```c
//AI
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

// 链表节点的定义
typedef struct ListNode {
    int data;
    struct ListNode *next;
} ListNode;

// 递归函数，找到链表中的最大整数
int find_max(ListNode *head) {
    // 如果链表为空，返回最小的整数值
    if (head == NULL) {
        return INT_MIN;
    }
    // 如果只有一个节点，返回该节点的值
    if (head->next == NULL) {
        return head->data;
    }
    // 递归地比较当前节点的值与剩余链表中的最大值
    int max_rest = find_max(head->next);
    return head->data > max_rest ? head->data : max_rest;
}

int main() {
    int n;
    scanf("%d", &n); // 读取链表的长度
    ListNode *head = NULL;
    ListNode *prev = NULL;
    
    // 构建链表
    for (int i = 0; i < n; i++) {
        int val;
        scanf("%d", &val);
        ListNode *node = (ListNode *)malloc(sizeof(ListNode));
        node->data = val;
        node->next = NULL;
        if (head == NULL) {
            head = node;
        } else {
            prev->next = node;
        }
        prev = node;
    }
    
    // 调用递归函数找到最大值并输出
    int max_value = find_max(head);
    printf("%d\n", max_value);

    // 释放链表内存
    ListNode *current = head;
    while (current != NULL) {
        ListNode *temp = current;
        current = current->next;
        free(temp);
    }
    
    return 0;
}

```



```c
//自己的代码
#include <stdio.h>
#include <stdlib.h>

/* run this program using the console pauser or add your own getch, system("pause") or input loop */

typedef struct	L_Node
{
	int data;
	struct L_Node *next; 
}LNode,*LinkList;

void InitList_L(LinkList *L)
{
	(*L) = (LinkList)malloc(sizeof(LNode));
	if(!(*L))	return ;
	(*L)->next = NULL;
}

void CreateList_L(LinkList L,int n)
{
	LNode *p = L; 
	
	int arr,i;
	for(i = 0;i < n;i ++)
	{
		scanf("%d",&arr); 
		LNode *r ;
		r = (LinkList)malloc(sizeof(LNode));
		if(!r)	return ;
		r->data = arr;
		r->next = NULL;
		p->next = r;
		p = p->next;
	 } 
}

int find_max(LinkList L)
{
	if(!L|| !L->next)	return 0;
	if(!L->next->next)	return L->next->data;
	return L->next->data >= find_max(L->next) ? L->next->data : find_max(L->next);
}


int main(int argc, char *argv[]) 
{
	int n;
	scanf("%d",&n);
	
	LinkList L;
	
	InitList_L(&L);
	
	CreateList_L(L,n);
	
	printf("%d",find_max(L));

	return 0;
}
```



#### 6. 递归实现求链表的结点个数

```c
//AI
#include <stdio.h>
#include <stdlib.h>

// 链表节点的定义
typedef struct ListNode {
    int data;
    struct ListNode *next;
} ListNode;

// 递归函数，计算链表中的节点数量
int count_nodes(ListNode *head) {
    // 如果链表为空，返回0
    if (head == NULL) {
        return 0;
    }
    // 递归地计算剩余链表中的节点数量，并加上当前节点
    return 1 + count_nodes(head->next);
}

int main() {
    int n;
    scanf("%d", &n); // 读取链表的长度
    ListNode *head = NULL;
    ListNode *prev = NULL;
    
    // 构建链表
    for (int i = 0; i < n; i++) {
        int val;
        scanf("%d", &val);
        ListNode *node = (ListNode *)malloc(sizeof(ListNode));
        node->data = val;
        node->next = NULL;
        if (head == NULL) {
            head = node;
        } else {
            prev->next = node;
        }
        prev = node;
    }
    
    // 调用递归函数计算节点数量并输出
    int node_count = count_nodes(head);
    printf("%d\n", node_count);

    // 释放链表内存
    ListNode *current = head;
    while (current != NULL) {
        ListNode *temp = current;
        current = current->next;
        free(temp);
    }
    
    return 0;
}

```



```c
//自己的代码
#include <stdio.h>
#include <stdlib.h>

typedef struct L_Node
{
	int data;
	struct L_Node *next;
}LNode,*LinkList;

void InitList_L(LinkList *L)
{
	(*L) = (LinkList)malloc(sizeof(LNode));
	if(!(*L))	return ;
	(*L)->next = NULL; 
}

void CreateList_L(LinkList L,int n) 
{
	int i ,arr;
	LNode *p = L;
	for(i = 0;i < n; i ++)
	{
		scanf("%d",&arr);
		LNode *r;
		r = (LinkList)malloc(sizeof(LNode));
		r->data = arr;
		r->next = NULL;
		p->next = r;
		p = p->next;
	}
}

int Count_Node(LinkList L)
{
	if(!L->next)	return 0;
	return 1 + Count_Node(L->next);	
} 


int main(int argc, char *argv[]) 
{
	int n;
	scanf("%d",&n);
	
	LinkList L;
	
	InitList_L(&L);
	
	CreateList_L(L,n);
	
	printf("%d",Count_Node(L));
	
	return 0;
}
```



### 作业8——树

#### 学习代码：

###### 二叉链表的第一种创建方法：

```c++
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define OK 1
#define ERROR 0

typedef struct BiTNode 
{
    char data;
    struct BiTNode *lchild;
    struct BiTNode *rchild;
} BiTNode, *BiTree;

int CreateBiTree(BiTree *T) 
{
    char ch;
    scanf("%c", &ch);
    getchar(); // Consume the newline character

    if (ch == '#')// Assuming '#' represents empty node
        *T = NULL;
    else {
        *T = (BiTree)malloc(sizeof(BiTNode));// Allocate memory for the new node
        if (!*T)// Check if memory allocation failed
            exit(EXIT_FAILURE);

        (*T)->data = ch;// Set the data of the node

        // Recursively create left and right subtrees
        if (CreateBiTree(&((*T)->lchild)) == ERROR)
            return ERROR;
        if (CreateBiTree(&((*T)->rchild)) == ERROR)
            return ERROR;
    }
    return OK;
}

int Height_BiTree(BiTree T) 
{
    if (!T)//T为空树
        return 0;
    int left_height = Height_BiTree(T->lchild);
    int right_height = Height_BiTree(T->rchild);
    return fmax(left_height, right_height) + 1;
}

int LeafCount_BiTree(BiTree T) 
{
    if (!T)//若T为空树
        return 0;
    if (T->lchild == NULL && T->rchild == NULL)//T为叶子结点 
        return 1;
    return LeafCount_BiTree(T->lchild) + LeafCount_BiTree(T->rchild);
}

void Level_BiTree(BiTree T, int level) 
{
    if (T) {//T不为空树 
        printf("%c at level %d\n", T->data, level);
        Level_BiTree(T->lchild, level + 1);//求左子树的节点层数 
        Level_BiTree(T->rchild, level + 1);//求右子树的节点层数 
    }
}

void Visit(char data) 
{
    printf("%c ", data);
}

int found = 0;//全局变量，或作参数传递
void Decendents(BiTree T,char e)
{
	if(!T)	return ;//遇空树，直接返回 
	if(T->data == e)	found = 1;//先序遍历时找到e,置“找到”标记 
    if(found)	Visit(T->data);//访问该结点，如打印 
	//if(found)	printf("%c ",T->data);//访问该结点，如打印 
	Decendents(T->lchild, e);//递归地在左子树中搜索 
	Decendents(T->rchild, e);//递归地在右子树中搜索 
	if(T->data == e)	found = 0;//后序遍历时找到e,置“退出”以e为根的子树标记 
 }

void InOrderTraversal(BiTree T) 
{
    if (T) {
        InOrderTraversal(T->lchild);
        printf("%c ", T->data);
        InOrderTraversal(T->rchild);
    }
}

void PreOrderTraversal(BiTree T) 
{
    if (T) {
        printf("%c ", T->data);
        PreOrderTraversal(T->lchild);
        PreOrderTraversal(T->rchild);
    }
}

void PostOrderTraversal(BiTree T) 
{
    if (T) {
        PostOrderTraversal(T->lchild);
        PostOrderTraversal(T->rchild);
        printf("%c ", T->data);
    }
}

void DestroyBiTree(BiTree *T) 
{
    if (*T) 
    {
        DestroyBiTree(&((*T)->lchild));
        DestroyBiTree(&((*T)->rchild));
        free(*T);
        *T = NULL;
    }
}

int main() {
    BiTree T = NULL;
    printf("Enter the binary tree (use '#' for empty nodes):\n");
    if (CreateBiTree(&T) == OK) 
    {
        printf("Binary tree created successfully!\n");

        printf("Inorder traversal: ");
        InOrderTraversal(T);
        printf("\n");

        printf("Preorder traversal: ");
        PreOrderTraversal(T);
        printf("\n");

        printf("Postorder traversal: ");
        PostOrderTraversal(T);
        printf("\n");

        printf("Height of the binary tree: %d\n", Height_BiTree(T));
        printf("Number of leaf nodes: %d\n", LeafCount_BiTree(T));

        printf("Nodes at different levels:\n");
        Level_BiTree(T, 1);

        char node_to_find;
        printf("Enter a node to find its descendants: ");
        scanf(" %c", &node_to_find);
        Decendents(T, node_to_find);
        printf("\n");
    } 
    else 
    {
        printf("Failed to create binary tree.\n");
    }

    DestroyBiTree(&T);
    return 0;
}

```



###### 二叉链表的第二种创建方法：

```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef char DataType;

// Define the structure of a binary tree node
typedef struct TreeNode 
{
    DataType data;
    struct TreeNode *lchild;
    struct TreeNode *rchild;
} LinkBiTree;

// Function to perform postorder traversal and print the binary tree
void PostOrderTraverse(LinkBiTree* T) 
{
    if (T) 
	{
        PostOrderTraverse(T->lchild); // Traverse left subtree
        PostOrderTraverse(T->rchild); // Traverse right subtree
        printf("%c ", T->data);       // Print root
    }
}

// Function to create a binary tree from given preorder and inorder sequences
void CreateBiTree(LinkBiTree **T, char *PreStr, char *InStr, int L1, int R1, int L2, int R2) 
{
    if (L1 > R1 || L2 > R2) // Base case: empty subtree
        *T = NULL;
    else 
	{
        (*T) = (LinkBiTree *)malloc(sizeof(LinkBiTree)); // Allocate memory for the new node
        if (!(*T))    exit(OVERFLOW);

        (*T)->data = PreStr[L1]; // Set the data of the node

        int root;
        for (root = L2; root <= R2; root++) 
		{
            if (InStr[root] == PreStr[L1])     break;
        }
        printf("Root node '%c' is at index %d in the inorder sequence.\n", PreStr[L1], root);
        
        if (root - L2 != 0) // If there are left children
            CreateBiTree(&(*T)->lchild, PreStr, InStr, L1 + 1, L1 + root - L2, L2, root - 1);
        else
            (*T)->lchild = NULL;

        if (R2 - root != 0) // If there are right children
            CreateBiTree(&(*T)->rchild, PreStr, InStr, R1 - R2 + root + 1, R1, root + 1, R2);
        else
            (*T)->rchild = NULL;
    }
}

int main() {
    char PreStr[30], InStr[30];
    printf("Enter the preorder sequence: ");
    scanf("%s", PreStr);
    printf("Enter the inorder sequence: ");
    scanf("%s", InStr);

    int len1 = strlen(PreStr);
    int len2 = strlen(InStr);

    LinkBiTree *T = NULL;
    CreateBiTree(&T, PreStr, InStr, 0, len1 - 1, 0, len2 - 1);

    printf("Postorder traversal of the binary tree: ");
    PostOrderTraverse(T);
    printf("\n");

    return 0;
}
```



#### 1. 二叉树基本操作



```c
#include <stdio.h>

#include <string.h>

#include<malloc.h>

typedef struct node         //二叉树结点类型的定义

{

    char data;

    struct node *lchild;      //定义结点的左孩子指针

    struct node *rchild;      //定义结点的右孩子指针

} BinTNode;


BinTNode *CreateBinTree()  //输入二叉树的先序遍历序列，创建二叉链表

{

    BinTNode *t;

    char ch;

    ch = getchar();

    if (ch == '0')             //如果读入0，创建空树

        t = NULL;

    else
    {
		t = (BinTNode*)malloc(sizeof(BinTNode));
		//if(!t)	exit(-1);
		t->data = ch;
		t->lchild = CreateBinTree();
		t->rchild = CreateBinTree(); 

    }


    return t;

}


void ListBinTree(BinTNode *t)                  //用广义表表示二叉树

{

    if (t != NULL)
    {

        printf("%c", t->data);                //打印数据

        if (t->lchild != NULL || t->rchild != NULL)
        {

            printf("(");                      //打印广义表的左括号

            ListBinTree(t->lchild);           //用广义表表示左子树

            if (t->rchild != NULL)

                printf(",");                    //打印左子树和右子树之间的逗号

            ListBinTree(t->rchild);         //用广义表表示右子树

            printf(")");                    //打印广义表的右括号

        }

    }

}


void preorder(BinTNode *t)   //对二叉树进行先序遍历  注意: 课件中的Visit(T->data)在此

//处是 printf("%3c",t->data),下同。

{


 	if(t)
	{
		printf("%3c",t->data);
		preorder(t->lchild);
		preorder(t->rchild);
	}



}


void inorder(BinTNode *t) //对二叉树进行中序遍历

{
	if(t)
	{
		inorder(t->lchild);
		printf("%3c",t->data);
		inorder(t->rchild);
	}

}


void postorder(BinTNode *t) //对二叉树进行后序遍历

{
	if(t)
	{
		postorder(t->lchild);
		postorder(t->rchild);
		printf("%3c",t->data);
	}



}


int Height(BinTNode *t)//节点深度

{
    if(!t)	return 0;
    return (Height(t->lchild) > Height(t->rchild) ? Height(t->lchild) : Height(t->rchild)) + 1;


}





//二叉树的总结点数

int Size(BinTNode *t)
{


    if(!t)	return 0;
	return 1 + Size(t->lchild) + Size(t->rchild);


}



//二叉树的叶子结点数

int Leaf(BinTNode *t)
{

	if(!t)	return 0;
	if(t->lchild == NULL && NULL == t->rchild)	return 1;
	return 	Leaf(t->lchild) + Leaf(t->rchild);
    

}



//二叉树的最大值

int Max(BinTNode *t)
{

    if (t == NULL) return 0;

    if (t->lchild == NULL && t->rchild == NULL)

        return t->data;

    int l = Max(t->lchild);

    int r = Max(t->rchild);

    return l > r ? l : r;

}


int main()
{

    BinTNode *t = NULL;

    //int TreeHeight;

    printf("请输入先序序列,虚结点用0表示：\n");

    t = CreateBinTree();

    printf("广义表表示的二叉树的输出：\n");

    ListBinTree(t);                          //调用二叉树的广义表表示函数

    printf("\n二叉树的前序遍历结果为:\n");

    preorder(t);                             //调用二叉树先序遍历函数

    printf("\n二叉树的中序遍历结果为:\n");

    inorder(t);                              //调用二叉树中序遍历函数

    printf("\n二叉树的后序遍历结果为:\n");

    postorder(t);                            //调用二叉树后序遍历函数

    printf("\n");

    printf("二叉树的高度为：%d\n", Height(t));

    printf("二叉树的总结点数为：%d\n", Size(t));

    printf("二叉树的叶子结点数为：%d\n", Leaf(t));

    printf("二叉树的最大值为：%c\n", Max(t));
    
    return 0;

}
```



#### 2. 二叉树的遍历与应用

```c
#include <stdio.h>

#include <malloc.h>

#include <stdlib.h>

#define OVERFLOW 0

#define OK 1

typedef struct node         //二叉树结点类型的定义

{

    char data;

    struct node *lchild; //定义结点的左孩子指针

    struct node *rchild; //定义结点的右孩子指针

} BinTNode, *BTNode;


BinTNode *CreateBinTree()  //输入二叉树的先序遍历序列，创建二叉链表

{

    BinTNode *t;

    char ch;

    ch = getchar();

    if (ch == '0')             //如果读入0，创建空树

        t = NULL;

    else
    {

        t = (BinTNode *) malloc(sizeof(BinTNode)); //申请根结点*t空间

        if (!t) exit(OVERFLOW);

        t->data = ch;                                  //将结点数据ch放入跟结点的数据域

        t->lchild = CreateBinTree();                        //建左子树

        t->rchild = CreateBinTree();                        //建右子树

    }

    return t;

}


void preorder(BTNode t)   //对二叉树进行先序遍历。提示：打印采用 %3c

{

    if (t != NULL)
    {

        printf("%3c", t->data);  //打印节点数据

        preorder(t->lchild);   //先序遍历左子树

        preorder(t->rchild);   //先序遍历右子树

    }

}


void inorder(BTNode t) //对二叉树进行中序遍历。提示：打印采用 %3c

{

    //★★★请补全代码
    if (t != NULL)
    {

        inorder(t->lchild);   //先序遍历左子树 
        
        printf("%3c", t->data);  //打印节点数据

        inorder(t->rchild);   //先序遍历右子树

    }

}

//二叉树的叶子结点数

int Leaf(BTNode t)
{

    //★★★请补全代码
    if(!t)	return 0;
    if(t->lchild == NULL && NULL == t->rchild)		return 1;
	return Leaf(t->lchild) + Leaf(t->rchild);
}



//二叉树的最大值

int Max(BTNode t)
{

    //★★★请补全代码
    if(!t)	return 0;
    if(t->lchild == NULL && NULL == t->rchild)	return t->data;
    return Max(t->lchild) > Max(t->rchild) ? Max(t->lchild) : Max(t->rchild);

}


    int main()
    {

        BTNode t = NULL;

        //int TreeHeight;

        t = CreateBinTree();

        preorder(t);                             //调用二叉树先序遍历函数

        printf("\n");

        inorder(t);                              //调用二叉树中序遍历函数

        printf("\n");

        printf("%d\n", Leaf(t));

        printf("%c\n", Max(t));


    }
```



#### 3.打印二叉树中的所有从根结点到叶子结点的路径

```c
#include<stdio.h>
#include<malloc.h>

#define OK 1
#define ERROR 0

typedef int TElemType;
typedef int Status;

typedef struct Tnode{
    TElemType data;
    struct Tnode *leftchild;
    struct Tnode *rightchild;
}TNode, *BiTree;  

// 根据先序扩展序列构建二叉链表
// a[]为先序扩展序列数组，n为数组长度
Status CreateBiTree1(BiTree *T, char a[], int n)
{
    static int count = 0; // 静态变量，用于记录当前处理的序列下标
    if(count >= n) return ERROR; // 若序列已处理完毕，则返回ERROR
    if(a[count] == '#') // 若当前结点为空
    {
        *T = NULL;
        count++; // 继续处理下一个结点
    }
    else
    {
        *T = (BiTree)malloc(sizeof(TNode)); // 创建新结点
        (*T)->data = a[count++]; // 读取结点的值
        CreateBiTree1(&((*T)->leftchild), a, n); // 递归构建左子树
        CreateBiTree1(&((*T)->rightchild), a, n); // 递归构建右子树
    }
    return OK;
} 

// 打印二叉树
void PrintBiTree(BiTree T)
{
    if(T)
    {
        printf("%c", T->data); // 打印当前结点的值
        PrintBiTree(T->leftchild); // 递归打印左子树
        PrintBiTree(T->rightchild); // 递归打印右子树
    }
}

// 辅助函数：打印路径
void printPath(char path[], int pathLen)
{
    //不能改成path[i]; 或 path[i] != '\0';
    //因为该路径未必能够覆盖之前路径，则path末尾不一定是'\n'
    for(int i = 0; i < pathLen; ++i)
        printf("%c", path[i]); // 打印路径
    printf("\n");
}

// 打印从根结点到叶子结点的所有路径
void printAllPaths(BiTree T, char path[], int pathLen)
{
    if(T == NULL) return; // 若当前结点为空，则直接返回

    path[pathLen++] = T->data; // 将当前结点的值加入路径
    if(T->leftchild == NULL && T->rightchild == NULL) // 若当前结点为叶子结点
    {
        printPath(path, pathLen); // 打印当前路径
        //pathlen传进去是为了区分之前的路径，因为现在新的路径未必能够覆盖之前的路径
        //如若不传进去，则会出现本路径末尾还有结点打印
    }
    else // 若当前结点不是叶子结点，则继续向下递归
    {
        printAllPaths(T->leftchild, path, pathLen); // 递归遍历左子树
        printAllPaths(T->rightchild, path, pathLen); // 递归遍历右子树
    }
}

int main()
{
    char arr[1000], ch;
    int len = 0;
    
//	while(scanf("%c",&arr[len]) != EOF)
//	{
//		if(arr[len] == '\n') // 若输入换行符，则结束循环
//            break;
//        len ++;      
//	}
//这样也行，但会警告，还是下面一种更为稳妥
    
    while((ch = getchar()) != EOF)
    {
        if(ch == '\n') // 若输入换行符，则结束循环
            break;
        arr[len++] = ch;
    }

    BiTree T = NULL;
    CreateBiTree1(&T, arr, len);

    char path[1000]; // 存储当前路径
    int pathLen = 0; // 当前路径长度
    printAllPaths(T, path, pathLen);

    return 0;
}

```



#### 4NR010:求任意二叉树最长路径

```c
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef struct TNode
{
	char data;
	struct TNode *lchild;
	struct TNode *rchild;
}TNode, *BiTree;

void CreateBiTree(BiTree *T)
{
	char ch;
	ch = getchar();//压根没有换行，可以用putchar(ch)试一下 ，最后会自动递归终止 
	//if(ch == '\n')	return;
	if(ch == '0')	*T = NULL;
	else
	{
		*T = (BiTree)malloc(sizeof(TNode));
		(*T)->data = ch;
		CreateBiTree(&(*T)->lchild);
		CreateBiTree(&(*T)->rchild);
	}
}

int Max(int a, int b)
{
	return a > b ? a : b;
}

int Height_BiTree(BiTree T)
{
	if(!T)	return 0;
	return Max(Height_BiTree(T->lchild), Height_BiTree(T->rchild))+ 1;
	
}

void PrintBiTree(BiTree T)
{
    if(T)
    {    
        PrintBiTree(T->lchild); // 递归打印左子树
        printf("%c", T->data); // 打印当前结点的值
        PrintBiTree(T->rchild); // 递归打印右子树
    }
}

void PrintPath(char *Path, int Pathlen)
{
	int i = 0;
	//printf("%d",Pathlen); 
	for(i = 0;i < Pathlen;i ++)
	{
		printf("%c->",Path[i]);
	}
	printf("NULL");
}


void printLongestPath(BiTree T,char* path, int pathlen, int count)
{
	if(!T)	return ;
	path[count ++] = T->data;
	if(T->lchild == NULL && NULL == T->rchild && count == pathlen)
	{
		PrintPath(path,pathlen);
		exit(1);
	}
	else
	{
		printLongestPath(T->lchild, path, pathlen, count);
		printLongestPath(T->rchild, path, pathlen, count);
	}
}

void Destroy_BiTree(BiTree *T)
{
	if(*T)
	{
		Destroy_BiTree(&(*T)->lchild);
		Destroy_BiTree(&(*T)->rchild);
		free(*T);
		*T = NULL;
	}
}

int main()
{
	BiTree T;
	
	CreateBiTree(&T);
	
	int pathlen = Height_BiTree(T);
	
	char path[1000];
	
	printLongestPath(T, path, pathlen, 0);
	
	Destroy_BiTree(&T);
	
	return 0;
}
```



```c
//AI错得离谱
#include <stdio.h>
#include <stdlib.h>

// 定义树节点结构体
typedef struct TreeNode {
    char val;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;

// 创建树节点
TreeNode* createNode(char val) {
    TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
    newNode->val = val;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// 从先序序列构建二叉树
TreeNode* buildTreeFromPreorder(char* preorder) {
    if (!preorder || *preorder == '\0') {
        return NULL;
    }
    TreeNode* root = createNode(*preorder++);
    if (*preorder == '0') {
        preorder++;
    } else {
        root->left = buildTreeFromPreorder(preorder);
        root->right = buildTreeFromPreorder(preorder);
    }
    return root;
}

// 深度优先搜索查找最长路径
void findLongestPath(TreeNode* root, char* path, char** longestPath, int* maxLength, int length) {
    if (!root) {
        if (length > *maxLength) {
            *maxLength = length;
            *longestPath = path;
        }
        return;
    }
    path[length++] = root->val;
    path[length] = '\0';
    findLongestPath(root->left, path, longestPath, maxLength, length);
    findLongestPath(root->right, path, longestPath, maxLength, length);
}

// 打印路径
void printPath(char* path) {
    while (*path != '\0') {
        printf("%c -> ", *path++);
    }
    printf("NULL\n");
}

int main() {
    char preorder[] = "ABD00E00CFG0000";
    TreeNode* root = buildTreeFromPreorder(preorder);

    // 初始化路径变量
    char path[100] = "";
    char* longestPath = NULL;
    int maxLength = 0;

    // 查找最长路径
    findLongestPath(root, path, &longestPath, &maxLength, 0);

    // 打印最长路径
    printPath(longestPath);

    // 释放内存
    free(root);

    return 0;
}

```

