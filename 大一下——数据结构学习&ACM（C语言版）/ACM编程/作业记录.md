### 作业1——C语言复习

#### 1. ACM2024-第一章-C语言回顾-结构体2

#### 2. ACM2024-第一章-C语言回顾-结构体2

#### 3. ACM2024-第一章-C语言回顾-结构体1

#### 4. ACM2024-第一章-C语言回顾-数组最大值

#### 5. ACM2024-第一章-C语言回顾-数组1



### 作业2——顺序表

#### 1. ACM2023-第二章-线性表-交叉合并两个顺序表- LJD



```c
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0
#define MAXSIZE 20

typedef int Status;
typedef int ElemType;

typedef struct {
    ElemType data[MAXSIZE];
    int length;
} SqList;

// 遍历顺序表并打印元素
void TraverseList(SqList L) 
{
    for (int i = 0; i < L.length; i++) 
    {
        printf("%d ", L.data[i]);
    }
    printf("\n");
}

// 获取顺序表的长度
int GetListLength(SqList L) 
{
    return L.length;
}

// 获取指定位置的元素值
Status GetElemAt(SqList L, int i, ElemType *e) 
{
    if (i < 1 || i > L.length)
        return ERROR;
    *e = L.data[i - 1];
    return OK;
}

// 在指定位置插入元素
Status InsertIntoList(SqList *L, int i, ElemType e) 
{
    if (L->length >= MAXSIZE || i < 0 || i > L->length)
        return ERROR;
    for (int k = L->length - 1; k >= i; k--) 
    {
        L->data[k + 1] = L->data[k];
    }
    L->data[i] = e;
    L->length++;
    return OK;
}

// 将两个顺序表的元素交错到第三个顺序表中
void InterleaveLists(SqList *L3, SqList L1, SqList L2) 
{
    int i = 1;
    int e;
    while (i <= L1.length || i <= L2.length) 
    {
        int tag = i;//作为判断标志	是否已经插了L1	矫正i 的值
        if (i <= L1.length) 
        {
            GetElemAt(L1, i, &e);
            InsertIntoList(L3, L3->length, e);
            i++;
        }
        if (i - 1 <= L2.length) 
        {
            if (tag != i) i--;
            GetElemAt(L2, i, &e);
            InsertIntoList(L3, L3->length, e);
            i++;
        }
    }
}

int main() 
{
    SqList L1, L2, L3;
    Status i;
    int j, k, l;

    // 输入并创建第一个顺序表
    scanf("%d", &k);
    L1.length = 0;
    if (k > 0)
        for (j = 1; j <= k; j++) 
        {
            scanf("%d", &l);
            i = InsertIntoList(&L1, 0, l);
        }

    // 打印第一个顺序表及其长度
    TraverseList(L1);
    printf("%d \n", GetListLength(L1));

    // 输入并创建第二个顺序表
    scanf("%d", &k);
    L2.length = 0;
    if (k > 0)
        for (j = 1; j <= k; j++) 
        {
            scanf("%d", &l);
            i = InsertIntoList(&L2, 0, l);
        }

    // 打印第二个顺序表及其长度
    TraverseList(L2);
    printf("%d \n", GetListLength(L2));

    // 将两个顺序表的元素交错到第三个顺序表中
    L3.length = 0;
    InterleaveLists(&L3, L1, L2);

    // 打印交错后的顺序表及其长度
    TraverseList(L3);
    printf("%d \n", GetListLength(L3));

    return OK;
}

```



#### 2. ACM2023-第二章-线性表-顺序表的各种操作练习- LJD



```c
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE 0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
typedef int ElemType;

#define INIT_SIZE 100       // 初始分配空间的大小
#define LISTINCREMENT 10    // 分配增量

typedef struct {
    ElemType *elem;         // 存储空间的起始地址
    int length;             // 线性表中数据元素个数，即表长
    int listsize;           // 线性表所申请的存储空间的大小
} SqList;

// 创建一个空的线性表
SqList CreateList_Sq(SqList L)
{
    L.elem = (ElemType*)malloc(100 * sizeof(ElemType));  // 申请空间
    L.length = 0;         // 表长为0
    L.listsize = 100;     // 申请的空间为初始大小
    return L;
}

// 在线性表的第i个位置前插入元素e
void InsertList_Sq(SqList *L, int i, ElemType e)
{
    int *newbase, *q, *p;
    if ((i < 1) || (i > L->length + 1)) 
    {
        printf("i值不合法!\n");
        exit(ERROR);
    }
    // 当前空间已满，增加分配空间
    if (L->length >= L->listsize) 
    {   
        newbase = (ElemType*)realloc(L->elem, (L->listsize + LISTINCREMENT) * sizeof(ElemType));
        if (!newbase) exit(ERROR);
        L->elem = newbase;
        L->listsize = L->listsize + LISTINCREMENT;
    }
    //检查完错误	开始插值
    int j;
    for (j = L->length - 1; j >= i - 1; j--) 
    {
        L->elem[j + 1] = L->elem[j]; // 将元素后移
    }
    L->elem[i - 1] = e;
    L->length++;//插完后	莫忘更新线性表的长度
    return OK;
}

// 删除线性表中的第i个元素
void DeleteList_Sq(SqList *L, int i)
{
    int j;
    if ((i < 1) || (i > L->length)) {
        printf("i值不合法!\n");
        exit(ERROR);
    }
    for (j = i; j < L->length; j++) {
        L->elem[j - 1] = L->elem[j];
    }
    L->length--;
}

// 遍历顺序线性表并输出
void Print_Sq(SqList L)
{
    int i;
    for (i = 0; i < L.length; i++) {
        printf("%3d ", L.elem[i]);
    }
}

// 判两个元素是否相等
int equal(ElemType e1, ElemType e2)
{
    if (e1 == e2) return 1;
    else return 0;
}

// 查找元素在顺序表中的位置
int LocateElem_Sq(SqList L, ElemType e, int (* compare)(ElemType e1, ElemType e2))
{
    int i = 0;
    for (; i < L.length; i++) {
        if (compare(L.elem[i], e)) return i + 1;
    }
    return ERROR;
}

void Getelem(SqList L, int i, ElemType *e)
{
    if (i < 1 || i > L.length) return;
    *e = L.elem[i - 1];
    return;
}

int main()
{
    int i;
    ElemType e;
    SqList Lq;
    Lq = CreateList_Sq(Lq);
    InsertList_Sq(&Lq, 1, 21);
    InsertList_Sq(&Lq, 2, 18);
    InsertList_Sq(&Lq, 3, 30);
    InsertList_Sq(&Lq, 4, 75);
    InsertList_Sq(&Lq, 5, 42);
    InsertList_Sq(&Lq, 6, 56);
    printf("初始顺序表为\n");
    Print_Sq(Lq);
    InsertList_Sq(&Lq, 3, 67);
    printf("\n插入67后顺序表为\n");
    Print_Sq(Lq);
    DeleteList_Sq(&Lq, 6);
    printf("\n删除第6个元素后顺序表为\n");
    Print_Sq(Lq);
    if ((i = LocateElem_Sq(Lq, 75, equal)))
        printf("\n存在元素75且位置为%d\n", i);
    else
        printf("\n不存在元素75\n");
    free(Lq.elem);
    return 1;
}

```



#### 3. ACM2023-第二章-顺序表练习题 -合并两有序表 - LJD



```c
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE 0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10
typedef int ElemType;

typedef struct {
    ElemType *elem;
    int length;
    int listsize;
} SqList;

// Create an empty list
Status InitList_Sq(SqList *L)
{
    //学生添加
    L->elem = (int*)malloc(INIT_SIZE*sizeof(int));
    if (!L->elem) return OVERFLOW;
    L->length = 0;
    L->listsize = INIT_SIZE; 
}

// Create an array based list with n elements
Status CreateList_Sq(SqList *L, int a[], int n)
{
    //学生添加
    int j = 0;
    for(; j < n; j++)
    {
        L->elem[j] = a[j];
    }
    L->length = n;
}

// Get Element
Status GetElem(SqList L, int i, int *e)
{
    //学生添加
    if(i < 1 || i > L.length) return ERROR;
    *e = L.elem[i - 1];
    return OK;
}

// Insert
Status ListInsert(SqList *L, int i, int e)
{
    //学生添加
    if(i < 1 || i > L->length + 1) return ERROR;
    if(L->length == L->listsize) return ERROR;
    int j = L->length - 1;
    for(; j >= i - 1; j--)
    {
        L->elem[j + 1] = L->elem[j];
    }
    L->elem[i - 1] = e;
    L->length++;
    return OK;
}

// Merge two sequential lists 
Status MergeList_Sq(SqList L1, SqList L2, SqList *L3)
{  
    //学生添加
    int i = 0, j = 0, k = 0;
    
    
    while(i < L1.length && j < L2.length)
    {
        if(L1.elem[i] <= L2.elem[j])
        {
            L3->elem[k++] = L1.elem[i++];
        }
        else
        {
            L3->elem[k++] = L2.elem[j++];
        }
    }
    while(i < L1.length)
    {
        L3->elem[k++] = L1.elem[i++];
    }
    while(j < L2.length)
    {
        L3->elem[k++] = L2.elem[j++];
    }
    L3->length = k;
    
    
    //上面的三个while循环逻辑更加清晰	
    //下面一个看着很复杂
    //while (L3->length < L1.length + L2.length)
    //{
    //	if (len1 < L1.length && (L1.elem[len1] <= L2.elem[len2] || len2 >= L2.length))
    //	{
    //		L3->elem[len3++] = L1.elem[len1++];
    //		L3->length++;
    //	}
    //	else if (len2 < L2.length && (L2.elem[len2] < L1.elem[len1] || len1 >= L1.length))
    //	{
    //		L3->elem[len3++] = L2.elem[len2++];
    //		L3->length++;
    //	}
    //}
    
}

// Print out all elements
void PrintList_Sq(SqList L)
{ 
    //学生添加
    int j = 0;
    for(; j < L.length; j++)
    {
        printf("%d ", L.elem[j]);
    }
}

int main()
{
    int n1, n2, i, j;
    int a[20], b[20];
    SqList L1, L2, L3;

    scanf("%d", &n1);
    for(i = 0; i < n1; i++)
    {
        scanf("%d", &a[i]);
    }
    scanf("%d", &n2);
    for(i = 0; i < n2; i++)
    {
        scanf("%d", &b[i]);
    }

    InitList_Sq(&L1);
    InitList_Sq(&L2);
    InitList_Sq(&L3);

    CreateList_Sq(&L1, a, n1);
    CreateList_Sq(&L2, b, n2);

    MergeList_Sq(L1, L2, &L3);

    PrintList_Sq(L3);

    return 0;
}

```



#### 4. ACM2023-第二章-顺序表练习题 -删除顺序表指定位置n后的m个元素 - LJD



```C
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE  0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10  
typedef int ElemType;

typedef struct
{
    ElemType *elem;
    int length;
    int listsize;
}SqList;

// Initialize an empty list
Status InitList_Sq(SqList *L)
{
 //学生添加
 	L->elem = (int*)malloc(INIT_SIZE * sizeof(int));
    if (!L->elem) return OVERFLOW;
 	L->length = 0;
 	L->listsize = INIT_SIZE;
}
//Create an array based list with n elements
Status CreateList_Sq(SqList *L, int a[], int n)
{
 //学生添加
	int i = 0;
	for(;i < n;i ++)
	{
		L->elem[i] = a[i]; 
	}
	L->length = n;
    return OK;
}

// Delete the ith elements of sequential list L
Status DeleteList_Sq(SqList *L, int m,int k)
{    
 //学生添加
       if (m < 0 || m > L->length || k < 0)
        return ERROR;
 	int i = 0; 	
 	for(;m < L->length - k;m ++)
 	{
 		L->elem[m] = L->elem[m + k];
	 }
	 L->length -=k;
}

//print out all elements
void PrintList_Sq(SqList L)
{ 
 //学生添加
	 int i = 0;
	 for(;i < L.length;i ++)
	 {
	 	printf("%d ",L.elem[i]); 
	 }
}

int main()
{ 
	int n;
	scanf("%d",&n);
	int i,arr[n];
	for(i = 0;i < n;i ++)
	{
		scanf("%d",&arr[i]);
	 }
    
	 SqList sq;
	 InitList_Sq(&sq);	 
	 CreateList_Sq(&sq,arr,n);
	 
	 int m,k; 
	 scanf("%d%d",&m,&k);
	 
	 DeleteList_Sq(&sq,m,k);
	 
	 PrintList_Sq(sq);	 
	 return 0;
}

```



#### 5. ACM2023-第二章-顺序表练习题 -就地逆置顺序表 - LJD



```c
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE  0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10  
typedef int ElemType;

typedef struct {
    ElemType *elem;
    int length;
    int listsize;
} SqList;

// Create an empty list
Status InitList_Sq(SqList *L)
{
    //学生添加
    L->elem = (int*)malloc(INIT_SIZE * sizeof(int));
    L->length = 0;
    L->listsize = INIT_SIZE;
}

// Create an array based list with n elements
Status CreateList_Sq(SqList *L, int a[], int n)
{
    //学生添加
    int i = 0;
    for(; i < n; i++)
    {
        L->elem[i] = a[i];
    }
    L->length = n;
}

// Reverse the elements of sequential list L
void swap(int *a, int *b)
{
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;	
}

Status ReverseList_Sq(SqList *L)
{    
    //学生添加
    int i = 0;
    for(; i < L->length / 2; i++)
    {
        swap(&L->elem[i], &L->elem[L->length - i - 1]); 
    }
    return OK;
}

// print out all elements
void PrintList_Sq(SqList L)
{ 
    //学生添加
    int i = 0;
    for(; i < L.length; i++)
    {
        printf("%d ", L.elem[i]);
    }
}

int main()
{ 
    //学生添加
    int n;
    scanf("%d", &n);
    int arr[n];
    int i = 0;
    for(; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }
    SqList sq;
    InitList_Sq(&sq);
    CreateList_Sq(&sq, arr, n);
    ReverseList_Sq(&sq);
    PrintList_Sq(sq);
    return 0;
}

```



#### 6. ACM2023-第二章-顺序表练习题 -顺序表排序 - LJD



```C
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE 0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10  
typedef int ElemType;

typedef struct{
    ElemType *elem;
    int length;
    int listsize;
} SqList;

// Create an empty list
Status InitList_Sq(SqList *L)
{
    //学生添加
    L->elem = (int*)malloc(INIT_SIZE*sizeof(int));
    L->length = 0;
    L->listsize = INIT_SIZE;
}

// Create an array based list with n elements
Status CreateList_Sq(SqList *L, int a[], int n)
{
    //学生添加
    int i = 0;
    for(; i < n; i++)
    {
        L->elem[i] = a[i];
    }
    L->length = n;
}

// Sort the elements of sequential list L into ascending order
Status SortList_Sq(SqList *L)
{    
    //学生添加
    int i = 0, j = 0;
    for(; i < L->length - 1; i++)
    {
        for(j = 0; j < L->length - i - 1; j++)
        {
            if(L->elem[j] > L->elem[j + 1])
            {
                int temp = L->elem[j];
                L->elem[j] = L->elem[j + 1];
                L->elem[j + 1] = temp;
            }
        }
    }
}

// Print out all elements
void PrintList_Sq(SqList L)
{ 
    //学生添加
    int i = 0;
    for(; i < L.length; i++)
    {
        printf("%d ", L.elem[i]);
    }
}

int main()
{ 
    //学生添加
    int n;
    scanf("%d", &n);
    int i = 0, arr[n];
    for(; i < n; i++)
    {
        scanf("%d", &arr[i]);
    } 
    SqList sq;
    InitList_Sq(&sq);
    CreateList_Sq(&sq, arr, n);
    SortList_Sq(&sq);
    PrintList_Sq(sq);
    return 0;
}

```



#### 7. ACM2023-第二章-顺序表练习题 -在顺序表的指定位置插入指定元素 -LJD

```c
#include <stdio.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10  
typedef int ElemType;

typedef struct {
    ElemType *elem;
    int length;
    int listsize;
} SqList;

// 创建一个空的顺序表
Status InitList_Sq(SqList *L) 
{
    L->elem = (int *)malloc(INIT_SIZE * sizeof(int));
    if (!L->elem) 
    {
        printf("Memory allocation failed.\n");
        return OVERFLOW;
    }
    L->length = 0;
    L->listsize = INIT_SIZE;
    return OK;
}

// 创建一个带有 n 个元素的数组列表
Status CreateList_Sq(SqList *L, int a[], int n) 
{
    if (n > INIT_SIZE) 
    {
        printf("The number of elements exceeds the initial size.\n");
        return ERROR;
    }
    int i;
    for (i = 0; i < n; i++) 
    {
        InsertList_Sq(L, i + 1, a[i]);
    }
    return OK;
}

// 在顺序表 L 的特定位置插入元素
Status InsertList_Sq(SqList *L, int i, ElemType e) 
{    
    if (i < 1 || i > L->length + 1) 
    {
        printf("Invalid position.\n");
        return ERROR;
    }
    if (L->length >= L->listsize) 
    {
        printf("The list is full. No more space to insert.\n");
        return OVERFLOW; // 检查是否需要扩展顺序表的空间
    }
    int j;
    for (j = L->length - 1; j >= i - 1; j--) 
    {
        L->elem[j + 1] = L->elem[j]; // 将元素后移
    }
    L->elem[i - 1] = e;
    L->length++;
    return OK;
}

// 打印所有元素
void PrintList_Sq(SqList L) 
{
    int i;
    for (i = 0; i < L.length; i++) 
    {
        printf("%d ", L.elem[i]); 
    }
    printf("\n");
}

int main() 
{
    int n, e, k;
   // printf("Enter the number of elements: ");
    scanf("%d", &n);
    if (n <= 0) 
    {
       // printf("Invalid number of elements.\n");
        return ERROR;
    }
    int i, arr[n];
    //printf("Enter the elements: ");
    for (i = 0; i < n; i++) 
    {
        scanf("%d", &arr[i]);
    }
    SqList sq;
    if (InitList_Sq(&sq) != OK) 
    {
        return ERROR;
    }
    if (CreateList_Sq(&sq, arr, n) != OK) 
    {
        return ERROR;
    }
    //printf("Enter the element and the position to insert: ");
    scanf("%d%d", &e, &k);
    if (InsertList_Sq(&sq, k, e) != OK) 
    {
        return ERROR;
    }
    //printf("The list after insertion: ");
    PrintList_Sq(sq);
    return 0;
}

```

### 作业3——链表



#### 单链表学习代码：

```c
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0

typedef int ElemType;
typedef int Status;

typedef struct LNode
{
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// Initialize a linked list
Status InitList(LinkList *L)
{
    *L = (LinkList)malloc(sizeof(LNode));
    if (!(*L)) return ERROR;
    (*L)->next = NULL;
    return OK;
}

// Get the value at a given position
Status GetElem(LinkList L, int i, ElemType *e)
{
    LNode *p = L->next;
    int j = 1;
    while (p && j < i)
    {
        p = p->next;
        ++j;
    }
    if (!p || j > i) return ERROR;
    *e = p->data;
    return OK;
}

// Locate the element with a given value
LinkList LocateElem(LinkList L, ElemType e)
{
    LinkList p = L->next;
    while (p && p->data != e)
    {
        p = p->next;
    }
    return p;
}

// Insert an element at a given position
Status ListInsert(LinkList *L, int i, ElemType e)
{
    LinkList p = *L;
    int j = 0;
    while (p && j < i - 1)
    {
        p = p->next;
        ++j;
    }
    if (!p || j > i - 1) return ERROR;
    LinkList s = (LinkList)malloc(sizeof(LNode));
    if (!s) return ERROR;
    s->data = e;
    s->next = p->next;
    p->next = s;
    return OK;
}

// Delete the element at a given position
Status ListDelete(LinkList L, int i)
{
    LinkList p = L;
    int j = 0;
    while (p->next && j < i - 1)//循环终止后  p指向的第 i - 1个位置的结点
    {
        p = p->next;
        ++j;
    }
    if (!(p->next) || j > i - 1) return ERROR;//前者便是的是此链表最大长度小于 i，没有第i 个结点
    LinkList q = p->next;
    p->next = q->next;//不能直接使用p->next->next，会造成p->next的内存地址无法找到，内存泄漏
    free(q);
    return OK;
}

// Display the elements in the linked list
void DisplayList(LinkList L)
{
    LinkList p = L->next;
    while (p)
    {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}


/*逆序创建链表通常是为了更高效地插入元素。在逆序创建链表时，我们可以直接将新元素插入链表的头部，而不需要遍历整个链表找到尾部再插入。这样做的好处是，每次插入操作的时间复杂度为O(1)，而不是O(n)，因为不需要遍历链表。

如果采用正序创建链表，每次插入元素都需要遍历到链表的尾部，时间复杂度为O(n)，这在插入大量元素时会导致性能下降。*/

// Create a linked list with elements in reverse order
Status InverseCreateList(LinkList L, ElemType a[], int n)
{
    LNode *r = L;
    int i = 0;
    for(; i < n; i++)
    {
        LNode *p ;
        p = (LNode*)malloc(sizeof(LNode));
        p->data = a[n - i - 1]; // Insert elements in reverse order
        p->next = NULL;
        r->next = p; // Insert p into the linked list
        r = p; // Update r to point to p
    }
    return OK;
}

Status CreateList_L(LinkList L, ElemType a[ ], int n)
{
    LNode *r = L;
    int i = 0;
    for(;i < n;i ++)
    {
        LNode *p ;
        p = (LNode*)malloc(sizeof(LNode));//初始化指针，为其分配内存空间，防止出现内存泄漏和未定义行为
        p->data = a[i];//正序时：a[i]   逆序时：a[n - i - 1]
        p->next = NULL;
        r->next = p;//将p插入链表中
        r = p;//更新r的结点，变成指向p的结点
    }
    return OK;
}


//利用头插法对单链表进逆序
void reverse_List(LinkList L)
{
    LNode* p, * q, * r;
    q = L->next;
    p = L->next->next;
    while (p)
    {
        r = p->next;
        p->next = L->next;
        L->next = p;
        //p = p->next;之所以不能这样做，是因为p->next在之前被改了
        //这也是为什么需要额外的一个r来记录p->next
        p = r;
    }
    q->next = NULL;
}

int main()
{
    LinkList L;
    if (InitList(&L) == OK)
    {
        printf("List initialized successfully.\n");

        // Example usage
        ListInsert(&L, 1, 10);
        ListInsert(&L, 2, 20);
        ListInsert(&L, 3, 30);
        printf("Inserted elements: ");
        DisplayList(L);

        ElemType e;
        if (GetElem(L, 2, &e) == OK)
            printf("Element at position 2: %d\n", e);

        LinkList found = LocateElem(L, 20);
        if (found)
            printf("Element 20 found.\n");

        if (ListDelete(L, 2) == OK)
        {
            printf("Deleted element at position 2.\n");
            printf("Current list: ");
            DisplayList(L);
        }

        // Create a linked list with elements in reverse order
        ElemType arr[] = {1, 2, 3, 4, 5};
        if (InverseCreateList(L, arr, 5) == OK)
        {
            printf("Linked list created in reverse order: ");
            DisplayList(L);
        }
    }
    else
    {
        printf("Failed to initialize list.\n");
    }

    return 0;
}

```



#### 1.两个递增有序链表求交集

```c
#include <stdio.h>  
#include <stdlib.h>  

#define ERROR 0
#define OK 1

typedef int ElemType;  
typedef int Status; 

// definition of node structure of singly linked list
typedef struct LNode
{  
    ElemType data;           // data field
    struct LNode *next;      // pointer field
} LNode, *LinkList;

//===========================================
// Initialize a singly linked list L with head node
//===========================================
Status InitList_L(LinkList *L)//在初始化链表时，需要修改链表的头指针，所以需要传入的参数是指针的指针的类型
{
    *L = (LinkList)malloc(sizeof(LNode));
    if (!(*L)) return ERROR;
    (*L)->next = NULL;
    return OK;
}

//===========================================
// Create a singly linked list L with head node, and with n elements
//===========================================
Status CreateList_L(LinkList L, ElemType a[], int n)
{
    LNode *r = L;
    int i = 0;
    for (; i < n; i ++)
    {
        LNode *p = (LNode*)malloc(sizeof(LNode));
        if (!p) return ERROR;
        p->data = a[i];
        p->next = NULL;
        r->next = p;
        r = p;
    }
    return OK; 
}

//======================================
// Insert an element in a list
//=======================================
Status ListInsert_L(LinkList L,int i,ElemType e)
{
	LinkList r = L;
	int j = 0;
	while(r && j < i - 1)
	{
		r = r->next;
		++j;
	}
	if(!r || j > i - 1) return ERROR;
	LinkList s = (LNode*) malloc(sizeof(LNode));
	if(!s) return ERROR;
	s->data = e;
	s->next = r->next;
	r->next = s;
	r = s;
	return OK;
}

//===========================================
// 求两个递增链表La和Lb的交集，得到一个新的链表Lc
//===========================================
Status ListIntersection_L(LinkList La, LinkList Lb, LinkList Lc)
{
    int len_c = 0;
    LNode *ra = La->next;
    LNode *rb = Lb->next;
    LNode *rc = Lc; // 指向 Lc 的头结点
    while (ra && rb)
    {
        if (ra->data > rb->data) rb = rb->next;
        else if (ra->data < rb->data) ra = ra->next;
        else
        {
            ListInsert_L(Lc,++len_c,rb->data);
            //如果不用上面的插入函数，就直接插，
//			LNode *s ;
//			s = (LNode*)malloc(sizeof(LNode));
//			s->data = ra->data;
//			s->next = NULL;
//			rc->next = s;
//			rc = s;
            ra = ra->next;
            rb = rb->next;
        }
    }
    return OK;
}

//===========================================
// Print the elements in a list
//===========================================
void LinkedListPrint(LinkList L)
{
    if (L->next == NULL)//鲁棒性问题，
    {
        return;
    }
    LinkList p = L->next;
    while(p)
    {
        printf("%d ",p->data);
        p = p->next;
    }
    printf("\n");
}

int main()  
{  
    int n, m;
    LinkList La, Lb, Lc;
    //初始化指针，修改了链表的头指针，故要传入指针的指针的类型
    InitList_L(&La);
    InitList_L(&Lb);
    InitList_L(&Lc);
    
    scanf("%d", &n);
    int a[n];
    for (int i = 0; i < n; i++)
        scanf("%d", &a[i]);
    CreateList_L(La, a, n);
    
    scanf("%d", &m);
    int b[m];
    for (int i = 0; i < m; i++)
        scanf("%d", &b[i]);
    CreateList_L(Lb, b, m);

    ListIntersection_L(La, Lb, Lc);

    LinkedListPrint(Lc);
    
    return 0;
}

```



#### 2.将链表的最小值移动到链表的头部

```c
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

#define ERROR 0
#define OK 1

typedef int ElemType;
typedef int Status;

// Definition of a node structure for a singly linked list
typedef struct L_node 
{
    ElemType data;           // Data field
    struct L_node *next;     // Pointer field
} LNode, *LinkedList;

//===========================================
// Initialize a singly linked list L with a head node
//===========================================
Status InitList_L(LinkedList *L)
{
    *L = (LNode*)malloc(sizeof(LNode));
    if (!(*L))     return ERROR;
    (*L)->next = NULL;
    return OK;
}

//===========================================
// Create a singly linked list L with a head node, and with n elements
//===========================================
Status CreateList_L(LinkedList *L, ElemType a[], int n)
{
    if (n <= 0)    return ERROR;
    LNode *r = *L;  // r points to the head node
    int j = 0;
    for (; j < n; j++)
    {
        LNode *p = (LNode*)malloc(sizeof(LNode));  // Create a new node
        if (!p)   return ERROR; 
        p->data = a[j];  // Assign data to the new node
        p->next = NULL;  // Set next pointer to NULL

        r->next = p;     // Link the new node to the list
        r = p;           // Move r to the newly added node
    }
    return OK;
}

//===========================================
// Find the minimum value in an array
//===========================================
int find_Min(int arr[], int n)
{
    int min = arr[0], i = 1;
    for (; i < n; i++)
    {
        if (arr[i] < min)     min = arr[i];
    }
    return min;
}

//===========================================
// Move the node containing the minimum value to the head of the linked list
//===========================================
void MoveMinNode_L(LinkedList L, ElemType minval)
{
    // 如果链表为空或者输入无效，无需操作
    if (!L || !L->next)   return;
        
    // 用于跟踪最小值节点前面的节点
    LNode *prev = NULL;

    // 遍历链表的指针
    LNode *cur = L->next;

    // 寻找包含最小值的节点
    while (cur && cur->data != minval)
    {
        prev = cur;
        cur = cur->next;
    }

    // 如果找不到最小值或者最小值已经在链表头部，无需移动
    if (!cur || cur == L->next)    return;

    // 将包含最小值的节点从当前位置分离出来
    prev->next = cur->next;

    // 将分离的节点插入到链表头部
    cur->next = L->next;
    L->next = cur;
}


//void MoveMinNode_L(LinkedList L, ElemType minval)
//
//{
//	if(!L->next) return;
//	LNode* r = L;
//	while(r && r->next->data != minval)	r = r->next;//找到minval的前一个结点 
	//类似于进行一个删除操作 
//	LNode* p = r->next;
//	r->next = p->next;
// 	free(p);
	//类似进行一个插入操作 
// 	LNode *s = L;
//	LNode*q;
//	q = (LNode*)malloc(sizeof(LNode));
//	q->data = minval;
//	q->next = s->next;
//	s->next = q;
//}


//===========================================
// Print the elements in a linked list
//===========================================
void LinkedListPrint(LinkedList L)
{
    LNode *p = L->next;
    while (p)
    {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}

int main()
{
    int n;
    scanf("%d", &n);

    int arr[n];
    int i; 
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    int min = find_Min(arr, n);
    //printf("Minimum value: %d\n", min);
    printf("%d\n",min);

    LinkedList L;
    if (InitList_L(&L) == ERROR)
    {
        printf("Error: Failed to initialize the list.\n");
        return 1;
    }

    if (CreateList_L(&L, arr, n) == ERROR)
    {
        printf("Error: Failed to create the list.\n");
        return 1;
    }

    MoveMinNode_L(L, min);
    //printf("List after moving the minimum value to the head: ");
    LinkedListPrint(L);

    return 0;
}

```



#### 3. 单链表基本操作与应用



```c
#include <stdio.h>
#include <stdlib.h>

// 定义函数执行结果状态代码
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE 0

// 定义新的函数运行结果类型
typedef int Status;

// 动态单链表的结点结构体定义
typedef int ElemType;
typedef struct LNode 
{
    ElemType data;          // 数据域
    struct LNode* next;     // 指针域
} LNode, *LinkList;

// 初始化链表
Status InitList(LinkList *L) 
{
    int x, i;
    // 创建头结点
    *L = (LinkList)malloc(sizeof(LNode));
    if (*L == NULL) 
    {
        printf("内存分配失败\n");
        return ERROR;
    }
    (*L)->next = NULL;

    // 根据键盘输入构建链表
    LinkList r = *L;
    for (i = 0;; i++) 
    {
        scanf("%d", &x);
        if (x == -1)
            break;
        LinkList p = (LinkList)malloc(sizeof(LNode));
        if (!p) 
        {
            printf("初始化失败\n");
            return ERROR;
        }
        p->data = x;
        p->next = NULL;
        r->next = p;
        r = p;
    }
    return OK;
}

// 销毁链表
Status DestroyList(LinkList *L) 
{
    LinkList p;
    while (*L) 
    {
        p = (*L)->next; // p指向下一个结点
        free(*L);       // 释放L
        *L = p;
    }
    return OK;
}

// 判断链表是否为空
Status ListEmpty(LinkList L) 
{
    return (L->next == NULL);
}

// 清空链表
Status ClearList(LinkList L) 
{
    LinkList p, q;
    p = L->next; // p指向链表第一个结点
    while (p)    // 当p指向空时循环结束
    {
        q = p->next;
        free(p);
        p = q;
    }
    L->next = NULL; // 头结点指针域为空
    return OK;
}

// 获取链表的长度
int ListLength(LinkList L) 
{
    LNode *p = L;
    int len = 0;
    while (p->next) 
    {
        len++;
        p = p->next;
    }
    return len;
}

// 删除链表中的第i个元素，并将删除的元素值存储到e中
Status ListDelete(LinkList L, int i, ElemType* e) 
{
    LinkList p = L;
    int j = 0; // 计数器
    // 当第i个结点为空，或者j = i-1时结束循环，此时p指向第i-1个结点
    while (p->next && j < i - 1) 
    {
        p = p->next;
        j++;
    }

    if (!(p->next) || j > i - 1)    return ERROR;

    LinkList q = p->next;   // q保存删除结点地址
    p->next = p->next->next; // 删除
    *e = q->data;           // e存放删除节点的数据
    free(q);                // 释放
    return OK;
}

// 遍历输出链表
Status ListTraverse(LinkList L) 
{
    LinkList p = L->next;
    while (p) // 当p为空时结束循环
    {
        printf("%d ", p->data); // 每一个数据都进行visit函数操作，例如visit可以是打印函数
        p = p->next;
    }
    printf("\n");
    return OK;
}

// 在第i个位置插入元素e
Status ListInsert(LinkList L, int i, ElemType e) 
{
    LinkList p = L;
    int j = 0;
    while (p && j < i - 1) 
    {
        p = p->next;
        ++j;
    }
    if (!p || j > i - 1)   return ERROR;
    LNode *r = (LNode*)malloc(sizeof(LNode));
    if (!r)      return ERROR;
    r->data = e;
    r->next = p->next;
    p->next = r;
    return OK;
}

// 对链表进行操作
Status ListOperate(LinkList L) 
{
    if (ListEmpty(L)) 
    {
        printf("0 0\n");
        return OK;
    }

    int max = L->next->data, min = L->next->data;
    LNode *p = L->next;
    while (p) 
    {
        if (max < p->data)        max = p->data;
        if (min > p->data)		  min = p->data;
        p = p->next;
    }

    ListInsert(L, 1, max);
    ListInsert(L, ListLength(L) + 1, min);
    return OK;
}

int main() 
{
    // 初始化链表
    LinkList L;
    if (InitList(&L) == ERROR)       return 0;
    ListTraverse(L);    // 打印输出初始链表
    printf("%d\n", ListLength(L)); // 打印链表长度

    ListOperate(L);     // 对链表进行操作

    ListTraverse(L);    // 打印输出操作后的链表
    DestroyList(&L);    // 销毁链表

    return 0;
}

```



#### 4.使用链栈检验括号匹配

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 100

typedef int Status;
typedef char SElemType;

// 定义链表栈节点结构
typedef struct StackNode {
    SElemType data;
    struct StackNode *next;
} StackNode, *LinkStack;

// 函数声明
Status InitStack(LinkStack *S);
Status StackEmpty(LinkStack S);
Status Push(LinkStack *S, char ch);
Status Pop(LinkStack *S, char *ch);
Status GetTop(LinkStack S, char *e);
Status match(char element_l, char element_r);

// 初始化链表栈
Status InitStack(LinkStack *S) {
    (*S) = (LinkStack)malloc(sizeof(StackNode));
    if (!(*S))
        return ERROR;
    (*S)->next = NULL;
    return OK;
}

// 判断栈是否为空
Status StackEmpty(LinkStack S) {
    return S->next == NULL ? TRUE : FALSE;
}

// 元素入栈
Status Push(LinkStack *S, char ch) {
    LinkStack s = (LinkStack)malloc(sizeof(StackNode));
    if (!s)
        return ERROR;
    s->data = ch;
    s->next = (*S)->next;
    (*S)->next = s;
    return OK;
}

// 元素出栈
Status Pop(LinkStack *S, char *ch) {
    if (StackEmpty(*S))
        return ERROR;
    LinkStack p = (*S)->next;
    *ch = p->data;
    (*S)->next = p->next;
    free(p);
    return OK;
}

// 获取栈顶元素
Status GetTop(LinkStack S, char *e) {
    if (StackEmpty(S))
        return ERROR;
    *e = S->next->data;
    return OK;
}

// 检查两个括号是否匹配
Status match(char element_l, char element_r) {
    if (element_l == '(') {
        return (element_r == ')') ? TRUE : FALSE;
    } else if (element_l == '[') {
        return (element_r == ']') ? TRUE : FALSE;
    } else if (element_l == '{') {
        return (element_r == '}') ? TRUE : FALSE;
    } else {
        exit(0);
    }
}

int main() {
	//SetConsoleOutputCP(65001);
    LinkStack S;
    char e;
    int length = 0,i;
    char str[MAXSIZE];

    InitStack(&S);
    scanf("%s", str); // 输入一串括号
    length = strlen(str);

    for (i = 0; i < length; i++) {
        switch (str[i]) {
            case '(':
            case '[':
            case '{':
                Push(&S, str[i]);
                break;
            case ')':
            case ']':
            case '}':
                if (StackEmpty(S)) {
                    printf("右括号多余\n");
                    exit(0);
                } else {
                    GetTop(S, &e);
                    if (match(e, str[i])) {
                        Pop(&S, &e);
                    } else {
                        printf("左右括号不匹配\n");
                        exit(0);
                    }
                }
                break;
            default:
                exit(0);
        }
    }

    if (StackEmpty(S)) {
        printf("括号匹配\n");
    } else {
        printf("左括号多余\n");
    }

    return 0;
}


```



#### 5. 合并两个有序链表

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef int ElemType;
typedef int Status;

// Definition of node structure of singly linked list
typedef struct L_node
{
    ElemType data;           // data field 
    struct L_node *next;     // pointer field
} LNode, *LinkedList;

// Initialize a singly linked list L with head node
Status InitLinkList(LinkedList *L)
{
    (*L) = (LNode *) malloc(sizeof(LNode));
    if (!(*L))     return ERROR;
    (*L)->next = NULL;
    return OK;
}

// Create a singly linked list L with head node, and with n elements
Status CreateList_L(LinkedList L, int a[], int n)
{
    LNode *p = L;
    int i = 0;
    for (i = 0; i < n; i++)
    {
        LNode *r = (LNode *) malloc(sizeof(LNode));
        if (!r)
            return ERROR;
        r->data = a[i];
        r->next = NULL;
        p->next = r;
        p = r;
    }
    return OK;
}

// Merge two singly linked lists La and Lb into Lc
void Merge_L(LinkedList *La, LinkedList *Lb, LinkedList *Lc)
{
    LNode *a = (*La)->next;
    LNode *b = (*Lb)->next;
    LNode *c = (*Lc);
    LNode *c1;

    while (a && b)
    {
        c1 = (LNode *) malloc(sizeof(LNode));
        if (!c1)    return; // Allocation failed

        if (a->data <= b->data)
        {
            c1->data = a->data;
            a = a->next;
        } else
        {
            c1->data = b->data;
            b = b->next;
        }
        c1->next = NULL;
        c->next = c1;
        c = c1;
    }

    while (a)
    {
        c1 = (LNode *) malloc(sizeof(LNode));
        if (!c1)    return; // Allocation failed
        c1->data = a->data;
        c1->next = NULL;
        c->next = c1;
        c = c1;
        a = a->next;
    }

    while (b)
    {
        c1 = (LNode *) malloc(sizeof(LNode));
        if (!c1)   return;
		c1->data = b->data;
        c1->next = NULL;
        c->next = c1;
        c = c1;
        b = b->next;
    }
}

// Print the elements in a list
void LinkedListPrint(LinkedList L)
{
    LNode *p = L->next;
    while (p)
    {
        printf("%d ", p->data);
        p = p->next;
    }
}

int main()
{
    LNode *La, *Lb, *Lc;
    InitLinkList(&La);
    InitLinkList(&Lb);
    InitLinkList(&Lc);

    int n, m;
    scanf("%d", &n);
    int a[n];
    int i = 0;
    for (i = 0; i < n; i++)     scanf("%d", &a[i]);

    CreateList_L(La, a, n);

    scanf("%d", &m);
    int b[m];
    for (i = 0; i < m; i++)     scanf("%d", &b[i]);

    CreateList_L(Lb, b, m);

    Merge_L(&La, &Lb, &Lc);

    LinkedListPrint(Lc);

    return OK;
}  

```



#### 6.链表删除



```c
#include <stdio.h>   
#include <stdlib.h>   
#include <malloc.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef int ElemType;
typedef int Status;

// definition of node structure of singly linked list
typedef struct L_node
{
    ElemType data;           // data field 
    struct L_node* next;       // pointer field
}LNode, * LinkList;

//===========================================
// Initialize  a singly linked list L with head node
//===========================================

Status InitList_L(LinkList *L)

{
	(*L) = (LNode*)malloc(sizeof(LNode));
	(*L)->next = NULL;
	return OK;
}

//===========================================
// Create a singly linked list L with head node, and with n elements
//===========================================

Status CreateList_L(LinkList* L, ElemType a[], int n)
{
	LNode *p = *L;
	int j = 0;
	for(;j < n;j ++)
	{
		LNode*r ;
		r = (LNode*)malloc(sizeof(LNode));
		r->data = a[j];
		r->next = NULL;
		p->next = r;
		p = r;
	}
	return OK;
}

void Delete_List(LinkList L,int i)
{
	LNode*prev = L;
	int j = 0;
	while(prev && j < i - 1)
	{
		prev = prev->next;
		j ++;
	}
	if(!prev || j > i - 1) return ;
	LinkList r = prev->next;
	prev->next = r->next;
	free(r);
	return ;
}
//===========================================
//  删除位序为偶数的结点，并返回删除结点的总数
//===========================================

int Delete_L(LinkList *L,int len)
{
	int i = len / 2;
	int j = 2 * i;
	int count = 0;
	for(;j >1;j -=2)	
	{
		Delete_List(*L,j);
		count ++;
	}
	return count;
}
//======================================
// Print the elements in a list
//=======================================

void LinkedListPrint(LinkList L)

{
	LNode *p = L->next;
	while(p)
	{
		printf("%d ",p->data);
		p = p->next;
	}
	return;
}

int main()
{
	LNode *L;
	InitList_L(&L);
	int i = 0,n;
	scanf("%d",&n);
	int arr[n];
	for(;i < n;i ++) scanf("%d",&arr[i]);
	CreateList_L(&L,arr,n);
	int tot = Delete_L(&L,n);
	printf("%d\n",tot);
	LinkedListPrint(L);
	return OK;
}
```



#### 7.链表拼接

```c
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef int ElemType;
typedef int Status;

// definition of node structure of singly linked list
typedef struct L_node
{
    ElemType data;           // data field 
    struct L_node *next;       // pointer field
} LNode, *LinkedList;

//===========================================
// Initialize  a singly linked list L with head node
//===========================================
Status InitList_L(LinkedList *L)
{
    *L = (LNode *) malloc(sizeof(LNode));
    if (!(*L)) return ERROR;
    (*L)->next = NULL;
    return OK;
}

//===========================================
// Create a singly linked list L with head node, and with n elements
//===========================================

Status CreateList_L(LinkedList *L, int a[], int n)
{
    LNode *r = (*L);
    int i = 0;
    for (; i < n; i++)
    {
        LNode *p;
        p = (LNode *) malloc(sizeof(LNode));
        p->data = a[i];
        p->next = NULL;
        r->next = p;
        r = p;
    }
    return OK;
}

//===========================================
//  Merge two singly linked lists 
//===========================================

int Merge_L(LinkedList *ha, int len_a, LinkedList *hb, int len_b, LinkedList *hc)
{
    LNode *a = (*ha)->next;
    LNode *b = (*hb)->next;
    LNode *c = *hc;
    LNode *c1;
    c1 = (LNode *) malloc(sizeof(LNode));
    if (len_a > len_b)
    {
        while (b)
        {
            c1 = b;
            c->next = c1;
            c = c1;
            b = b->next;
        }
        while (a)
        {
            c1 = a;
            c->next = c1;
            c = c1;
            a = a->next;
        }
    } 
    else
    {
        while (a)
        {
            c1 = a;
            c->next = c1;
            c = c1;
            a = a->next;
        }
        while (b)
        {
            c1 = b;
            c->next = c1;
            c = c1;
            b = b->next;
        }
    }
}

//======================================
// Print the elements in a list
//=======================================

void LinkedListPrint(LinkedList L)
{
    LNode *p = L->next;
    while (p)
    {
        printf("%d ", p->data);
        p = p->next;
    }
}

int main()
{
    LNode *La;
    LNode *Lb;
    LNode *Lc;
    InitList_L(&La);
    InitList_L(&Lb);
    InitList_L(&Lc);
    int n, m, i = 0;
    scanf("%d", &n);
    int a[n];
    for (; i < n; i++) scanf("%d", &a[i]);
    CreateList_L(&La, a, n);
    scanf("%d", &m);
    int b[m];
    for (i = 0; i < m; i++) scanf("%d", &b[i]);
    CreateList_L(&Lb, b, m);
    Merge_L(&La, n, &Lb, m, &Lc);
    LinkedListPrint(Lc);
	return OK;
}  
```



#### 双向链表学习代码：

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1

typedef int ElemType;
typedef int Status;

typedef struct DuLNode
{
    ElemType data;          // 数据域
    struct DuLNode *prior;  // 指向直接前驱
    struct DuLNode *next;   // 指向直接后继
} DuLNode, *DuLinkList;

Status GetElem_DuL(DuLinkList L, int i, ElemType *e)
{
    int j;
    DuLinkList p;
    p = L->next; // p指向第一个结点
    j = 1;
    while (p && j < i)
    {
        p = p->next;
        ++j;
    }
    if (!p || j > i)
        return ERROR; // 第i个元素不存在
    *e = p->data;     // 取第i个元素的数据
    return OK;
}

Status ListInsert_DuL(DuLinkList *L, int i, ElemType e)
{
    DuLinkList p, s;
    if (i < 1) // 如果位置不合法
        return ERROR;

    s = (DuLinkList) malloc(sizeof(DuLNode));
    if (!s)
        exit(EXIT_FAILURE); // 内存分配失败，退出程序
    s->data = e;

    if (i == 1 || !(*L)->next)
    { // 在第一个位置插入或者链表为空时
        s->next = (*L)->next;
        if ((*L)->next) // 如果链表不为空
            (*L)->next->prior = s;
        s->prior = *L;
        (*L)->next = s;
        return OK;
    }

    p = (*L)->next;
    while (--i && p) p = p->next; // 找到第 i-1 个节点
    if (!p) // 如果位置超出链表长度
        return ERROR;

    s->next = p->next;
    s->next->prior = s;
    s->prior = p;
    p->next = s;
    return OK;
}


Status ListDelete_DuL(DuLinkList *L, int i)
{
    DuLinkList p, q;
    int j = 1;
    p = *L; // 将 p 指向头节点
    while (p->next && j < i)
    {
        p = p->next;
        ++j;
    }
    if (!p->next || j > i)
        return ERROR; // 第i个元素不存在
    q = p->next;
    p->next = q->next;
    if (q->next) // 如果 q 的下一个节点不为空
        q->next->prior = p;
    free(q);
    return OK;
}


int main()
{
    DuLinkList L;
    L = (DuLinkList) malloc(sizeof(DuLNode));
    if (!L)
        exit(EXIT_FAILURE); // 内存分配失败，退出程序
    L->next = NULL;
    ElemType e;
    if (ListInsert_DuL(&L, 1, 10) == OK)
        printf("Insert successful!\n");
    if (GetElem_DuL(L, 1, &e) == OK)
        printf("The first element is: %d\n", e);
    if (ListDelete_DuL(&L, 1) == OK)
        printf("Delete successful!\n");
    //system("pause");
    return 0;
}

```



### 作业4——栈



#### 学习代码：

```c
#include <stdio.h>
#include <malloc.h>
#include <string.h>

typedef int SElemType ;
typedef int Status;

#define ERROR 0
#define OK 1
#define MAXSIZE 100
typedef struct
{
    SElemType *base;
    SElemType *top;
    int stackSize;
}SqStack;

Status InitStack(SqStack *S)
{
    S->base = (SElemType*) malloc(sizeof (SqStack));
    if(!S->base)    return ERROR;
    S->top = S->base;//top 初始为 base ,空栈
    S->stackSize = MAXSIZE;
    return OK;
}

Status Push(SqStack *S,SElemType e)
{
    if(S->top - S->base == S->stackSize)    return ERROR;//栈满
    *S->top ++= e;//将元素e压入栈顶，栈顶指针加1
    return OK;
}

Status Pop(SqStack *S,SElemType *e)
{
    if(S->base == S->top)   return ERROR;//栈空
    *e = *--S->top;//栈顶指针减1，将栈顶元素赋给e
    return OK;
}

SElemType GetTop(SqStack S)
{//返回S的栈顶元素，不修改栈顶指针
    if(S.top != S.base)   return *(S.top - 1);//返回栈顶元素的值，栈顶指针不变
}

Status destorystack(stack *p)//毁坏
{
	free(p->base);
	p->base=NULL;
	p->top=NULL;
	p->stacksize=0;
	if(!p->base)
		printf("栈被毁坏成功！！！\n");
	return OK;
}

```



```c
//将中缀表达式转化为逆波兰表达式
#include <stdio.h>
#include <stdlib.h>


typedef struct
{
	char *base;
	char *top;
	int stackSize;
}sqStack;

void InitStack(sqStack *s)
{
	s->base = (char *)malloc(100*sizeof(char));
	s->top = s->base;
	s->stackSize = 100; 
}

void Push(sqStack *s, char e)
{
	*(s->top) = e;
	s->top++; 
}

int Pop(sqStack *s, char *e)
{
	if(s->top == s->base)
	{
		return 0;	
	}
	*e = *--(s->top);	
	return 0;
} 

int StackLen(sqStack s)
{
	return (s.top - s.base);
}

int main(void)
{
	sqStack s;
	char c, e;
	
	InitStack(&s);
	printf("Input: \n");
	scanf("%c", &c);
	
	while(c != '#')
	{
		while(c>='0' && c<='9')
		{
			printf("%c", c);
			scanf("%c", &c);
			if(c<'0' || c>'9')
			{
				printf(" ");
			}
		}
		
		if(c == ')')
		{
			Pop(&s, &e);
			while(e != '(')
			{
				printf("%c", e);
				Pop(&s, &e);
			}
		}
		else if('+' == c || c=='-')
		{
			if(StackLen(s) == 0)
			{
				Push(&s, c);
			}
			else
			{
				do
				{
					Pop(&s, &e);
					if(e == '(')
					{
						Push(&s, e);
					}
					else
					{
						printf("%c", e);
					}
				}while(StackLen(s) && e != '(');
				Push(&s, c);
			}
		}
		else if('*' == c || '/'==c || '('==c)
		{
			Push(&s, c);
		}
		else if('#' == c)
		{
			break;
		}
		else
		{
			printf("error!");
			return -1;
		}
		scanf("%c", &c);	
	}
	while(StackLen(s) != 0)
	{
		Pop(&s, &e);
		printf("%c ", e);
	}
	return 0;	
} 
```



```c
//计算逆波兰表达式的result

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

typedef struct
{
	double *base;
	double *top;
	int stackSize;
}sqStack;

void InitStack(sqStack *s)
{
	s->base = (double *)malloc(100*sizeof(double));
	s->top = s->base;
	s->stackSize = 100;
}

void Push(sqStack *s, double e)
{
	*(s->top) = e;
	s->top++;
}

void Pop(sqStack *s, double *e)
{
	s->top = s->top-1;
	*e = *(s->top);
}

int main(void)
{
	char c;
	double d, e, f, g;
	char str[100];
	int i = 0;
	
	sqStack s;
	InitStack(&s);
	
	printf("input: \n");
	scanf("%c", &c);
	while(c != '#' )
	{
		while(isdigit(c) || c=='.')
		{
			str[i++] = c;
			str[i] = '\0';
			scanf("%c", &c);
			if(c == ' ')
			{
				d = atof(str);
				Push(&s, d);
				i = 0;
				break;
			}
		}
		switch(c)
		{
			case '+':
				Pop(&s, &e);
				Pop(&s, &f);
				g = f+e;
				Push(&s, g);
				break;
			case '-':
				Pop(&s, &e);
				Pop(&s, &f);
				g = f-e;
				Push(&s, g);
				break;
			case '*':
				Pop(&s, &e);
				Pop(&s, &f);
				g = f*e;
				Push(&s, g);
				break;
			case '/':
				Pop(&s, &e);
				Pop(&s, &f);
				if(e != 0)
				{
					g = f/e;
					Push(&s, g);
					break;
				}
				else
				{
					printf("error!\n");
					break;
				}
	 
		}
		scanf("%c", &c);
	}
	
	Pop(&s, &d);
	printf("Result is: %f\n", d);
	return 0;
}
```



#### 1.堆栈练习题

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0

struct Stack
{
    int top;
    unsigned capacity;
    char *array;
};

struct Stack* createStack(unsigned capacity)
{
    struct Stack *stack = (struct Stack *)malloc(sizeof(struct Stack));
    if (stack == NULL) 
    {
        printf("Memory allocation failed!\n");
        exit(EXIT_FAILURE);
    }
    stack->capacity = capacity;
    stack->top = -1;
    stack->array = (char*)malloc(stack->capacity * sizeof(char));
    if (stack->array == NULL) 
    {
        printf("Memory allocation failed!\n");
        exit(EXIT_FAILURE);
    }
    return stack;
}

int isFull(struct Stack stack)
{
	int full = 0;   
	/*在表达式 (int)stack.capacity 中，stack.capacity 是 unsigned 类型的无符号整数，
	  而 (int) 是将其强制转换为有符号整数类型 int。
	  这个强制转换的目的是为了避免比较不同类型的数据时出现警告或错误*/
	full = (stack.top == (int)stack.capacity - 1)?1:0;
	return full;
}

int isEmpty(struct Stack stack)
{
	return (stack.top == -1) ? 1 :0;
}

void push(struct Stack *stack, char item)
{
    if (!isFull(*stack)) 
    {
        stack->array[++stack->top] = item;
    } 
    else 
    {
        printf("Stack is full. Cannot push element.\n");
    }
}

char pop(struct Stack *stack)
{
    if (!isEmpty(*stack)) 
    {
        return stack->array[stack->top--];
    } 
    else 
    {
        printf("Stack is empty. Cannot pop element.\n");
        return '\0';
    }
}

void reverseStr(char *str)
{
    int length = strlen(str);
    struct Stack* stack = createStack(length + 1);
    for (int i = 0; i < length; i++) 
    {
        push(stack, str[i]);
    }
    for (int i = 0; i < length; i++) 
    {
        str[i] = pop(stack);
    }
    printf("%s\n", str);
}

int main()
{
    char str[] = "ILoveChina, ILoveBJTU, ILoveGJCXSJXL";
    reverseStr(str);
    return 0;
}

```



####    2. 栈-创建堆栈

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef int SElemType;
typedef int Status;

#define STACK_INIT_SIZE   100     // 初始栈大小
#define STACKINCREMENT    10      // 栈增量大小

typedef struct {
    SElemType *base;    // 栈底指针
    SElemType *top;     // 栈顶指针
    int stacksize;      // 当前栈容量
} SqStack;

Status InitStack(SqStack *S) 
{
    S->base = (SElemType *)malloc(sizeof(SElemType) * STACK_INIT_SIZE);
    if (!S->base)      return ERROR;
    S->top = S->base;
    S->stacksize = STACK_INIT_SIZE;
    return OK;
}

Status StackEmpty(SqStack S) 
{
    return (S.top == S.base) ? TRUE : FALSE;
}

int StackLength(SqStack S) 
{
    return (S.top - S.base);
}

Status GetTop(SqStack S, SElemType *e) 
{
  if (StackEmpty(*S))      return ERROR;
    *e = *(S.top - 1);
    return OK;
}

Status Pop(SqStack *S, SElemType *e) 
{
    if (StackEmpty(*S))      return ERROR;
    *e = *(--S->top);
    return OK;
}

Status Push(SqStack *S, SElemType e) 
{
    if (S->top - S->base >= S->stacksize) 
    {
        //内存不够，重新分配空间
        S->base = (SElemType *)realloc(S->base, (S->stacksize + STACKINCREMENT) * sizeof(SElemType));
        if (!S->base)        return ERROR;
        S->top = S->base + S->stacksize;
        S->stacksize += STACKINCREMENT;
    }
    *(S->top++) = e;
    return OK;
}

void PrintStack(SqStack S) 
{
    int len = StackLength(S);
    for (int i = 0; i < len; i++) 
    {
        SElemType e;
        Pop(&S, &e);
        printf("%d ", e);
    }
    printf("\n");
}

int reverseOutput(SqStack S) 
{
    if (StackEmpty(S))      return ERROR;
    PrintStack(S);
    return StackLength(S);
}

int main() 
{
    SqStack S;
    InitStack(&S);
    int n, i = 0;
    scanf("%d", &n);
    int arr[n];
    for (; i < n; i++) 
    {
        scanf("%d", &arr[i]);
        Push(&S, arr[i]);
    }
    printf("%d", reverseOutput(S));
    return OK;
}

```



#### 3. 栈-比较含退格的字符串

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef char ElemType;
typedef int Status;

#define STACK_INIT_SIZE   100          // Initial size for memory allocation
#define STACKINCREMENT    10           // Incremental size

typedef struct 
{
    ElemType  *base;    // Base pointer
    ElemType  *top;     // Top pointer
    int        stacksize;     // Current size
} SqStack;

Status InitStack(SqStack *S) 
{
    S->base = (ElemType *)malloc(STACK_INIT_SIZE * sizeof(ElemType));
    if (!S->base) return ERROR;
    S->top = S->base;
    S->stacksize = STACK_INIT_SIZE;
    return OK;
}

Status StackEmpty(SqStack S)
{
    return S.base == S.top ? TRUE : FALSE;
}

int StackLength(SqStack S) 
{
    return S.top - S.base;
}

Status GetTop(SqStack S, ElemType *e) 
{
    if (StackEmpty(S)) return ERROR;
    *e = *(S.top - 1);
    return OK;
}

Status Pop(SqStack *S, ElemType *e)
{
    if (StackEmpty(*S)) return ERROR;
    *e = *--S->top;
    return OK;
}

Status Push(SqStack *S, ElemType e) 
{
    if (S->top - S->base >= S->stacksize)
    {
        S->base = (ElemType *)realloc(S->base, (S->stacksize + STACKINCREMENT) * sizeof(ElemType));
        if (!S->base) return ERROR;
        S->top = S->base + S->stacksize;
        S->stacksize += STACKINCREMENT;
    }
    *S->top++ = e;
    return OK;
}

int CompareString(char *S,  char *T)
{
    SqStack stack_S, stack_T;
    InitStack(&stack_S);
    InitStack(&stack_T);
    
    for (int i = 0; S[i] != '\0'; i++) 
    {
        if (S[i] != '#')     Push(&stack_S, S[i]);
        else 
        {
            if (!StackEmpty(stack_S)) 
            {
                ElemType temp;
                Pop(&stack_S, &temp);
            }
        }
    }
    
    for (int i = 0; T[i] != '\0'; i++) 
    {
        if (T[i] != '#')        Push(&stack_T, T[i]); 
        else 
        {
            if (!StackEmpty(stack_T)) 
            {
                ElemType temp;
                Pop(&stack_T, &temp);
            }
        }
    }
    
    if (StackLength(stack_S) != StackLength(stack_T))      return FALSE;
    while (!StackEmpty(stack_S)) 
    {
        ElemType charS, charT;
        Pop(&stack_S, &charS);
        Pop(&stack_T, &charT);
        if (charS != charT)      return FALSE;
    }
    return TRUE;
}

int main() 
{
    char s[1000], t[1000];
    scanf("%s", s);
    scanf("%s", t);
    
    int res = CompareString(s, t);
    if (res)   printf("true");
    else 		printf("false");

    return 0;
}

```



#### 4. 820230003栈基本操作与应用



```c
#define BASE 17

#include <stdio.h>
#include <stdlib.h>

#define Status int
#define SElemType char

#define STACK_INIT_SIZE 100        //存储空间的初始分配量
#define STACKINCREMENT  10          //存储空间的分配增量
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0

//栈数据结构
typedef struct Stack 
{
    SElemType *base;    //栈底指针
    SElemType *top;     //栈顶指针
    int stacksize;      //栈可用的最大容量
} SqStack;

//初始化函数
Status InitStack(SqStack *S) 
{
    S->base = (SElemType *)malloc(STACK_INIT_SIZE * sizeof(SElemType));
    if (!S->base) 
    {
        printf("init fail\n");
        return ERROR;
    }
    S->top = S->base;     //栈顶指针与栈底相同
    S->stacksize = STACK_INIT_SIZE;
    return OK;
}

//销毁 
Status DestroyStack(SqStack *S) 
{
    //补全代码
	free(S->base);
	S->base = NULL;
	S->top = NULL;  
	S->stacksize = 0;
	if(S->base)	
	{
		printf("Fail Destroy");
		return ERROR;
	}
	return OK;
}

//清空 
Status ClearStack(SqStack *S) 
{
    S->top = S->base;
    return OK;
}

//判断是否为空 
Status StackEmpty(SqStack S) 
{
    if (S.top == S.base) 
        return TRUE;
    else
        return FALSE;
}

int StackLength(SqStack S) 
{
    return S.top - S.base;
}

//得到栈顶元素，不修改指针
Status GetTop(SqStack S, SElemType *e) 
{ 
    if (S.top == S.base) 
        return ERROR;
    *e = *(S.top - 1);
    return OK;
}

//入栈
Status Push(SqStack *S, SElemType e) 
{
    if (S->top - S->base >= S->stacksize) 
    {  //栈满,追加存储空间
        S->base = (SElemType *)realloc(S->base, (S->stacksize + STACKINCREMENT) * sizeof(SElemType));
        if (!S->base) 
            return ERROR;
        S->top = S->base + S->stacksize;
        S->stacksize += STACKINCREMENT;
    }
    *S->top++ = e;
    return OK;
}

//出栈
Status Pop(SqStack *S, SElemType *e) 
{
    if (S->top == S->base) 
        return ERROR;    //栈空
    *e = *--S->top;
    return OK;
}

//遍历栈
Status StackTraverse(SqStack S) 
{
    if (S.base == NULL)
        return ERROR;
    if (S.top == S.base)
        printf("empty\n");
    SElemType *p;
    p = S.top;
    while (p > S.base) 
    {
        p--;
        printf("%c", *p);//从栈顶开始打印，而且未修改栈顶指针 
    }
    return OK;
}

void conversion(SqStack *S) 
{
    //补全代码
    int decimal = 0;
    scanf("%d",&decimal);
    char base17[20] = "0123456789ABCDEFG";
    while(decimal)
    {
    	int index = decimal % 17;
    	Push(S,base17[index]);
    	decimal /=17;
	}
	StackTraverse(*S);
}

//主函数
int main() 
{
    SqStack S;
    InitStack(&S);
    conversion(&S);
    DestroyStack(&S);
    return 0;
}

```



#### 5. 实验4 栈实验1



```c
#include <stdio.h>

#include <string.h>

#include <stdlib.h>


#define STACK_INIT_SIZE    20     /*存储空间的初始分配量*/

#define STACK_INCREMENT    10     /*存储空间的分配增量*/

//#define CHAR_MAX 127

#define DBL_MAX 100

#define ERROR 0

#define OK 1


/*数据栈结构体定义，要求：

包括栈底指针，栈顶指针和当前分配的存储容量*/

typedef struct
{

    double *Dbase;

    double *Dtop;

    int Dstacksize;

} DataStack;


/*操作符结构体定义，要求包括栈底指针，栈顶指针和当前分配的存储容量*/

typedef struct
{

    char *Obase;

    char *Otop;

    int Ostacksize;

} OpStack;


/*静态二维优先级数组：static char OperationPreceder[7][7]   

定义操作符＋、－、＊、／、（、）、=的运算优先级*/

static char OperationPreceder[7][7] =

        {{'>', '>', '<', '<', '<', '>', '>'},

         {'>', '>', '<', '<', '<', '>', '>'},

         {'>', '>', '>', '>', '<', '>', '>'},

         {'>', '>', '>', '>', '<', '>', '>'},

         {'<', '<', '<', '<', '<', '=', 'x'},

         {'>', '>', '>', '>', 'x', '>', '>'},

         {'<', '<', '<', '<', '<', 'x', '='}

        };


/*函数接口定义为：int TransOPtoCD(char op_temp)   

* 输入参数：操作符x   

* 处理规则及返回值：将操作符转化为运算优先级静态表的坐标，并返回；   

* 输入参数非＋、－、＊、／、（、）、=，则返回－1*/

int TransOPtoCD(char op_temp)
{

    switch (op_temp)
    {

        case '+':
            return (0);

        case '-':
            return (1);

        case '*':
            return (2);

        case '/':
            return (3);

        case '(':
            return (4);

        case ')':
            return (5);

        case '=':
            return (6);

        default:
            return (-1);  /*当输入参数不是四则运算、括号、等号时，返回－1*/

    }


}


/*函数接口定义为：char Precede(char op1, char op2)   

* 输入参数：进行比较的运算符op1和op2；   

* 处理规则及返回值：将op1和op2转化为二维数组OperationPreceder的坐标，查找该坐标存储的符号，并作为返回值输出；   

* 如果无法找到坐标则返回0*/

char Precede(char op1, char op2)
{

    int x, y;

    x = y = -1;

    x = TransOPtoCD(op1);

    y = TransOPtoCD(op2);

    if (x != -1 && y != -1)
    {

        //    printf("%c\n", OperationPreceder[x][y]);       

        return OperationPreceder[x][y];

    } else

        return 0;

}


/*函数接口定义为：int checkch (char c)   

* 输入参数：表达式字符c；   

* 处理规则及返回值：判断字符c是数字还是操作符；   

* 如果c是数字返回1，如果是小数点返回2，如果是运算符返回3，否则为无效字符返回－1；   

* 假设：表达式中的所有云算数均为正数*/

int checkch(char c)
{

    if (c >= '0' && c <= '9')

        return 1;

    if (c == '.')

        return 2;

    if (c == '+' || c == '-' || c == '*' || c == '/' || c == '(' || c == ')' || c == '=')

        return 3;

    else

        return 0;

}


/*函数接口定义为：double Operate(double x,double y, char op)；   

* 输入参数：运算数x，被运算数y，操作符op；   

* 处理规则及返回值：进行x op y运算，返回运算结果；默认返回0.0*/

double Operate(double x, double y, char op)
{

    switch (op)
    {

        case '+':

            return x + y;

        case '-':

            return x - y;

        case '*':

            return x * y;

        case '/':

            if (y != 0)

                return x / y;

            else

                printf("The divisor cannot be 0!\n");

            exit(-1);

        default:

            break;

    }

    return 0.0;

}


/*数据栈初始化函数定义，要求：   

* 函数接口定义为：int InitDataStack(DataStack *DS)   

* 输入参数：数据栈DS   

* 处理规则及返回值：从内存堆中申请STACK_INIT_SIZE个整型空间，将栈顶指针与栈底指针都指向初始地址，给Dstacksize赋值STACK_INIT_SIZE   

* 初始化成功返回1，否则返回0.*/

int InitDataStack(DataStack *DS)
{


    //根据注释, 将该函数补充完整
    DS->Dbase = (double*)malloc(sizeof(double));
    if(!DS->Dbase)	return ERROR;
    DS->Dtop = DS->Dbase;
	DS->Dstacksize =  STACK_INIT_SIZE;
	return OK;
	
	
}


/* 数据栈入栈函数定义，要求：   

* 函数接口定义为：int PushDataStack(DataStack *DS,int e)   

* 输入参数：待操作数据栈DS，插入数据e；   

* 处理规则及返回值：在栈顶指针位置存储e，并将栈顶指针位置后移，返回1；   

如果数据栈不存在或者数据栈上溢，返回错误（0）。*/

int PushDataStack(DataStack *DS, double e)
{
	if(!DS->Dbase)	return ERROR;//数据栈不存在
	if(DS->Dtop - DS->Dbase >= DS->Dstacksize)
	{//据栈上溢,重新分配内存 
		DS->Dbase = (double*)realloc(DS->Dbase,(DS->Dstacksize +STACK_INCREMENT ) * sizeof(double));
		if(!DS->Dbase)	return ERROR;
		DS->Dtop = DS->Dbase + DS->Dstacksize;
		DS->Dstacksize += STACK_INCREMENT;
	}
	*(DS->Dtop++) = e;
	return OK;
   // 根据注释, 将该函数补充完整


}


/*数据栈出栈函数定义，要求：   

* 函数接口定义为：int PopDataStack(DataStack *DS, int *e)   

* 输入参数：数据栈DS, 输出整型指针变量e；   

* 处理规则及返回值：将栈顶指针减1，将该地址存储的变量付给＊e，返回1；   

如果数据栈不存在或数据栈为空，返回0。*/

int PopDataStack(DataStack *DS, double *e)
{

    //根据注释, 将该函数补充完整
    if(!DS->Dbase)	return ERROR;
    *e = *--DS->Dtop;
	return OK; 

}


/*数据栈查看栈顶元素函数定义，要求：   

* 函数接口定义为：int GetDataTop(DataStack *DS)   

* 输入参数：数据栈DS, 记录栈顶元素变量e；   

* 处理规则及返回值：如果数据栈不存在或数据栈为空，返回DBL_MAX; 否则，返回栈顶元素。*/

double GetDataTop(DataStack *DS)
{


    //根据注释, 将该函数补充完整
	if(!DS->Dbase)	return DBL_MAX;
	return *(DS->Dtop - 1);
	
}


/*数据栈销毁函数定义，要求：   

* 函数接口定义为：int DestroyDataStack(DataStack *DS   

* 输入参数：数据栈DS   

* 处理规则及返回值：释放栈底指针所指空间，并将数据栈的栈底和栈顶指针置空，数据栈Dstacksize置为0。最后返回1*/

int DestroyDataStack(DataStack *DS)
{

    //根据注释, 将该函数补充完整
    free(DS->Dbase);
	DS->Dbase = NULL;
	DS->Dtop = NULL;
	DS->Dstacksize = 0;
	if(DS->Dbase)	return ERROR;
	return OK;

}


/*符号栈初始化函数定义，要求：   

* 函数接口定义为：int InitOpStack(OpStack *OS)   

* 输入参数：符号栈OS   

* 处理规则及返回值：从内存堆中申请STACK_INIT_SIZE个整型空间，将栈顶指针与栈底指针都指向初始地址，给Dstacksize赋值STACK_INIT_SIZE   

* 初始化成功返回1，否则返回0.*/

int InitOpStack(OpStack *OS)
{

    //根据注释, 将该函数补充完整
    OS->Obase = (char*)malloc(sizeof(char));
    if(!OS->Obase)	return ERROR;
    OS->Otop = OS->Obase;
    OS->Ostacksize = STACK_INIT_SIZE;
    return OK;

}


/* 符号栈入栈函数定义，要求：   

* 函数接口定义为：int PushOpStack(OpStack *OS,int e)   

* 输入参数：待操作符号栈DS，插入符号e；   

* 处理规则及返回值：在栈顶指针位置存储e，并将栈顶指针位置后移，返回1；   

如果符号栈不存在或者符号栈上溢，返回0。*/

int PushOpStack(OpStack *OS, char e)
{


//    根据注释, 将该函数补充完整
	if(!OS->Obase)	return OK;
	if(OS->Otop - OS->Obase >= OS->Ostacksize)	
	{
		OS->Obase = (char*)realloc(OS->Obase,(OS->Ostacksize + STACK_INCREMENT)*sizeof(char));
		
	}
	*OS->Otop++ = e;
}


/* 符号栈出栈函数定义，要求：   

* 函数接口定义为：int PopOpStack(OpStack *OS, int *e)   

* 输入参数：符号栈DS, 输出符号指针变量e；   

* 处理规则及返回值：将栈顶指针减1，将该地址存储的变量付给＊e，返回1；   

如果符号栈不存在或符号栈为空，返回0。*/

int PopOpStack(OpStack *OS, char *e)
{

    //根据注释, 将该函数补充完整
    if(!OS->Obase)	return ERROR;
    *e = *--OS->Otop;
    return OK;

}


/* 符号栈查看栈顶元素函数定义，要求：   

* 函数接口定义为：char GetOpTop(OpStack *OS)   

* 输入参数：数据栈DS, 记录栈顶元素变量e；   

* 处理规则及返回值：如果数据栈不存在或数据栈为空，返回CHAR_MAX; 否则，返回栈顶元素。*/

char GetOpTop(OpStack *OS)
{


    //根据注释, 将该函数补充完整
	if(!OS->Obase)	return ERROR;
	return *(OS->Otop - 1);

}


/* 符号栈销毁函数定义，要求：   

* 函数接口定义为：int DestroyOpStack(OpStack *OS)   

* 输入参数：符号栈DS   

* 处理规则及返回值：释放栈底指针所指空间，并将符号栈的栈底和栈顶指针置空，符号栈Dstacksize置为0。最后返回1*/

int DestroyOpStack(OpStack *OS)
{

    //根据注释, 将该函数补充完整
	free(OS->Obase);
	OS->Obase = NULL;
	OS->Otop = NULL;
	OS->Ostacksize = 0;
	if(OS->Obase)	return ERROR;
	return OK; 

}


int main()
{

    OpStack OPTR = {0};      /*运算符栈*/

    DataStack OPND = {0};    /*操作数栈*/

    char op = 0;             /*当前运算符*/

    double value = 0.0;        /*数字字符的组合结果*/

    double b = 0.0;         /*当前运算的操作数*/

    double a = 0.0;         /*当前运算的被操作数*/

    char expression[1001] = {0};          /*表达式缓存，表达式长度不大于1000个字符*/

    int i = 0;                            /*表达式缓存的当前读取位置*/



    /*数据栈初始化函数定义，要求：   

    * 函数接口定义为：int InitDataStack(DataStack *DS)   

    * 输入参数：数据栈DS   

    * 处理规则及返回值：从内存堆中申请STACK_INIT_SIZE个整型空间，将栈顶指针与栈底指针都指向初始地址，给Dstacksize赋值STACK_INIT_SIZE   

    * 初始化成功返回1，否则返回0.*/

    if (InitDataStack(&OPND) == 0)
    {

        printf("InitDataStack Wrong\n");

        return 1;

    }



    /*符号栈初始化函数定义，要求：   

    * 函数接口定义为：int InitOpStack(OpStack *OS)   

    * 输入参数：符号栈OS   

    * 处理规则及返回值：从内存堆中申请STACK_INIT_SIZE个整型空间，将栈顶指针与栈底指针都指向初始地址，给Dstacksize赋值STACK_INIT_SIZE   

    * 初始化成功返回1，否则返回0.*/

    if (InitOpStack(&OPTR) == 0)
    {

        printf("InitOpStack Wrong\n");

        return 1;

    }



    /*符号栈栈底压入'＝'*/

    PushOpStack(&OPTR, '=');

    /*提示输入表达式，以等号结束*/

    printf("Please input the expression:\n");

    /*从标准输入获得表达式存入数组expression*/

    gets(expression);

    /*防护代码：当用户遗漏＝时提示*/

    if (expression[strlen(expression) - 1] != '=')
    {

        printf("Error: Please make sure the expression is ended with '='!");

        return 0;

    }


    while (i < strlen(expression) - 1 || GetOpTop(&OPTR) != '=')
    {

        //防护无效输入       

        if (checkch(expression[i]) == 0)
        {

            printf("Error: Invalid Input!");

            return 0;

        }

        //当表达式当前字符是数字时，逐位读入并组合       

        if (checkch(expression[i]) == 1)
        {

            while (checkch(expression[i]) == 1)
            {

                value = 10 * value + expression[i] - '0';

                i++;

            }

            /*如果表达式当前字符是小数，小数点后的数字处理后与小数点之前的数字相加*/

            if (checkch(expression[i]) == 2)
            {

                int r = 10;

                i++;

                while (checkch(expression[i]) == 1)
                {

                    value += (double) (expression[i] - '0') / r;

                    r = 10 * r;

                    i++;

                }

            }

            //数字压入数字栈OPND        

            PushDataStack(&OPND, value);

            value = 0.0;

        }



        /*如果表达式当前字符是运算符，则需要判断当前运算符与符号栈栈顶运算符的优先级*/

        if (checkch(expression[i]) == 3)
        {


            switch (Precede(GetOpTop(&OPTR), expression[i]))
            {

                /*如果符号栈栈顶运算符的优先级 < 表达式当前字符，则将表达式当前字符压入符号栈*/

                case '<':

                    PushOpStack(&OPTR, expression[i]);

                    i++;

                    break;

                    /*如果符号栈栈顶运算符的优先级 = 表达式当前字符，删去该栈顶符号*/

                case '=':

                    PopOpStack(&OPTR, &op);

                    i++;

                    break;

                    /*如果符号栈栈顶运算符的优先级 > 表达式当前字符，则计算栈顶运算符子式*/

                case '>':

                    PopOpStack(&OPTR, &op);

                    PopDataStack(&OPND, &b);

                    PopDataStack(&OPND, &a);

                    PushDataStack(&OPND, Operate(a, b, op));  /*运算结果入数据栈*/

                    break;

                default:

                    break;

            }

        }

    }

    /*打印表达式计算结果*/

    printf("The result is:%.2f\n", GetDataTop(&OPND));

    /*主动释放数据栈和符号栈的空间*/

    DestroyDataStack(&OPND);

    DestroyOpStack(&OPTR);

    return 0;

} 
```





#### 6. 实验4 栈实验2

```c
#include<stdio.h>
#include<stdlib.h>

#define OK 1
#define ERROR 0

typedef int SElemType;

typedef struct StackNode 
{
    SElemType data;
    struct StackNode *next;
} StackNode, *LinkStack;

void InitStack(LinkStack *S) 
{
    *S = (LinkStack)malloc(sizeof(StackNode));
    if(!(*S))	return;
    (*S)->next = NULL; 
    //下面是错误的内存开辟，sizeof(LinkStack)是一个指针变量的大小，存的就地址值，无法为StackNode开辟空间
    //S = (LinkStack*)malloc(sizeof(LinkStack));
    //if(!S)	return ;
    //(*S)->next = NULL; 
}

int StackEmpty(LinkStack S) 
{
    if (S->next == NULL) 
    {
        return 1;
    } 
    else 
    {
        return 0;
    }
}

void Push(LinkStack *S, SElemType e) 
{
    LinkStack p = *S;	
    LinkStack r;
    r = (LinkStack)malloc(sizeof(StackNode));
    if(!r)	return;
    r->data = e;
    r->next = p->next;
    p->next = r;
}

int Pop(LinkStack *S, SElemType *e) 
{
    if(StackEmpty(*S)) return ERROR;
    LinkStack p = *S;
    LinkStack q = p->next;
    *e = q->data;
    p->next = q->next;
    free(q);
    return OK;
}

void Conversion() 
{
    LinkStack S;
    InitStack(&S);
    printf("请输入非负十进制数\n");
    int N;
    N = 1348;
    while (N != 0) 
    {
        int mod = N % 8;
        Push(&S, mod);
        N = N / 8;
    }
    printf("八进制形式为: ");
    int e;
    while (StackEmpty(S) != 1) 
    {
        if(Pop(&S, &e) == OK)//判断是否pop成功
            printf("%d", e);
    }
    printf("\n");
}

int main() 
{
    Conversion();
    return 1;
}

```



#### 7. 栈-棒球比赛



```c
#include <stdio.h>  

#include <stdlib.h>  

#include <malloc.h>

 

#define ERROR 0

#define OK 1

#define TRUE 1

#define FALSE 0

 

typedef int SElemType;  

typedef int Status;

 

typedef struct L_node{

     SElemType     data;  //data field

     struct L_node  *next;   //pointer field

}LNode, *LinkList;

 

typedef struct{

   LinkList  Head;  //head pointer

   int  length;  //length

}LinkStack;

 

//========================================== 

// initialization of linked list based stack

//=========================================== 

Status InitStack(LinkStack *S)
{
	
	S->Head = (LinkList)malloc(sizeof(LNode));
	if(!(S->Head))	return ERROR; 
	S->Head->next = NULL;
	S->length = 0;
	return OK;
}

//========================================

//Test empty stack

//========================================

Status StackEmpty (LinkStack S)
{

	return (S.length == 0)?TRUE:FALSE;

}

 

//===============================================

// Get the length of a stack

//==============================================

int StackLength (LinkStack S)
{
 	               

}

 

//=====================================

// Get top item of a stack

//====================================

int GetTop(LinkStack S)
{
	if(S.length == 0) return ERROR;
	return S.Head->next->data;

}

 

//===================================================

// Delete an item from the stack

//====================================================

Status Pop(LinkStack *S, SElemType *e)
{
	if(S->length == 0)	return ERROR;
	LinkList p = S->Head->next;
	LinkList r = S->Head;
	*e = p->data;
	r->next = p->next;
	S->length --;
	free(p);
	return OK;
}

 

//======================================

// Insert an item into the stack

//=======================================

Status Push(LinkStack *S, SElemType e)
{
	LinkList p = S->Head;
	LinkList r;
	r = (LinkList)malloc(sizeof(LNode));
	if(!r) return ERROR;
	r->data = e;
	r->next = p->next;
	p->next = r;
	S->length ++;
	return OK;

}

 

//======================================

// Print the elements in a stack

//=======================================

void PrintStack (LinkStack S)
{

	LinkList p = S.Head->next;
	while(p)
	{
		printf("%d ",p->data);
		p = p->next;
	 } 
	 
}

//=========================

// 计算分值，s为字符串数组，nSize为数组的长度

//========================

int CalPoints(char *s,  int nSize)

{
	LinkStack Sstack;
	InitStack(&Sstack);
	int count = 0,i = 0,e;
	for(;i < nSize;i ++)
	{
		if(s[i] <= '9' && s[i] >= '0')	Push(&Sstack,s[i] - '0');
		else if(s[i] == '+')	
		{
			LinkList p = Sstack.Head->next;
			//while(p->next->next)	p = p->next;
			Push(&Sstack,p->data + p->next->data);
		}
		else if(s[i] == 'D')	Push(&Sstack,2 * GetTop(Sstack));
		else if(s[i] == 'C')	Pop(&Sstack,&e);
	}
	
	LinkList q = Sstack.Head->next;
	while(q)	
	{
		count +=q->data;
		q = q->next; 
	}
	return count;

} 



int main()  

{  
	int n,i = 0;
	char str[n + 1];
	scanf("%d",&n);
	for(;i < n;i ++)	
	{
		getchar(); 
		scanf("%c",&str[i]);
	}
	str[n] = '\0';
	printf("%s",str); 
	printf("%d",CalPoints(str,n));
	
	return OK;

 } 
```



#### 8. 栈-判断操作序列是否合法

```c
#include <stdio.h>  

#include <stdlib.h>  

#include <malloc.h>

 

#define ERROR 0

#define OK 1

#define TRUE 1

#define FALSE 0

typedef char SElemType;  

typedef int Status;

 

// definition of array based stack

#define STACK_INIT_SIZE   100          //Initial size for memory allocation

#define STACKINCREMENT  10          //incremental size

typedef struct{

   SElemType  *base;    //base pointer

   SElemType  *top;      //top pointer

   int        stacksize;     //current size

}SqStack;

 

//========================================== 

// initialization of array-based stack

//=========================================== 

Status InitStack(SqStack *S)
{

	S->base = (char*)malloc(STACK_INIT_SIZE*sizeof(char));
	if(!S->base)	return ERROR;
	S->top = S->base;
	S->stacksize =  STACK_INIT_SIZE;
	return OK;
}

 

//========================================

//Test empty stack

//========================================

Status StackEmpty (SqStack S)
{

	return (S.base == S.top)?TRUE:FALSE;

}

 

//===============================================

// Get the length of a stack

//==============================================

int StackLength (SqStack S)
{

	return S.top - S.base;                            

}

 

//=====================================

// Get top item of a stack

//====================================

Status GetTop(SqStack S, SElemType *e)
{
	if(StackEmpty(S))	return ERROR;
	*e = *(S.top - 1);
 	return OK;

}

 

//===================================================

// Delete an item from the stack

//====================================================

Status Pop(SqStack *S)
{

	if(StackEmpty(*S))	return ERROR;
	--S->top; 
	return OK;
}

 

//======================================

// Insert an item into the stack

//=======================================

Status Push(SqStack *S,SElemType e)
{

	if(S->stacksize == StackLength(*S)) 
	{
		S->base = (char*)realloc(S->base,(S->stacksize + STACKINCREMENT) *sizeof(char));
		if(!S->base)	return ERROR;
		S->top = S->base + S->stacksize;
		S->stacksize += STACKINCREMENT; 
	 } 
	 *S->top ++ = e;
	return OK;
}

 

//======================================

// Print the elements in a stack

//=======================================

void PrintStack (SqStack S)
{
	
	SElemType *p = S.base;
	while(p < S.top)
	{
		printf("%c",*p++);
	}
	printf("\n"); 
}

 

//======================================

// 检查操作序列是否合法, 如果合法，返回1，否则返回0

//=======================================

int isLegal(char *s)

{
	SqStack T; 
	InitStack(&T);
	
	int i = 0;
	for(;s[i] != '\0';i ++)
	{
		if(s[i] == 'I')	Push(&T,s[i]);
		else if(s[i] == 'O')	if(!Pop(&T)) return ERROR;
	}
	return StackEmpty(T);
}



int main( )  

{  
	char str[10010];
	scanf("%s",str);
	int tag = isLegal(str);
	if(tag)	printf("True");
	else printf("False");
	return OK;


 } 
```



#### 9. 栈-删除元素



> ```c
> #include <stdio.h>  
> #include <stdlib.h>  
> #include <malloc.h>
> 
> #define ERROR 0
> #define OK 1
> #define TRUE 1
> #define FALSE 0
> 
> typedef int SElemType;  
> typedef int Status;
> 
> typedef struct L_node {
>     SElemType data;  //data field
>     struct L_node *next;   //pointer field
> } LNode, *LinkList;
> 
> typedef struct {
>     LinkList Head;  //head pointer
>     int length;  //length
> } LinkStack;
> 
> //========================================== 
> // initialization of linked list based stack
> //=========================================== 
> Status InitStack(LinkStack *S)
> {
>    S->Head = (LinkList)malloc(sizeof(LNode));
>    if(!S->Head)	return ERROR;
>    S->Head->next = NULL;
>    S->length = 0;
>    return OK; 
> }
> 
> //========================================
> // Test empty stack
> //========================================
> Status StackEmpty(LinkStack S)
> {
> 	return (!S.length);
> }
> 
> //===============================================
> // Get the length of a stack
> //==============================================
> int StackLength(LinkStack S)
> {
> 	return S.length;
> }
> 
> //=====================================
> // Get top item of a stack
> //====================================
> Status GetTop(LinkStack S, SElemType *e)
> {
> 	if(StackEmpty(S))	return ERROR;
> 	*e = S.Head->next->data;
> }
> 
> //===================================================
> // Delete an item from the stack
> //====================================================
> Status Pop(LinkStack *S, SElemType *e)
> {
> 	if(StackEmpty(*S))	return ERROR;
> 	LinkList p = S->Head;
> 	LinkList r = p->next;
> 	p->next = r->next;
> 	*e = r->data;
> 	free(r);
> 	S->length --;
> 	return OK;
> }
> 
> //======================================
> // Insert an item into the stack
> //=======================================
> Status Push(LinkStack *S, SElemType e)
> {
> 	LinkList p = S->Head;
> 	LinkList r;
> 	r = (LinkList)malloc(sizeof(LNode));
> 	r->data = e;
> 	r->next = p->next;
> 	p->next = r;
> 	S->length ++;
> 	return OK;
> }
> 
> //======================================
> // Print the elements in a stack
> //=======================================
> void PrintStack(LinkStack S)
> {
> 	LinkList p = S.Head->next;
> 	while(p)
> 	{
> 		printf("%d ",p->data);
> 		p = p->next;
> 	 } 
> 	 printf("\n");
> }
> 
> //======================================
> // 删除堆栈中值为x的元素（可能有多个），返回堆栈的长度
> //=======================================
> int DeleteElem(LinkStack *S, SElemType x)
> {
> 	LinkList p = S->Head;
> 	while(p->next)
> 	{
> 		if(p->next->data != x)	p = p->next;
> 		else
> 		{
> 			LinkList r = p->next;
> 			p->next = r->next;
> 			free(r);
> 			 S->length --;
> 		  }  
> 	}
> 	return S->length;
> }
> 
> int main()  
> {  
> 	LinkStack S;
> 	InitStack(&S);
> 	int n,i = 0;
> 	scanf("%d",&n);
> 	int arr[n];
> 	for(;i < n;i ++)	
> 	{
> 		scanf("%d",&arr[i]);
> 		Push(&S,arr[i]);
> 	}
> 	int x;
> 	scanf("%d",&x);
> 	
> 	int tag = DeleteElem(&S,x);
> 	PrintStack(S);
> 	printf("%d",tag);
> }
> 
> ```
>



### 作业5——队列

#### 学习代码：

##### 循环队列式：

```c
//循环队列
#include <stdio.h>
#include <stdlib.h>

#define MAXQSIZE 100
#define OVERFLOW -1
#define ERROR 0
#define OK 1

typedef int QElemType;
typedef int Status;

// 循环队列
typedef struct {
    QElemType *base;
    int front;
    int rear;
} SqQueue;

Status InitQueue(SqQueue *Q) 
{
    Q->base = (QElemType*) malloc(MAXQSIZE * sizeof(QElemType));
    if (!Q->base) 
    {
        exit(OVERFLOW);
    }
    Q->front = Q->rear = 0;
    return OK;
}

int QueueLength(SqQueue Q) 
{
    return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;
}

Status EnQueue(SqQueue *Q, QElemType e) 
{
    if ((Q->rear + 1) % MAXQSIZE == Q->front) 
    {
        return ERROR; // 队列已满
    }
    Q->base[Q->rear] = e;
    Q->rear = (Q->rear + 1) % MAXQSIZE;
    return OK;
}

Status DeQueue(SqQueue *Q, QElemType *e) 
{
    if (Q->front == Q->rear) 
    {
        return ERROR; // 队列为空
    }
    *e = Q->base[Q->front]; // 保存值
    Q->front = (Q->front + 1) % MAXQSIZE;
    return OK;
}

QElemType GetHead(SqQueue Q) 
{
    if (Q.front != Q.rear) 
    { // 队列不为空
        return Q.base[Q.front]; // 返回值
    }
    // 处理空队列
    return -1; // 或其他适当值
}

void DestroyQueue(SqQueue *Q) 
{
    free(Q->base);
    Q->base = NULL;
    Q->front = Q->rear = 0;
}

int main() 
{
    SqQueue Q;
    InitQueue(&Q);
    EnQueue(&Q, 1);
    EnQueue(&Q, 2);
    EnQueue(&Q, 3);

    printf("队列长度: %d\n", QueueLength(Q));

    QElemType head;
    if (DeQueue(&Q, &head)) 
    {
        printf("出队元素: %d\n", head);
    }

    printf("出队后队列长度: %d\n", QueueLength(Q));

    printf("队列头部元素: %d\n", GetHead(Q));

    DestroyQueue(&Q);

    return 0;
}

```

##### 链队列式：

```c
//链队列
#include <stdio.h>
#include <stdlib.h>

#define MAXQSIZE 100
#define OVERFLOW -1
#define ERROR 0
#define OK 1

typedef int QElemType;
typedef int Status;

// 循环队列
typedef struct {
    QElemType *base;
    int front;
    int rear;
} SqQueue;

Status InitQueue(SqQueue *Q) 
{
    Q->base = (QElemType*) malloc(MAXQSIZE * sizeof(QElemType));
    if (!Q->base) 
    {
        exit(OVERFLOW);
    }
    Q->front = Q->rear = 0;
    return OK;
}

int QueueLength(SqQueue Q) 
{
    return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;
}

Status EnQueue(SqQueue *Q, QElemType e) 
{
    if ((Q->rear + 1) % MAXQSIZE == Q->front) 
    {
        return ERROR; // 队列已满
    }
    Q->base[Q->rear] = e;
    Q->rear = (Q->rear + 1) % MAXQSIZE;
    return OK;
}

Status DeQueue(SqQueue *Q, QElemType *e) 
{
    if (Q->front == Q->rear) 
    {
        return ERROR; // 队列为空
    }
    *e = Q->base[Q->front]; // 保存值
    Q->front = (Q->front + 1) % MAXQSIZE;
    return OK;
}

QElemType GetHead(SqQueue Q) 
{
    if (Q.front != Q.rear) 
    { // 队列不为空
        return Q.base[Q.front]; // 返回值
    }
    // 处理空队列
    return -1; // 或其他适当值
}

void DestroyQueue(SqQueue *Q) 
{
    free(Q->base);
    Q->base = NULL;
    Q->front = Q->rear = 0;
}

int main() 
{
    SqQueue Q;
    InitQueue(&Q);
    EnQueue(&Q, 1);
    EnQueue(&Q, 2);
    EnQueue(&Q, 3);

    printf("队列长度: %d\n", QueueLength(Q));

    QElemType head;
    if (DeQueue(&Q, &head)) 
    {
        printf("出队元素: %d\n", head);
    }

    printf("出队后队列长度: %d\n", QueueLength(Q));

    printf("队列头部元素: %d\n", GetHead(Q));

    DestroyQueue(&Q);

    return 0;
}

```



#### 课外拓展题：

##### 判断字符串回文：

```c
#include <stdio.h>
#include <stdlib.h>

/* run this program using the console pauser or add your own getch, system("pause") or input loop */


#define MAXSIZE 100
#define OVERFLOW -1
#define ERROR 0
#define OK 1

typedef struct
{
    char *base;
    char *top;
    int stackSize;
}SqStack;

typedef struct
{
    char *base;
    int front;
    int rear;
}SqQueue;

void InitStack(SqStack *S)
{
    S->base = (char*)malloc(sizeof (char)*MAXSIZE);
    if(!S->base)
    {
        return;
    }
    S->top = S->base;
    S->stackSize = MAXSIZE;
    return ;
}
void Push(SqStack *S,char e)
{
    if(S->top - S->base == S->stackSize)
    {
        return ;
    }
    *S->top ++= e;
}

void Pop(SqStack *S,char*e)
{
    if(S->top - S->base == 0)
    {
        return;
    }
    *e = *--S->top;
}


void InitQueue(SqQueue *Q)
{
    Q->base = (char *) malloc(MAXSIZE*sizeof (char));
    if(!Q->base)
    {
        return ;
    }
    Q->front = Q->rear = 0;
}

void EnQueue(SqQueue *Q,char e)
{
    if((Q->rear + 1)%MAXSIZE == Q->front)
    {
        printf("队列已满\n");
        return ;
    }
    Q->base[Q->rear] = e;
    Q->rear = (Q->rear + 1 )% MAXSIZE;
}
void DeQueue(SqQueue *Q,char *e)
{
    if(Q->front == Q->rear)
    {
        printf("队列为空\n");
        return ;
    }
    *e = Q->base[Q->front];
    Q->front = (Q->front + 1)%MAXSIZE;
}


int main(int argc, char *argv[])
{
    SqStack S;
    SqQueue Q;
    InitStack(&S);
    InitQueue(&Q);
    char s,c,q;
    while((c = getchar())!= '@')
    {
        Push(&S,c);
        EnQueue(&Q,c);
    }
    while(0 != S.top - S.base)
    {
        Pop(&S,&s);
        DeQueue(&Q,&q);
        if(s != q)
        {
            printf("不是回文字符串\n");
            return 0;
        }
    }
    printf("是回文字符串\n");
    return 0;
}
```

##### 医院排队：

```c
#include <stdio.h>
#include <malloc.h>
#include <string.h>

typedef int QElemType ;
typedef int Status;

#define ERROR 0
#define OK 1
#define MAXSIZE 100

typedef struct
{
    QElemType *base;
    int front;
    int rear;
}SqQueue;

void InitQueue(SqQueue *Q)
{
    Q->base = (int*) malloc(sizeof (int)*MAXSIZE);
    if(!Q->base)
    {
        return ;
    }
    Q->front = 0 ;
	Q->rear = 0;
}

int QueueLength(SqQueue Q)
{
    return ((Q.rear - Q.front + MAXSIZE) % MAXSIZE);
}

void EnQueue(SqQueue *Q,QElemType e)
{
    if((Q->rear + 1) %MAXSIZE == Q->front)
    {
        return ;
    }
    Q->base[Q->rear] = e;
    Q->rear = (Q->rear + 1)%MAXSIZE;
}

void DeQueue(SqQueue *Q,QElemType *e)
{
    if(Q->front == Q->rear)
    {
        return;
    }
    *e = Q->base[Q->front];
    Q->front = (Q->front - 1)%MAXSIZE;
}


void SeeDoctor()
{
    SqQueue Q;
    int n;
    InitQueue(&Q);
    int flag = 1;
    while(flag)
    {
    	char ch;
        printf("请输入命令\n");
        scanf("%c",&ch);
        getchar();
        switch(ch)
        {
            case 'a' :
	            {
	                printf("病例号：\n");
	                scanf("%d",&n);
	                getchar();
	                EnQueue(&Q,n);
	                break;
	            }
            case 'n':
            {
                if(QueueLength(Q) != 0)
                {
                    DeQueue(&Q,&n);
                    printf("病历号为%d的病人就诊\n",n);
                }
                else
                {
                    printf("无病人等待就诊\n");
                }
                break;
            }
            case 'q':
            {
                printf("今天停止挂号，下列病人依次就诊\n");
                while(QueueLength(Q) == 0)
                {
                    DeQueue(&Q,&n);
                    printf("%d",n);
                }
                flag = 0;
                break;
            }
            default:
                break;
        }
    }
}

int main()
{
    SeeDoctor();
    return 0;
}
```



#### 1. 基于顺序表的队列基本操作

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1

typedef int QElemType;
typedef int Status;

#define MAXQSIZE 100

typedef struct {
    QElemType *base;
    int front;
    int rear;
} SqQueue;

Status InitQueue(SqQueue *Q) 
{
    Q->base = (QElemType*)malloc(MAXQSIZE * sizeof(QElemType));
    if (!Q->base) 
    {
        exit(ERROR);
    }
    Q->front = Q->rear = 0;
    return OK;
}

Status QueueEmpty(SqQueue Q) 
{
    return Q.front == Q.rear ? OK : ERROR;
}

int QueueLength(SqQueue Q) 
{
    return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;
}

Status GetHead(SqQueue Q, QElemType *e) 
{
    if (QueueEmpty(Q)) 
    {
        return ERROR;
    }
    *e = Q.base[Q.front];
    return OK;
}

Status DeQueue(SqQueue *Q, QElemType *e) 
{
    if (QueueEmpty(*Q)) 
    {
        return ERROR;
    }
    *e = Q->base[Q->front];
    Q->front = (Q->front + 1) % MAXQSIZE;
    return OK;
}

Status EnQueue(SqQueue *Q, QElemType e) 
{
    if ((Q->rear + 1) % MAXQSIZE == Q->front) 
    {
        return ERROR;
    }
    Q->base[Q->rear] = e;
    Q->rear = (Q->rear + 1) % MAXQSIZE;
    return OK;
}

void PrintQueue(SqQueue Q) 
{
    int i = Q.front;
    while (i != Q.rear) 
    {
        printf("%d ", Q.base[i]);
        i = (i + 1) % MAXQSIZE;
    }
    printf("\n");
}

int main() 
{
    SqQueue Q;
    InitQueue(&Q);
    int e;
    while (1) 
    {
        scanf("%d", &e);
        if (e == -1) 
        {
            break;
        }
        EnQueue(&Q, e);
    }
    PrintQueue(Q);
    printf("%d\n", QueueLength(Q));
    int n = QueueLength(Q);
    for (int i = 0; i < n; ++i) 
    {
        if (DeQueue(&Q, &e)) 
        {
            printf("%d ", e);
        }
    }
    printf("\n");
    return OK;
}

```



#### 2. 基于链表的队列合并



```c
//自己写的代码及老师给的代码模板
#include <stdio.h>  
#include <stdlib.h>  
#include <malloc.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef struct 
{
    char name;    
    int arriveTime;  
} QElemType;

typedef int Status;

typedef struct Qnode 
{
    QElemType   data;
    struct Qnode* next;
} QNode, * QueuePtr;

typedef struct
{
    QueuePtr  front;  //front pointer
    QueuePtr  rear;   //rear pointer
} LinkQueue;

Status InitQueue(LinkQueue* Q)
{
    Q->front = (QNode*)malloc(sizeof(QNode));
    if (Q->front == NULL)
        return ERROR;
    Q->rear = Q->front;
    Q->rear->next = NULL;
    return OK;
}

Status QueueEmpty(LinkQueue Q)
{
    if (Q.front == Q.rear)
        return OK;
    else
        return ERROR;
}

int QueueLength(LinkQueue Q) 
{
    QNode* p;
    p = Q.front->next;
    int length = 0;
    for (; p->next != NULL; p = p->next)
        length++;
    return length;
}

Status GetHead(LinkQueue Q, QElemType* e) 
{
    if (Q.front == Q.rear)
        return ERROR;
    *e = Q.front->next->data;
    return OK;
}

Status DeQueue(LinkQueue *Q, QElemType* e) 
{
    QNode* p;
    if (Q->front == Q->rear)
        return ERROR;
    p = Q->front->next;
    *e = Q->front->next->data;
    Q->front->next = Q->front->next->next;
    if (p == Q->rear)
        Q->rear = Q->front;
    return OK;
}

Status EnQueue(LinkQueue* Q, QElemType e) 
{
    QNode* p;
    p = (QNode*)malloc(sizeof(QNode));
    if (p == NULL)
        return ERROR;
    p->data = e;
    p->next = NULL;
    Q->rear->next = p;
    Q->rear = Q->rear->next;
    return OK;
}

void PrintQueue(LinkQueue Q) 
{
    QNode* p;
    p = Q.front->next;
    while (p != NULL) 
    {
        printf("(%c,%d)\n", p->data.name, p->data.arriveTime);
        p = p->next;
    }
}

void mergeQueue(LinkQueue *Q1, LinkQueue* Q2, LinkQueue* Q3) 
{
    QElemType e1,e2,e3;
    while(!QueueEmpty(*Q1) && !QueueEmpty(*Q2))
    {
        GetHead(*Q1,&e1);
        GetHead(*Q2,&e2);
        if(e1.arriveTime > e2.arriveTime)  
        {
            EnQueue(Q3,e2);
            DeQueue(Q2,&e2);
        }
        else 
        {
             EnQueue(Q3,e1);
             DeQueue(Q1,&e1);
        }
    }
    while(!QueueEmpty(*Q1))
    {
        GetHead(*Q1,&e1);
        EnQueue(Q3,e1);
        DeQueue(Q1,&e1);
    }
    while(!QueueEmpty(*Q2))
    {
        GetHead(*Q2,&e2);
        EnQueue(Q3,e2);
        DeQueue(Q2,&e2);
    }
}

int main()
{
    LinkQueue Q1, Q2, Q3;
    char c;
    int length1, length2;
    QElemType QData;
    InitQueue(&Q1);
    InitQueue(&Q2);
    InitQueue(&Q3);
    scanf("%d", &length1);
    c=getchar();
    int i = 0;
    for (; i <= length1 - 1; i++) 
    {
        scanf("%c%d", &QData.name, &QData.arriveTime);
        EnQueue(&Q1, QData);
        c = getchar();
    }
    scanf("%d", &length2);
    c = getchar();
    for (i = 0; i <= length2 - 1; i++)
    {
        scanf("%c%d", &QData.name, &QData.arriveTime);
        EnQueue(&Q2, QData);
        c = getchar();
    }
    mergeQueue(&Q1, &Q2, &Q3);
    printf("%d\n", length1 + length2);
    PrintQueue(Q3);
}

```



```c
//AI优化后的代码
#include <stdio.h>  
#include <stdlib.h>  

#define ERROR 0
#define OK 1

typedef struct {
    char name;    
    int arriveTime;  
} QElemType;

typedef int Status;

typedef struct Qnode {
    QElemType   data;
    struct Qnode* next;
} QNode, * QueuePtr;

typedef struct {
    QueuePtr  front;  //front pointer
    QueuePtr  rear;   //rear pointer
    int length;       // Length of the queue
} LinkQueue;

// initialization of linked list based queue
Status InitQueue(LinkQueue* Q) 
{
    Q->front = (QNode*)malloc(sizeof(QNode));
    if (Q->front == NULL)
        return ERROR;
    Q->rear = Q->front;
    Q->rear->next = NULL;
    Q->length = 0; // Initialize length to 0
    return OK;
}

// Test empty queue
Status QueueEmpty(LinkQueue Q) 
{
    if (Q.front == Q.rear)
        return OK;
    else
        return ERROR;
}

// Get the length of a queue
int QueueLength(LinkQueue Q) 
{
    return Q.length; // Return length directly
}

// Get front item of a queue
Status GetHead(LinkQueue Q, QElemType* e) 
{
    if (Q.front == Q.rear)
        return ERROR;
    *e = Q.front->next->data;
    return OK;
}

// Delete an item from the queue
Status DeQueue(LinkQueue *Q, QElemType* e) 
{
    QNode* p;
    if (Q->front == Q->rear)
        return ERROR;
    p = Q->front->next;
    *e = Q->front->next->data;
    Q->front->next = Q->front->next->next;
     /*下一行是检查被出队的节点 (p) 是否是队列中唯一的节点。
	如果 p 是队列中唯一的节点，意味着在出队这个节点后，队列将变为空。在这种情况下，队列的前后指针都应该指向同一个节点（即头节点）。这是因为在空队列中，前后指针都应该指向同一个节点以表示队列为空。*/
    if (p == Q->rear)
        Q->rear = Q->front;
    Q->length--; // Update length
    free(p); // Free memory
    return OK;
}

// Insert an item into the queue
Status EnQueue(LinkQueue* Q, QElemType e) 
{
    QNode* p;
    p = (QNode*)malloc(sizeof(QNode));
    if (p == NULL)
        return ERROR;
    p->data = e;
    p->next = NULL;
    Q->rear->next = p;
    Q->rear = Q->rear->next;
    Q->length++; // Update length
    return OK;
}

// Print the elements in a queue
void PrintQueue(LinkQueue Q) 
{
    QNode* p;
    p = Q.front->next;
    while (p != NULL) {
        printf("(%c,%d)\n", p->data.name, p->data.arriveTime);
        p = p->next;
    }
}

// Merge two queues
void mergeQueue(LinkQueue *Q1, LinkQueue* Q2, LinkQueue* Q3) 
{
    QElemType e1, e2;
    while (!QueueEmpty(*Q1) && !QueueEmpty(*Q2)) 
    {
        GetHead(*Q1, &e1);
        GetHead(*Q2, &e2);
        if (e1.arriveTime > e2.arriveTime) 
        {
            EnQueue(Q3, e2);
            DeQueue(Q2, &e2);
        } 
        else 
        {
            EnQueue(Q3, e1);
            DeQueue(Q1, &e1);
        }
    }
    while (!QueueEmpty(*Q1)) 
    {
        GetHead(*Q1, &e1);
        EnQueue(Q3, e1);
        DeQueue(Q1, &e1);
    }
    while (!QueueEmpty(*Q2)) 
    {
        GetHead(*Q2, &e2);
        EnQueue(Q3, e2);
        DeQueue(Q2, &e2);
    }
}

int main() 
{
    LinkQueue Q1, Q2, Q3;
    char c;
    int length1, length2;
    QElemType QData;
    
    // Initialize queues
    InitQueue(&Q1);
    InitQueue(&Q2);
    InitQueue(&Q3);

    // Input for queue 1
    scanf("%d", &length1);
    c = getchar(); // consume newline character
    for (int i = 0; i < length1; i++) 
    {
        scanf("%c%d", &QData.name, &QData.arriveTime);
        EnQueue(&Q1, QData);
        c = getchar(); // consume newline character
    }

    // Input for queue 2
    scanf("%d", &length2);
    c = getchar(); // consume newline character
    for (int i = 0; i < length2; i++) 
    {
        scanf("%c%d", &QData.name, &QData.arriveTime);
        EnQueue(&Q2, QData);
        c = getchar(); // consume newline character
    }

    // Merge queues
    mergeQueue(&Q1, &Q2, &Q3);

    // Output total length and merged queue
    printf("%d\n", length1 + length2);
    PrintQueue(Q3);

    return 0;
}
```



#### 3. 队列9-约瑟夫环问题

```c
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 36 //存储空间的初始分配量 

typedef struct {
    int data[MAXSIZE];
    int front;
    int rear;
} SqQueue; 

void InitQueue(SqQueue *Q) 
{
    Q->front = Q->rear = 0;
}

int QueueLength(SqQueue Q) 
{
    return ((Q.rear - Q.front + MAXSIZE) % MAXSIZE);
}

void EnQueue(SqQueue *Q, int e) 
{
    if ((Q->rear + 1) % MAXSIZE == Q->front) return; // 队列已满
    Q->data[Q->rear] = e;
    Q->rear = (Q->rear + 1) % MAXSIZE;
}

void DeQueue(SqQueue *Q, int *e) 
{
    if (Q->front == Q->rear) return; // 队列为空
    *e = Q->data[Q->front];
    Q->front = (Q->front + 1) % MAXSIZE;
}

void joseph_ring(int n, int m, int k) 
{
    SqQueue Q;
    InitQueue(&Q);
    int i, e;
    for (i = 0; i < n; i++) 
    {
        EnQueue(&Q, i + 1);
    }
    for (i = 0; i < k - 1; i++) 
    {
        int e;
        DeQueue(&Q, &e);
        EnQueue(&Q, e);
    }
    while (QueueLength(Q)) 
    {
        for (i = 0; i < m - 1; i++) 
        {
            DeQueue(&Q, &e);
            EnQueue(&Q, e);
        }
        DeQueue(&Q, &e);
        printf("%d ", e);
    }
    printf("\n");
}

int main(int argc, char *argv[]) 
{
    int m, n, k;
    scanf("%d%d%d", &n, &m, &k);
    joseph_ring(n, m, k);
    return 0;
}

```



#### 4. 队列7-杨辉三角

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

typedef struct {
    int data[MAX_SIZE];
    int front;
    int rear;
} Queue;

void initQueue(Queue *q) {
    q->front = q->rear = 0;
}

int isEmpty(Queue *q) {
    return q->front == q->rear;
}
int QueueLength(Queue Q)
{
    return (Q.rear - Q.front+ MAX_SIZE )%MAX_SIZE;
}

void enqueue(Queue *q, int value) {
    if(QueueLength(*q) == MAX_SIZE - 1)	return ;
    q->data[q->rear] = value;
    q->rear = (q->rear + 1) % MAX_SIZE;
}

int dequeue(Queue *q) {
    if(isEmpty(q))	return 0;
    int value = q->data[q->front];
    q->front = (q->front + 1) % MAX_SIZE;
    return value;
}

void printYanghuiTriangle(int n) {
    Queue q;
    initQueue(&q);
    
    enqueue(&q, 1);  // 第一行的1
    
    for (int i = 0; i < n; i++) {
        int previous = 0;
        for (int j = 0; j <= i; j++) {
            int current = dequeue(&q);
            printf("%4d", current);
            
            // 计算下一行的数字并入队
            enqueue(&q, current + previous);
            previous = current;
        }
        enqueue(&q, 1);  // 每行最后一个数字是1
        printf("\n");
    }
}

int main() {
    int n;
    //printf("请输入一个数字(2到9之间): ");做题时要加入判断
    scanf("%d", &n);

    printYanghuiTriangle(n);

    return 0;
}

```



#### 5. 数据结构和ACM2023-第四章-循环队列判断回文- LJD

```c
#include "stdio.h"
#include "stdlib.h"
#include "string.h"

#define OK 1
#define ERROR 0
#define TURE 1
#define FALSE 0
#define MAXSIZE 36 //存储空间的初始分配量

typedef int Status;
typedef char QElemType;

typedef struct {
    QElemType data[MAXSIZE];
    int front;
    int rear;
} SqQueue;

int QueueLength(SqQueue Q) 
{
    return ((Q.rear - Q.front + MAXSIZE) % MAXSIZE); 
}

Status EnQueue(SqQueue *Q, QElemType d) 
{
    if (QueueLength(*Q) == MAXSIZE) 
    {
        return ERROR;
    }
    Q->data[Q->rear] = d;
    Q->rear = (Q->rear + 1) % MAXSIZE;
    return OK;
}

Status DeQueue(SqQueue *Q, QElemType *d) 
{
    if (!QueueLength(*Q)) 
    {
        return ERROR;
    }
    *d = Q->data[Q->front];
    Q->front = (Q->front + 1) % MAXSIZE;
    return OK;
}

int main() 
{
    int i, j, d = 1;
    char a[20];
    SqQueue Q;
    Q.front = 0;
    Q.rear = 0;

    for (i = 0;; i++) 
    {
        scanf("%c", &a[i]);
        if (a[i] == '@')
            break;
        else
            EnQueue(&Q, a[i]);
    }

    j = QueueLength(Q);

    for (i = 0; i < (j + 1) / 2; i++) 
    {
        if (Q.data[Q.front + i] == Q.data[Q.rear - i - 1])
            d = 1;
        else 
        {
            d = 0;
            break;
        }
    }

    if (d == 0)  
    {
        printf("此字符串不是回文\n");
    }
    else if (d == 1) 
    {
        printf("此字符串为回文\n");
    }

    return 0;
}
```



#### 6. 队列实验

```c
#include <stdio.h>
#include "stdlib.h"
#include <malloc.h>
#include <string.h>

#define OK 1
#define ERROR 0
#define OVERFLOW -1
#define TRUE 1
#define FALSE -2

/*定义队列节点结构体类型、和队列节点结构体指针类型*/ 
typedef struct QUEUE_NODE 
{ 
	int data;
	struct QUEUE_NODE *next; 
//    补充完整
} QUEUE_NODE, *QUEUE_NODE_PTR; 

/*队列结构体类型、和队列结构体指针类型定义，包括：
  队列真实长度；
  队头位置指针；
  队尾位置指针*/ 
typedef struct 
{ 
    int Len; 
    QUEUE_NODE_PTR front;
    QUEUE_NODE_PTR rear;
//    补充完整
} LINK_QUEUE, *LINK_QUEUE_PTR; 

/*队列初始化函数，要求生成头结点，并将队列头指针、尾指针和长度正确赋值*/ 
int InitQueue(LINK_QUEUE *q) 
{  
	q->front = (QUEUE_NODE_PTR)malloc(sizeof(QUEUE_NODE));
	if(!q->front) return ERROR;
	q->rear = q->front;
	q->rear->next = NULL;
	return OK;
//    补充完整
    return 1; /*初始化成功返回1*/ 
} 

/*.队列判空函数，要求：
函数接口定义为：int IsQueueEmpty(LINK_QUEUE *q)；
2.输入参数：待判空队列q；
3 处理规则及返回值：通过队列长度元素判空。
                     队列为空返回1；队列非空返回0.*/
int IsQueueEmpty(LINK_QUEUE *q) 
{ 
	return ((q->Len == 0)?1:0); 
//    补充完整
}

/*.入队列函数，要求：
1.函数接口定义为：int EnQueue(LINK_QUEUE *q, int MRN)；
2.输入参数：待操作队列名q，待入队列数值（病例号）MRN；
3 处理规则及返回值：从内存堆中申请一个队列结点大小的存储空间作为新的队列结点newNode，给节点数据域赋值MRN，指针域为空。
    将队列队尾结点的指针域指向新节点newNode，队尾指针指向新节点newNode。
    入队列成功时返回1，入队列失败时返回0.*/
int EnQueue(LINK_QUEUE *q, int MRN) 
{ 
	QUEUE_NODE_PTR p ;
	p = (QUEUE_NODE_PTR)malloc(sizeof(QUEUE_NODE));
	if(!p)	return ERROR;
	p->data = MRN;
	p->next = q->rear->next;
	q->rear->next = p;
	q->rear = q->rear->next;
	q->Len ++;
	return OK;
//    补充完整
} 
 

/*.出队列函数，要求：
.函数接口定义为：int DeQueue(LINK_QUEUE *q)；
2.输入参数：待操作队列q；
3 处理规则及返回值：取队头节点，将其数据域数值作为返回值输出。
                     删除队头结点，并将头节点的next指针指向新的队头节点；
                     当出队列失败时返回0；成功时返回原队头结点的数据域数值。*/
int DeQueue(LINK_QUEUE *q) 
{  
	if(IsQueueEmpty(q))	return ERROR;
    int mn;
    QUEUE_NODE_PTR p = q->front->next;
    mn = p->data;
    q->front->next = q->front->next->next;
	if(p == q->rear ) q->rear = q->front;
	q->Len --;
	free(p);	 
//    补充完整
    return mn;//返回原队头结点的病历号 
} 

/*.销毁队列函数，要求：
函数接口定义为：int DestroyQueue(LINK_QUEUE *q)
2.输入参数：待销毁队列q；
3 处理规则及返回值：在队尾指针的辅助下，从头至尾逐一释放队列结点空间。
                     销毁成功返回1；否则，返回0.*/
int DestroyQueue(LINK_QUEUE *q) 
{ 
    /*一般防护：如果队列不存在，返回错误*/ 
    if(q->front == NULL) 
    { 
        return 0; 
    } 
    /*在队尾指针的辅助下，从头至尾逐一释放队列结点空间*/
    while(q->Len)
    {
    	DeQueue(q);
	}
    q->front = q->rear = NULL; 
//    补充完整
    return 1; 
} 

/*.队列遍历函数，要求：
.函数接口定义为：int QTraverse(LINK_QUEUE *q)
2.输入参数：进行遍历的队列q；
3 处理规则及返回值：从首至尾遍历队列，依次打印输出所有队列结点数据域数值。数值之间间隔一个制表符位置；
                     遍历成功返回1；队列不存在或为空返回0*/
int QTraverse(LINK_QUEUE *q) 
{ 
    QUEUE_NODE_PTR p; 
    /*队列不存在或为空返回0*/ 
    if(q->front == NULL || q->Len == 0) 
    { 
        return 0; 
    } 
    /*从队列第一个元素开始遍历队列，依次打印输出所有队列结点数据域数值，每次循环结束p后移一个节点*/ 
    for(p=q->front->next; p!=NULL; p= p->next) 
    { 
        printf("%d\t", p->data); 
    } 
    return 1; 
} 

/**************************************************************************/ 
/*                                                                        */ 
/**************************************************************************/ 

int main() 
{ 
    LINK_QUEUE QPatient ={0};//定义病人队列 
    int flag = 1; /*上下班标志位： 1为上班，0为下班*/ 
    int Medical_Record_NO = 0; 
    char ch = 0; 
    char a[100];
    int length;
    int index;
    //初始化病人对列 
    InitQueue(&QPatient); 
    //输入处理命令 
    gets(a); 
    length = strlen(a); 
    index = 0; 
    /*上班时，依次处理各个输入命令*/ 
    while( (flag==1) && (index<length) ) 
    { 
        ch = a[index] &0xff; /*从控制台接收命令*/ 
        index++; 
        switch (ch) 
        { 
            case 'a': 
                /*新增病人排至队尾*/ 
                Medical_Record_NO=Medical_Record_NO+1;  /*记录病人数量*/
                EnQueue(&QPatient, Medical_Record_NO); 
                printf("\nYour patient's No. is:%d.\t", Medical_Record_NO); 
                printf("There are %d patient(s) waiting ahead of you.", QPatient.Len); 
                break; 
            case 'n': 
                /*队头病人出队看病*/ 
                if(!IsQueueEmpty(&QPatient)) 
                { 
                    Medical_Record_NO = DeQueue(&QPatient); 
                    printf("\nPatient No. %d, please go to the clinic", Medical_Record_NO); 
                } 
                else 
                { 
                    printf("\n No patient is waiting in line.\n"); 
                } 
                break; 
            case 'q': 
                /*下班：如果队列中还有病人则依次出队，否则打印hello*/ 
                if(!IsQueueEmpty(&QPatient)) 
                { 
                    printf("\nIt is the end of today. Following patients please go to the clinic in turn: "); 
                    QTraverse(&QPatient); 
                    printf("\n"); 
                } 
                else 
                {                    
                    printf("hello\n"); 
                } 
                flag = 0;//置下班标志 
                //销毁队列 
                DestroyQueue(&QPatient); 
                break; 
            default: 
                printf("ERROR\n"); 
                break; 
        }// end of switch(ch) 
    }//end of while() 
    return 0; 
} 

```



### 作业6——串

#### 学习代码：

##### 定长顺序存储：

```c
#include <stdio.h>
#include <string.h>

#define MAXSTRLEN 255
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

typedef int Status;
typedef unsigned char SString[MAXSTRLEN + 1];

// Function to clear the string
Status ClearString(SString S) {
    S[0] = '\0';
    return OK;
}

// Function to get the length of the string
int StrLength(SString S) {
    return S[0];
}

// Function to check if the string is empty
Status StrEmpty(SString S) {
    return (S[0] == 0) ? TRUE : FALSE;
}

// Function to assign a character array to the string
Status StrAssign(SString T, char *chars) {
    int len = strlen(chars);
    
    //在不能使用 strlen函数的情况下，求chars的长度i
    //for(int i = 0,c = chars;*c != '\0';++i, ++c)    
    
    if (len > MAXSTRLEN) return ERROR;
    T[0] = len;
    for (int i = 1; i <= len; i++) {
        T[i] = *(chars + i - 1);
    }
    return OK;
}

// Function to copy one string to another
Status StrCopy(SString T, SString S) {
    for (int i = 0; i <= S[0]; i++) {
        T[i] = S[i];
    }
    return OK;
}

// Function to compare two strings
int StrCompare(SString S, SString T) {
    for (int i = 1; i <= S[0] && i <= T[0]; ++i) {
        if (S[i] != T[i]) return S[i] - T[i];
    }
    return S[0] - T[0];
}

// Function to concatenate two strings
Status Concat(SString T, SString S1, SString S2) {
    if (S1[0] + S2[0] <= MAXSTRLEN) {//未截断
        StrCopy(T, S1);
        for (int i = 1; i <= S2[0]; i++) {
            T[S1[0] + i] = S2[i];
        }
        T[0] = S1[0] + S2[0];
        return OK;
    } 
    else {
        return ERROR;
    }
}

Status Concat(SString T, SString S1, SString S2) 
{
    StrCopy(T, S1);
    memmove(T + S1[0] + 1, S2 + 1, MAXSTRLEN - S1[0]);
    if (S1[0] + S2[0] <= MAXSTRLEN) 
    {
        T[0] = S1[0] + S2[0];
        return OK;
    } 
    else 
    {
        T[0] = MAXSTRLEN;
        T[MAXSTRLEN] = '\0';
        return ERROR;
    }
}


// Function to concatenate two strings
Status Concat(SString T, SString S1, SString S2) {
    if (S1[0] + S2[0] <= MAXSTRLEN) 
    { // 未截断
        StrCopy(T, S1);
        for (int i = 1; i <= S2[0]; i++) 
        {
            T[S1[0] + i] = S2[i];
        }
        T[0] = S1[0] + S2[0];
        return OK;
    } 
    else 
    {
            StrCopy(T, S1);
            for (int i = 1; i <= MAXSTRLEN - S1[0]; i++) 
            {
                T[S1[0] + i] = S2[i];
            }
            T[0] = MAXSTRLEN; // 设置T的长度为最大长度
         	T[MAXSTRLEN] = '\0'; // 添加字符串结束符
            return ERROR;
    }
}



// Function to extract a substring from a string
Status SubString(SString Sub, SString S, int pos, int len) {
    if (pos < 1 || pos > S[0] || len < 0 || pos + len - 1 > S[0]) return ERROR;
    for (int i = 1; i <= len; i++) {
        Sub[i] = S[pos + i - 1];
    }
    Sub[0] = len;
    return OK;
}

// Function to insert a string into another string at a specified position
Status StrInsert(SString S, int pos, SString T) {
    if (pos < 1 || pos > S[0] + 1) return ERROR;
    if (S[0] + T[0] <= MAXSTRLEN) {//完全插入
        for (int i = S[0]; i >= pos; i--) {
            S[i + T[0]] = S[i];
        }
        for (int i = pos; i < pos + T[0]; i++) {
            S[i] = T[i - pos + 1];
        }
        S[0] = S[0] + T[0];
        return OK;
    } 
    else 
    {//部分插入
        //这段貌似也没什么用，后续还是被T给替换掉了
        // 	        for (int i = MAXSTRLEN; i >= pos + T[0]; i--) {
		//            S[i] = S[i - T[0]];
		//        }

        for (int i = pos; i < pos + T[0]; i++) {
            S[i] = T[i - pos + 1];
        }
        S[0] = MAXSTRLEN;
        return ERROR;
    }
}

// Function to delete a substring from a string
Status StrDelete(SString S, int pos, int len) {
    if (pos < 1 || pos + len - 1 > S[0] || len < 0) return ERROR;
    for (int i = pos + len; i <= S[0]; i++) {
        S[i - len] = S[i];
    }
    S[0] -= len;
    return OK;
}

// Function to find the first occurrence of a substring in a string
int Index(SString S, SString T, int pos) {
    int n, m;
    if (pos < 0) return ERROR;
    n = StrLength(S);
    m = StrLength(T);
    int i = pos;
    while (i <= n - m + 1) {
        SString sub;
        SubString(sub, S, i, m);
        if (StrCompare(sub, T) != 0) {
            ++i;
        } else {
            return i;
        }
    }
    return 0;
}

// Function to replace all occurrences of a substring in a string with another substring
Status Replace(SString S, SString T, SString V) {
    int i = 1;
    if (StrEmpty(T)) return ERROR;
    do {
        i = Index(S, T, i);
        if (i) {
            StrDelete(S, i, StrLength(T));
            StrInsert(S, i, V);
            i += StrLength(V);
        }
    } while (i);
    return OK;
}

int main() {
    SString s, t, v;

    // Example usage
    StrAssign(s, "Hello");
    StrAssign(t, "l");
    StrAssign(v, "XYZ");

    Replace(s, t, v);

    printf("%s\n", s + 1); // Output should be "HeXYZo"

    return 0;
}
```

##### 堆分配存储表示：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef int Status;

#define MAXSTRLEN 255

#define OK 1
#define ERROR 0
#define FALSE -1
#define TRUE 2
#define OVERFLOW -2

typedef struct {
    char *ch;   // Pointer to the dynamic array storing the characters of the string
    int length; // Length of the string
} HString;

// Function to initialize a string
Status InitString(HString *T) {
    T->length = 0;
    T->ch = NULL;
    return OK;
}

// Function to clear the string
Status ClearString(HString *S) {
    if (S->ch) {
        free(S->ch);
        S->ch = NULL; // Set the pointer to NULL after freeing the memory
        S->length = 0;
    }
    return OK;
}

// Function to assign a character array to a string
Status StrAssign(HString *T, char *chars) {
    int i = strlen(chars);
    if (!i) {
        T->ch = NULL;
        T->length = 0;
    } else {
        T->ch = (char*)malloc((i + 1) * sizeof(char)); // Allocate memory for the string including '\0'
        if (!T->ch) exit(OVERFLOW);
        strcpy(T->ch, chars); // Use strcpy to copy characters from chars to T->ch
        T->length = i;
    }
    return OK;
}

// Function to copy a string
Status StrCopy(HString *T, HString S) {
    T->ch = (char*)malloc((S.length + 1) * sizeof(char)); // Allocate memory for the string including '\0'
    if (!T->ch) return ERROR;
    strcpy(T->ch, S.ch); // Use strcpy to copy characters from S.ch to T->ch
    T->length = S.length;
    return OK;
}

// Function to check if a string is empty
Status StrEmpty(HString S) {
    return (S.length == 0 && S.ch == NULL) ? TRUE : FALSE;
}

// Function to get the length of a string
int StrLength(HString S) {
    return S.length;
}

// Function to compare two strings

//使用strcmp函数的字符串比较
//int StrCompare(HString S, HString T) {
//    return strcmp(S.ch, T.ch); // Use strcmp to compare strings
//}

//不使用函数的字符串比较
int StrCompare(HString S, HString T) {
    int i = 0;
    while (S.ch[i] != '\0' && T.ch[i] != '\0') {
        if (S.ch[i] != T.ch[i]) {
            return S.ch[i] - T.ch[i];
        }
        i++;
    }
    // 如果两个字符串中的所有字符都相等，但其中一个字符串长度更长，则返回长度差值
    return S.length - T.length;
}

// Function to insert a string into another string at a specified position
Status StrInsert(HString *S, int pos, HString T) {
    if (pos < 1 || pos > S->length + 1) return ERROR;
    if (T.length) 
    {
        S->ch = (char*)realloc(S->ch, (S->length + T.length + 1) * sizeof(char)); // Reallocate memory
        if (!S->ch) return ERROR;
        
        memmove(S->ch + pos + T.length - 1, S->ch + pos - 1, (S->length - pos + 2) * sizeof(char)); // Move characters to make space for insertion
      
        memcpy(S->ch + pos - 1, T.ch, T.length * sizeof(char)); // Copy characters of T to the specified position in S
        S->length += T.length;
    }
    return OK;
}

Status StrInsert(HString *S, int pos, HString T) {
    if (pos < 1 || pos > S->length + 1) return ERROR; // 检查插入位置是否合法
    if (T.length) {
        // 重新分配内存空间
        S->ch = (char*)realloc(S->ch, (S->length + T.length + 1) * sizeof(char));
        if (!S->ch) return ERROR; // 内存分配失败
        
        // 后移字符以腾出插入位置
        for (int i = S->length; i >= pos; i--) {
            S->ch[i + T.length] = S->ch[i - 1];
        }
        
        // 插入字符串T
        for (int i = 0; i < T.length; i++) {
            S->ch[pos + i - 1] = T.ch[i];
        }
        
        S->length += T.length; // 更新长度
    }
    return OK;
}


// Function to delete a substring from a string
Status StrDelete(HString *S, int pos, int len) {
    if (pos < 1 || pos + len - 1 > S->length) return ERROR;
    memmove(S->ch + pos - 1, S->ch + pos + len - 1, (S->length - pos - len + 2) * sizeof(char)); // Move characters to remove the substring
    S->length -= len;
    S->ch = (char*)realloc(S->ch, (S->length + 1) * sizeof(char)); // Reallocate memory
    return OK;
}

// Function to replace all occurrences of a substring in a string with another substring
Status Replace(HString *S, HString T, HString V) {
    int i = 1;
    if (StrEmpty(T)) return ERROR;
    do {
        i = StrIndex(*S, T, i); // Call StrIndex function
        if (i) {
            StrDelete(S, i, T.length);
            StrInsert(S, i, V);
            i += V.length;
        }
    } while (i);
    return OK;
}

// Function to find the first occurrence of a substring in a string
int StrIndex(HString S, HString T, int pos) {
    int i = pos, j = 1;
    while (i <= S.length && j <= T.length) {
        if (S.ch[i - 1] == T.ch[j - 1]) {
            ++i;
            ++j;
        } 
        else {
            i = i - j + 2;
            j = 1;
        }
    }
    if (j > T.length) return i - T.length;
    else return 0;
}

int main() {
    HString s, t, v;

    // Initialize strings
    InitString(&s);
    InitString(&t);
    InitString(&v);

    // Assign values to strings
    StrAssign(&s, "Hello");
    StrAssign(&t, "l");
    StrAssign(&v, "XYZ");

    // Replace all occurrences of string t in string s with string v
    Replace(&s, t, v);

    // Output the modified string s
    printf("%s\n", s.ch);

    // Clear memory
    ClearString(&s);
    ClearString(&t);
    ClearString(&v);

    return 0;
}
```



##### BF算法：

```c
int Index(SString S,SString T,int pos)
{
    if(pos >= 1 && pos <= S[0])
    {
        int i = pos;
        int j = 1;
        while(i <= S[0] && j <= T[0])
        {
            if(S[i] == T[j])
            {
                ++i;++j;
            }
            else
            {
                i = i - j + 2;
                j = 1;
            }
        }
        if(j > T[0])    return i - T[0];//返回 离pos 的距离
        else return 0;
    }
    else return 0;
}
```



##### KMP算法

```c
// 计算子串T的next数组
void GetNext(SString T, int *next) {
    int i = 1;
    int j = 0;
    next[1] = 0;
    while (i < T[0]) 
    {
        if (j == 0 || T[i] == T[j]) 
        {
            ++i; ++j;
            next[i] = j;
        } 
        else    j = next[j];
    }
}

// 使用KMP算法在字符串S中查找子串T
int Index(SString S, SString T, int pos) {
    int i = pos;
    int j = 1;
    int s_len = S[0];
    int t_len = T[0];
    int next[MAXSTRLEN];
    GetNext(T, next); // 获取子串T的next数组

    while (i <= s_len && j <= t_len) 
    {
        if (j == 0 || S[i] == T[j]) 
        {
            ++i; ++j;
        }
        else   j = next[j]; // 根据next数组进行回溯
    }
    if (j > t_len)    return i - t_len;
    else 	   return 0;
}
```



#### 1. 串的基本操作

```c
//AIxi
#include <stdio.h>
#include <string.h>

#define MAIN_STR_LEN 100
#define SUB_STR_LEN 20

int MyStrCompare(char* Str1, char* Str2) 
{ 
    int i;
    int result = 0;
    for (i = 1; (i <= Str1[0]) && (i <= Str2[0]); i++) 
    {
        if (Str1[i] > Str2[i]) 
        {
            result = 1;
            break;
        } 
        else if (Str1[i] < Str2[i]) 
        {
            result = -1;
            break;
        } 
    }
    if (result == 0) 
    {
        if (Str1[0] > Str2[0]) 
        {
            result = 1;
        } 
        else if (Str1[0] < Str2[0]) 
        {
            result = -1;
        } 
    } 
    return result;
}

int MySubStrIndex(char* MainStr , char* SubStr , int pos) 
{
    int i, j, result;
    if ((pos < 0) || (pos > (MainStr [0] - SubStr[0] + 1))) 
    {
        return 0;
    } 
    i = pos;
    j = 1;
    while (i <= MainStr [0] && j <= SubStr [0]) 
    {
        if (MainStr[i] == SubStr[j]) 
        {
            i++;
            j++;
        } 
        else 
        {
            i = i - j + 2;
            j = 1;
        }
    }
    if (j > SubStr [0]) 
    {
        result = i - SubStr [0];
    } 
    else 
    {
        result = 0;
    }
    return result;
}

char MyStrDelete(char* S, int pos , int len) 
{
    int i;
    if (pos < 1 || pos > S[0] - len + 1 || len < 0)
        return -1;
    for (i = pos + len; i <= S[0]; i++)
        S[i - len] = S[i];
    S[0] -= len;
    return 1;
}

char MyStrInsert(char* S, int pos , char* T) 
{
    int i;
    if (pos < 1 || pos > S[0] + 1)
        return -1;
    if (S[0] + T[0] <= MAIN_STR_LEN) 
    {
        for (i = S[0]; i >= pos; i--) 
        {
            S[i + T[0]] = S[i];
        }
        for (i = pos; i < pos + T[0]; i++) 
        {
            S[i] = T[i - pos + 1];
        }
        S[0] = S[0] + T[0];
        return 1;
    } 
    else 
    {
        for (i = MAIN_STR_LEN; i <= pos; i--) 
        {
            S[i] = S[i - T[0]];
        }
        for (i = pos; i < pos + T[0]; i++) 
        {
            S[i] = T[i - pos + 1];
        }
        S[0] = MAIN_STR_LEN;
        return 0;
    }
}

int MyStrAssign(char * StrTobeAssigned , char * StrInput)

{
    int len = strlen(StrInput);
    if (len > MAIN_STR_LEN)
        return -1;
    StrTobeAssigned[0] = len;
    strcpy(&StrTobeAssigned[1], StrInput);
    return 1;
}

int MyStrReplace(char * MainStr , char * SubStr1 , char * SubStr2)

{
    int i = 1, tot = 0;
    do 
    {
        i = MySubStrIndex(MainStr, SubStr1, i);
        if (i)
        {
            MyStrDelete(MainStr, i, SubStr1[0]);
            MyStrInsert(MainStr, i, SubStr2);
            i += strlen(SubStr2);
            tot++;
        }
    } while (i);
    return tot;
}

int main() 
{
    char MainStr[MAIN_STR_LEN + 1];
    char SubStr1[SUB_STR_LEN + 1];
    char SubStr2[SUB_STR_LEN + 1];
    int i;
    int compareResult;
    int pos;
    int replaceCounter = 0;
    char InputBuf[3][MAIN_STR_LEN + 1];

    printf("please input 3 strings as MainStr , SubStr1 and SubStr2\n");
    scanf("%s %s %s", InputBuf[0], InputBuf[1], InputBuf [2]);

    if (MyStrAssign(MainStr, InputBuf[0]) == -1 || MyStrAssign(SubStr1, InputBuf[1]) == -1 || MyStrAssign(SubStr2, InputBuf[2]) == -1)
    {
        printf("Error: String length exceeds maximum length\n");
        return -1;
    }

    printf("MainStr =:%d,", MainStr[0]);
    for (i = 1; i <= MainStr[0]; i++) 
    {
        printf("%c,", MainStr[i]);
    }
    printf("\n");
    printf("SubStr1 =:%d,", SubStr1[0]);
    for (i = 1; i <= SubStr1[0]; i++) 
    {
        printf("%c,", SubStr1[i]);
    }
    printf("\n");
    printf("SubStr2 =:%d,", SubStr2[0]);
    for (i = 1; i <= SubStr2[0]; i++) 
    {
        printf("%c,", SubStr2[i]);
    }
    printf("\n");

    compareResult = MyStrCompare(SubStr1, SubStr2);
    printf("SubStr1 compare with SubStr2 is %d\n", compareResult);

    pos = MySubStrIndex(MainStr, SubStr1, 1);
    printf("pos of SubStr1 in MainStr is %d\n", pos);

    pos = MySubStrIndex(MainStr, SubStr2, 1);
    printf("pos of SubStr2 in MainStr is %d\n", pos);

    replaceCounter = MyStrReplace(MainStr, SubStr1, SubStr2);
    printf("The content of MainStr after %d times of replacing SubStr1 with SubStr2 is :\n%d,", replaceCounter , MainStr[0]);
    for (i = 1; i <= MainStr[0]; i++) 
    {
        printf("%c,", MainStr[i]);
    }
    printf("\n");
    return 0;
}
```



#### 2. 统计字符数



```c
//自己写的代码

#include <stdio.h>
#include <string.h>

#define MAXSTRLEN 100
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

typedef char SString[MAXSTRLEN + 1];

void SStringAssign(SString S,char*str)
{
	int i = 1,len = 0;
	for(;str[len] != '\0';len ++)
	for(;str[i - 1] != '\0';i ++)
	{
		S[i] = str[i - 1];
	}
	S[0] = len;
	S[len + 1] = '\0'; 
}

void CountStr(SString S,int *total)
{
	int i = 1;
	for(;i <= S[0];i ++)
	{
		total[S[i] - 'a'] ++;
	}
}

void PrintMax(int *total)
{
	int max = total[0],i = 0,max_n = 0;
	for(;i < 26;i ++)
	{
		if(max < total[i])
		{
			max = total[i] ;
			max_n = i;
		}
	}
	printf("%c %d\n",max_n + 'a',max);
}

int main(int argc, char *argv[]) 
{
	int n ;
	scanf("%d",&n);
	getchar();
	while(n --)
	{
		SString S;
		char str[MAXSTRLEN + 1000];
		scanf("%s",str); 
        str[100] = '\0';
		getchar();
		//printf("%s",str); 
		SStringAssign(S,str);
		
		int total[26] = {0};
		CountStr(S,total);
		
		PrintMax(total);			
	} 
	return 0;
}
```



```c
//AI修改的代码

#include <stdio.h>
#include <string.h>

#define MAXSTRLEN 100
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

typedef char SString[MAXSTRLEN + 2]; // 加一位存储字符串长度，一位存储字符串结尾标记

void SStringAssign(SString S, char *str) {
    int len = strlen(str);
    S[0] = len;
    strncpy(&S[1], str, MAXSTRLEN); // 将字符串复制到 SString 结构体中
    S[len + 1] = '\0'; // 添加字符串结尾标记
}

void CountStr(SString S, int *total) {
    int i;
    for (i = 1; i <= S[0]; i++) {
        total[S[i] - 'a']++;
    }
}

void PrintMax(int *total) {
    int max = total[0], i, max_n = 0;
    for (i = 0; i < 26; i++) {
        if (max < total[i]) {
            max = total[i];
            max_n = i;
        }
    }
    printf("%c %d\n", max_n + 'a', max);
}

int main(int argc, char *argv[]) {
    int n;
    scanf("%d", &n);
    getchar(); // 清除换行符
    while (n--) {
        SString S;
        char str[MAXSTRLEN + 1]; // 调整字符数组大小
        scanf("%100s", str); // 限制输入的最大长度为100个字符
        getchar(); // 清除换行符

        SStringAssign(S, str);

        int total[26] = {0};
        CountStr(S, total);

        PrintMax(total);
    }
    return 0;
}
```



#### 3.字符串连接

```c
//自编代码

#include <stdio.h>
#include <string.h>
#define MAXSTRLEN 100
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

typedef char SString[MAXSTRLEN + 1];

void StrAssign(SString S,char*str)
{
	int i = 1;
	for(;str[i - 1] != '\0';i ++)
	{
		if(str[i - 1] == '#')	break;
		S[i] = str[i - 1];
	}
	S[0] = i;
	S[i + 1] = '\0';
}

int StrConcat(SString S, SString T) {
    if (S[0] + T[0] > MAXSTRLEN) {
        return ERROR;
    }
    int i = 1;
	for(;S[i] != '\0';i++)
	{
		T[T[0] + i] = S[i];
	}
    
    T[0] += S[0];

    return OK;
}

int main(int argc, char *argv[]) 
{
	int n = 1000,i;
	char str1[n],str2[n];
       
	//scanf("%s %s",str1,str2);  //这样输入出问题了，中间有空格，就间断输入了
   
    // 读取两个字符串，以 '#' 结束
    scanf("%[^#]#", str1);
    getchar();  // 读取并丢弃换行符
    scanf("%[^#]#", str2);
    
	//printf("%s\n",str1);
	//printf("%s\n",str2);
    
	SString S,T;
	StrAssign(S,str1);
	StrAssign(T,str2);
	
	StrConcat(S,T);
	
	for(i = 1;i <= T[0];i ++)
	{
		printf("%c",T[i]);
	}
	printf("\n");
	return 0;
}
```



#### 4. 词频统计

```c
//AI跑得代码   
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_WORD_LENGTH 50
#define HASH_SIZE 1000

// 定义单词节点结构体
typedef struct WordNode {
    char word[MAX_WORD_LENGTH];
    int count;
    struct WordNode* next;
} WordNode;

// 定义哈希表结构体
typedef struct {
    WordNode* buckets[HASH_SIZE];
} HashTable;

// 哈希函数，将单词转换为哈希值
int hash(char *word) {
    int hash = 0;
    while (*word) {
        hash = (hash * 31 + *word) % HASH_SIZE;
        word++;
    }
    return hash;
}

// 创建单词节点
WordNode* createWordNode(char *word) {
    WordNode* newNode = (WordNode*)malloc(sizeof(WordNode));
    if (newNode == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }
    strcpy(newNode->word, word);
    newNode->count = 1;
    newNode->next = NULL;
    return newNode;
}

// 在哈希表中查找单词节点，如果不存在则返回NULL
WordNode* findWord(HashTable* hashTable, char *word) {
    int index = hash(word);
    WordNode* current = hashTable->buckets[index];
    while (current != NULL) {
        if (strcmp(current->word, word) == 0) {
            return current;
        }
        current = current->next;
    }
    return NULL;
}

// 向哈希表中插入单词节点，如果已存在则增加计数，否则创建新节点插入
void insertWord(HashTable* hashTable, char *word) {
    int index = hash(word);
    WordNode* current = hashTable->buckets[index];
    WordNode* previous = NULL;
    while (current != NULL) {
        if (strcmp(current->word, word) == 0) {
            current->count++;
            return;
        }
        previous = current;
        current = current->next;
    }
    // 单词不存在，创建新节点插入
    WordNode* newNode = createWordNode(word);
    if (previous == NULL) {
        hashTable->buckets[index] = newNode;
    } else {
        previous->next = newNode;
    }
}

// 比较函数，用于qsort排序
int compare(const void *a, const void *b) {
    const WordNode *word1 = *(const WordNode **)a;
    const WordNode *word2 = *(const WordNode **)b;
    // 先比较出现次数，出现次数相同时按照字典序排序
    if (word1->count != word2->count) {
        return word2->count - word1->count;
    } else {
        return strcmp(word1->word, word2->word);
    }
}

// 释放哈希表
void freeHashTable(HashTable* hashTable) {
    for (int i = 0; i < HASH_SIZE; i++) {
        WordNode* current = hashTable->buckets[i];
        while (current != NULL) {
            WordNode* temp = current;
            current = current->next;
            free(temp);
        }
    }
    free(hashTable);
}

int main() {
    // 打开文件
    FILE *file = fopen("article.txt", "r");
    if (file == NULL) {
        fprintf(stderr, "Failed to open file\n");
        return 1;
    }

    // 创建哈希表
    HashTable* hashTable = (HashTable*)malloc(sizeof(HashTable));
    if (hashTable == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        return 1;
    }
    memset(hashTable->buckets, 0, sizeof(hashTable->buckets));

    char word[MAX_WORD_LENGTH];
    // 读取文件中的每个单词并进行统计
    while (fscanf(file, "%s", word) == 1) {
        // 转换为小写
        for (int i = 0; word[i]; i++) {
            word[i] = tolower(word[i]);
        }
        // 去除单词末尾的标点符号
        int len = strlen(word);
        while (len > 0 && ispunct(word[len - 1])) {
            word[len - 1] = '\0';
            len--;
        }
        // 插入哈希表
        insertWord(hashTable, word);
    }
    fclose(file);

    // 将哈希表中的单词节点存入数组
    WordNode* wordArray[HASH_SIZE];
    int count = 0;
    for (int i = 0; i < HASH_SIZE; i++) {
        WordNode* current = hashTable->buckets[i];
        while (current != NULL) {
            wordArray[count++] = current;
            current = current->next;
        }
    }

    // 对单词节点数组按照出现次数进行排序
    qsort(wordArray, count, sizeof(WordNode*), compare);

    // 输出前100个单词及其出现次数
    int numWords = count < 100 ? count : 100;
    for (int i = 0; i < numWords; i++) {
        printf("%s %d\n", wordArray[i]->word, wordArray[i]->count);
    }

    // 释放内存
    freeHashTable(hashTable);

    return 0;
}

```



#### 5. 字符串中的第一个唯一字符

```c
//我的代码
#include <stdio.h>
#include <string.h>

#define MAXSTRLEN 300000
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

typedef char SString [MAXSTRLEN + 1]; 

void StrAssign(SString S,char*str)
{
	int i = 1;
	for(;str[i - 1] != '\0';i ++)
	{
		S[i] = str[i - 1];
	}
	S[0] = i - 1;
	S[i] = '\0';
}

int Unique_Index(SString S)
{
	if(S[0] == 0)	return -1;
	int i,j,tag;
	for(i = 1;i <= S[0];i ++)
	{
		for(j = 1;j <= S[0];j ++)
		{
			tag = -1;
			if(j == i)	continue;	
			else if(S[i] == S[j])	break;
			if(S[i] != S[j])	tag = i;
		}
		if(tag != -1)	return i - 1;
	}
	return -1;
}

int main(int argc, char *argv[]) 
{
	char str[MAXSTRLEN + 1];
	scanf("%s",str);
	
	SString S;
	StrAssign(S,str);
	
	int a = Unique_Index(S);
	printf("%d",a); 
	
	return 0;
}
```



```c
//AI跑的代码
#include <stdio.h>
#include <string.h>

#define MAXSTRLEN 300000
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

typedef char SString[MAXSTRLEN + 1];

void StrAssign(SString S, char *str) {
    int i = 1;
    for (; str[i - 1] != '\0'; i++) {
        S[i] = str[i - 1];
    }
    S[0] = i - 1; // 修正字符串长度
    S[i] = '\0';
}

int Unique_Index(SString S) {
    if (S[0] == 0) return -1; // 如果字符串为空，则返回 -1
    int i;
    int char_count[256] = {0}; // 哈希表，用于记录每个字符的出现次数
    // 第一次遍历字符串，统计每个字符出现的次数
    for (i = 1; i <= S[0]; i++) {
        char_count[(int)S[i]]++; // 将字符映射到哈希表中，并统计出现次数
    }
    // 第二次遍历字符串，找到第一个出现次数为1的字符，返回其下标
    for (i = 1; i <= S[0]; i++) {
        if (char_count[(int)S[i]] == 1) {
            return i - 1;
        }
    }
    return -1;
}

int main(int argc, char *argv[]) {
    char str[MAXSTRLEN + 1];
    scanf("%s", str);

    SString S;
    StrAssign(S, str);

    int a = Unique_Index(S);
    printf("%d", a);

    return 0;
}

```



#### 6. 求一个串中出现的第一个最长重复子串

```c
#include <stdio.h>
#include <string.h>
#include<malloc.h>

#define MAXSTRLEN 255
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

int check(char *s, int x, int n,int *pos) 
{
	int j = 0,i,k;

	for(;j < n - x + 1;j ++)
	{
		char substr[x + 1];
		for(i = j,k=0;i < x + j; i ++,k++)
		{
			substr[k] = s[i];
		}
		substr[x] = '\0';
	    int count = 0;
		for (i = 0; i <= n - x; i++) 
		{
	        if (strncmp(s + i, substr, x) == 0) 
			{
	            count++;
	        }
	        if(count == 2)
	        {
	        	*pos = j;
	        	return 1;
			}
	    } 
	}
	return 0;
}

char *search_longest_repeated_substring(char *s, int n) {
    int l = 0, r = n,pos = 0;
    while (l < r) {
        int mid = l + (r - l + 1) / 2;
        if (check(s, mid, n, &pos))    l = mid;
        else      r = mid - 1;
    }
    if (l == 0) {
        return NULL;
    }
    char *result;
	result = (char*)malloc((l + 1) * sizeof(char));
    if (result == NULL) {
        printf("内存分配失败\n");
        return NULL;
    }
    strncpy(result, s + pos, l);
    result[l] = '\0';
    return result;
}

int main() {
    char *s = malloc(MAXSTRLEN * sizeof(char));
    if (s == NULL) 
	{
        printf("内存分配失败\n");
        return 1;
    }
    scanf("%s", s);

    char *result = search_longest_repeated_substring(s, strlen(s));
    
    if (result == NULL) 
	{
        printf("没有最长重复子串\n");
    }
	 else 
	 {
        printf("%s\n", result);
        free(result);
    }

    free(s);

    return 0;
}

```



```c
//AI优化的hash算法
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAXSTRLEN 255
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

// Function to compute the hash value of a substring
unsigned long long hash(char *s, int start, int end) {
    unsigned long long hash_value = 0;
    for (int i = start; i <= end; i++) {
        hash_value = hash_value * 31 + s[i];
    }
    return hash_value;
}

// Function to check if a substring appears more than once in the string
int check(char *s, int x, int n, int *pos) {
    unsigned long long *hashes = malloc((n - x + 1) * sizeof(unsigned long long));
    if (hashes == NULL) {
        printf("内存分配失败\n");
        return ERROR;
    }

    // Precompute hashes for all substrings of length x
    for (int i = 0; i <= n - x; i++) {
        hashes[i] = hash(s, i, i + x - 1);
    }

    // Search for repeated substrings using the hashes
    for (int i = 0; i <= n - x; i++) {
        unsigned long long target_hash = hashes[i];
        int count = 0;
        for (int j = i + 1; j <= n - x; j++) {
            if (hashes[j] == target_hash) {
                count++;
                if (count == 1) {
                    *pos = i;
                    free(hashes);
                    return TRUE;
                }
            }
        }
    }

    free(hashes);
    return FALSE;
}

char *search_longest_repeated_substring(char *s, int n) {
    int l = 0, r = n, pos = 0;
    while (l < r) {
        int mid = l + (r - l + 1) / 2;
        if (check(s, mid, n, &pos))    l = mid;
        else      r = mid - 1;
    }
    if (l == 0) {
        return NULL;
    }
    char *result;
    result = (char *)malloc((l + 1) * sizeof(char));
    if (result == NULL) {
        printf("内存分配失败\n");
        return NULL;
    }
    strncpy(result, s + pos, l);
    result[l] = '\0';
    return result;
}

int main() {
    char *s = malloc(MAXSTRLEN * sizeof(char));
    if (s == NULL) {
        printf("内存分配失败\n");
        return 1;
    }
    scanf("%s", s);

    char *result = search_longest_repeated_substring(s, strlen(s));

    if (result == NULL) {
        printf("没有最长重复子串\n");
    } else {
        printf("%s\n", result);
        free(result);
    }

    free(s);

    return 0;
}

```



#### 7. Caesar密码

```c
//AI	跑的代码
#include <stdio.h>
#include <string.h>

// 函数用于解密Caesar密码
void decrypt_caesar(char *cipher_text) {
    // 定义字母替换表
    char mapping[26] = {
        'V', 'W', 'X', 'Y', 'Z', 'A', 'B', 'C', 'D', 'E',
        'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
        'P', 'Q', 'R', 'S', 'T', 'U'
    };

    // 对密码消息中的每个字符进行解密
    for (int i = 0; cipher_text[i] != '\0'; i++) {
        // 如果是字母，则进行解密
        if (cipher_text[i] >= 'A' && cipher_text[i] <= 'Z') {
            cipher_text[i] = mapping[cipher_text[i] - 'A'];
        }
    }
}

int main() {
    char line[200];

    // 读取输入直到遇到ENDOFINPUT
    while (1) {
        scanf("%s", line);
        if (strcmp(line, "ENDOFINPUT") == 0) {
            break;
        }

        if (strcmp(line, "START") == 0) {
            getchar(); // 消耗掉换行符
            fgets(line, 200, stdin); // 读取密码消息
            decrypt_caesar(line); // 解密消息
            printf("%s", line); // 输出原始消息
        }
    }

    return 0;
}

```



#### 8.判断等值子串

```c
//算法1 —— 贪心
#include <stdio.h>
#include <string.h>

void longest_equal_substring(char *s) {
    int max_length = 0;
    char *max_substring = NULL;
    
    int current_length = 1,i;
    char *current_start = s;
    for ( i = 1; s[i] != '!'; i++) {
        if (s[i] == s[i - 1]) {
            current_length++;
        } else {
            if (current_length > max_length) {
                max_length = current_length;
                max_substring = current_start;
            }
            current_length = 1;
            current_start = s + i;
        }
    }
    
    // Check the last substring
    if (current_length > max_length) {
        max_length = current_length;
        max_substring = current_start;
    }

    if (max_length > 1) {
        for (i = 0; i < max_length; i++) {
            printf("%c", max_substring[i]);
        }
    } else {
        printf("no");
    }
}

int main() {
    char input_str[1000];
    scanf("%s", input_str);
    longest_equal_substring(input_str);
    return 0;
}

```



```c
//算法2 —— 双指针
#include <stdio.h>
#include <string.h>

void longest_equal_substring(char *s) {
    int n = strlen(s);
    int max_length = 0;
    int max_start = 0;

    int start = 0; // 记录当前等值子串的起始位置
    for (int i = 1; i <= n; i++) {
        if (s[i] != s[i - 1]) {
            int length = i - start; // 计算当前等值子串的长度
            if (length > max_length) {
                max_length = length;
                max_start = start;
            }
            start = i; // 更新当前等值子串的起始位置
        }
    }

    if (max_length > 1) {
        for (int i = max_start; i < max_start + max_length; i++) {
            printf("%c", s[i]);
        }
    } else {
        printf("no");
    }
}

int main() {
    char input_str[1000];
    scanf("%s", input_str);
    longest_equal_substring(input_str);
    return 0;
}

```



```c
//算法3 —— 动态规划
#include <stdio.h>
#include <string.h>

void longest_equal_substring(char *s) {
    int n = strlen(s);
    int max_length = 0;
    int max_start = 0;
    
    int current_length = 1;
    for (int i = 1; i < n; i++) {
        if (s[i] == s[i - 1]) {
            current_length++;
        } else {
            if (current_length > max_length) {
                max_length = current_length;
                max_start = i - max_length;
            }
            current_length = 1;
        }
    }
    
    // Check the last substring
    if (current_length > max_length) {
        max_length = current_length;
        max_start = n - max_length;
    }

    if (max_length > 1) {
        for (int i = max_start; i < max_start + max_length; i++) {
            printf("%c", s[i]);
        }
    } else {
        printf("no");
    }
}

int main() {
    char input_str[1000];
    scanf("%s", input_str);
    longest_equal_substring(input_str);
    return 0;
}

```



#### 9.判断两个字符串是否匹配



```c
//我的代码 + AI优化
#include <stdio.h>
#include <stdbool.h>

#define TRUE 1
#define FALSE 0

bool isMatch(char *str1, char *str2) {
    // 当两个字符串都为空时，它们是匹配的
    if (*str1 == '\0' && *str2 == '\0')
        return TRUE;
    
    // 当其中一个字符串为空时，另一个不为空，它们不匹配
    if (*str1 == '\0' || *str2 == '\0')
        return FALSE;

    // 如果当前字符匹配或者是 '?'，则继续比较下一个字符
    if (*str1 == *str2 || *str2 == '?')
        return isMatch(str1 + 1, str2 + 1);

    // 如果遇到 '*'，则递归地尝试所有可能的情况
    if (*str2 == '*') {
        // 将 '*' 后面的子串作为模式串
        char *pattern = str2 + 1;
        
		while(*pattern == '*')	
		{
			pattern ++; 
			str1++;
		}
		       
		if(*pattern == '\0')	return TRUE;
		
		while(*pattern == '?')
		{
			pattern++;
        	str1++;
        	
        	// 当两个字符串都为空时，它们是匹配的
   			if (*str1 == '\0' && *pattern == '\0')
        		return TRUE;
        		
        	// 当其中一个字符串为空时，另一个不为空，它们不匹配
    		if (*str1 == '\0' || *str2 == '\0')
        		return FALSE;
		}
		

		
        // 在 str1 中查找所有可能的匹配
        while (*str1 != '\0') {
            if (isMatch(str1, pattern))
                return TRUE;
            str1++;
        }

        // 如果在 str1 中没有找到匹配，则返回 FALSE
        return FALSE;
    }

    // 如果当前字符不匹配，且不是通配符，则说明不匹配
    return FALSE;
}


int main() {
    char str1[1000], str2[1000];

    // 读取两个字符串，以 '#' 结束
    scanf("%[^#]#", str1);
    getchar();  // 读取并丢弃换行符
    scanf("%[^#]#", str2);
    
//    puts(str1);
//	puts(str2); 
    
    // 调用匹配函数进行匹配
    if (isMatch(str2, str1)) {
        printf("yes\n");
    } else {
        printf("no\n");
    }

    return 0;
}
```



```c
//AI跑得	有bug
#include <stdio.h>
#include <stdbool.h>
#include <string.h>

// Function to check if two strings match considering wildcard characters
bool isMatch(char *str1, char *str2) {
    // Pointers to traverse both strings
    char *s1 = str1, *s2 = str2;
    // Pointers to store the positions when '*' and '?' are encountered
    char *star = NULL, *ques = NULL;

    // Traverse until the end of the first string
    while (*s1 != '\0' && *s2 != '\0') {
        // If current characters match or '?' is encountered
        if (*s2 == *s1 || *s2 == '?') {
            s1++;
            s2++;
        }
        // If '*' is encountered in the second string
        else if (*s2 == '*') {
            star = s2; // Store the position of '*'
            ques = s1; // Store the position of corresponding character in the first string
            s2++;      // Move to the next character in the second string
        }
        // If characters don't match and there is no '*' in the second string
        // Go back to the last '*' position and try to match from there
        else if (star != NULL) {
            s2 = star + 1; // Move to the next character after '*'
            s1 = ++ques;   // Move to the next character in the first string from the last '*' position
        } else {
            return false; // If no '*' encountered and characters don't match, return false
        }
    }

    // Ignore any extra '*' characters in the second string
    while (*s2 == '*') {
        s2++;
    }

    // If both strings have reached the end, return true
    return (*s1 == '\0' && (*s2 == '\0' || (*s2 == '*' && *(s2+1) == '\0')));
}

int main() {
    // Input two strings terminated by '#'
    char str1[100], str2[100];
    scanf("%[^#]#%[^#]#", str1, str2);

    // Check if the strings match and print the result
    if (isMatch(str1, str2)) {
        printf("yes\n");
    } else {
        printf("no\n");
    }

    return 0;
}

```

```c
//leetcode 官方解答 —— 动态规划方案	仍有bug
#include <stdio.h>
#include<string.h>
#include <stdbool.h>

bool isMatch(char* s, char* p) {
    int m = strlen(s),j;
    int n = strlen(p),i;
    int dp[m + 1][n + 1];
    memset(dp, 0, sizeof(dp));
    dp[0][0] = true;
    for (i = 1; i <= n; ++i) {
        if (p[i - 1] == '*') {
            dp[0][i] = true;
        } else {
            break;
        }
    }
    for (i = 1; i <= m; ++i) {
        for (j = 1; j <= n; ++j) {
            if (p[j - 1] == '*') {
                dp[i][j] = dp[i][j - 1] | dp[i - 1][j];
            } else if (p[j - 1] == '?' || s[i - 1] == p[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            }
        }
    }
    return dp[m][n];
}


int main() {
    char str1[1000], str2[1000];

    // 读取两个字符串，以 '#' 结束
    scanf("%[^#]#", str1);
    getchar();
    scanf(" %[^#]#", str2);
    
    //putchar(ch);
	
//	scanf("%s",str1);
//	scanf("%s",str2);
	//puts(str1);
	//puts(str2); 
	
    // 调用匹配函数进行匹配
    if (isMatch(str1, str2)) {
        printf("yes\n");
    } else {
        printf("no\n");
    }

    return 0;
}

```



### 作业7——递归



#### 学习代码：

```c
void reverse_List_recursive(LNode *prev, LNode *curr, LNode **head) {
    if (curr == NULL) {
        *head = prev; // 更新逆序后的链表头结点
        return;
    }
    reverse_List_recursive(curr, curr->next, head);
    curr->next = prev;
}

void reverse_List(LinkList L) {
    LNode *head = NULL; // 逆序后的链表头结点
    reverse_List_recursive(NULL, L->next, &head);
    L->next = head; // 更新原链表的头结点
}
```



#### 1. 递归实验--阶乘

```c
#include <stdio.h>

#include <stdlib.h>

#include <string.h>

#include <math.h>

 

int JieCheng(int n)

{

/* 代码填在这里 */
    if(n == 1)    return n;
    if(n > 15)
    {
        printf("无法计算\n");
        return 0;
    }
    return n*JieCheng(n - 1);
}

 

int main()

{

    int a;

    int n;

    a=0;

    printf("Input n:\n");

    scanf("%d",&n);

    a = JieCheng(n);

    printf("%d的阶乘为%d",n,a);

}

```



#### 2.用递归方法创建单链表-副本

```c
#include <stdio.h>   
#include <stdlib.h>   
#include <malloc.h>

#define ERROR 0
#define OK 1

typedef int ElemType;   
typedef int Status;

// definition of node structure of singly linked list
typedef struct L_node 
{
    ElemType data;           // data field 
    struct L_node *next;     // pointer field
} LNode, *LinkedList;

// Initialize a singly linked list L with head node
Status InitList_L(LinkedList *L) 
{
    // Allocate memory for head node
	(*L) = (LinkedList)malloc(sizeof(LNode));
	if (!(*L)) return ERROR;
	(*L)->next = NULL;
	return OK; 
}

// 输入若干整数（以输入-1作为结束条件，-1不包含在单链表中），用递归方法创建一个不带头结点的单链表。
Status CreateList_L(LinkedList L) 
{
    ElemType input;
	scanf("%d", &input);
	if (input == -1) {
        // Set the next pointer of the last node to NULL
		L->next = NULL;
		return OK;
	}
    // Allocate memory for the next node
	L->next = (LinkedList)malloc(sizeof(LNode));
	if (!L->next) return ERROR;
    // Assign input value to the data field of the next node
	L->next->data = input;
    // Recursively create the next node
	CreateList_L(L->next);
	return OK;
}

// Print the elements in a list
void LinkedListPrint(LinkedList L) 
{
    // Base case: If the next node is NULL, return
	if (!L->next) return;
    // Print the data of the next node
	printf("%d ", L->next->data); 
    // Recursively print the rest of the list
	LinkedListPrint(L->next);
}

int main() 
{   
	LinkedList La;
	
    // Initialize the linked list
	InitList_L(&La);
	
    // Create the linked list using recursion
	CreateList_L(La);
	
    // Print the linked list
	LinkedListPrint(La);
	
	return 0;
}

```



#### 3. 递归实验--汉诺塔

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static int step = 0;

//移动函数
void move(int n, char *A, char *B)
{
    printf("将%d从%c移动到%c.\n", n, *A, *B);
    step++;
    return;
}

//将n层汉诺塔从A移动到C，B作为辅助
void Hanoi(int n, char *A, char *B, char *C)
{
   if (n == 1)    move(n, A, C); // 只有一层时直接从 A 移动到 C
   else 
   {
        Hanoi(n - 1, A, C, B); // 将 n-1 层汉诺塔从 A 移动到 B，以 C 为辅助
        move(n, A, C); // 将第 n 层从 A 移动到 C
        Hanoi(n - 1, B, A, C); // 将 n-1 层汉诺塔从 B 移动到 C，以 A 为辅助
    }
}

int main()
{
    int n;
    char axle[3] = {'A', 'B', 'C'};

    printf("输入层数n:");
    scanf("%d", &n);

    Hanoi(n, axle, axle + 1, axle + 2);

    printf("移完%d层汉诺塔所用总步数为%d\n", n, step);
    return 0;
}

```



#### 4. 递归实现单链表的反转

```c
#include <stdio.h>

#include <stdlib.h>

#include <string.h>

#define ERROR 0
#define OK 1

typedef struct L_Node
{
	int data;
	struct L_Node *next;
}LNode,*LinkList;

void InitList_L(LinkList* L)
{
	(*L) = (LinkList)malloc(sizeof(LNode));
	if(!(*L))	return ;
	(*L)->next = NULL;
}

void CreateList_L(LinkList L)
{
	int input;
	if(scanf("%d",&input) == EOF)	
	{
		L->next = NULL;
		return ;
	}	
	L->next = (LinkList)malloc(sizeof(LNode));
	if(!L->next)	return ;
	L->next->data = input;
	
	CreateList_L(L->next);
}

void reverse_List(LinkList L)
{
    if (L == NULL || L->next == NULL || L->next->next == NULL) {
        return;
    }

    // 递归反转除头结点之外的部分
    reverse_List(L->next);

    // 找到反转后的尾节点
    LNode *tail = L->next;
    while (tail->next != NULL) 
	{
        tail = tail->next;
    }

    // 将头结点后的节点（反转后的尾节点）移到头结点之前
    tail->next = L->next;
    L->next = L->next->next;
    tail->next->next = NULL;
}


void LinkListPrint(LinkList L)
{
	if(!L->next)	return ;
	printf("%d ",L->next->data);
	LinkListPrint(L->next);
}


int main()

{

    int n;
	
	scanf("%d",&n);
	
	LinkList La;
	
	InitList_L(&La);
	
	CreateList_L(La);
	
	reverse_List(La);
	
	LinkListPrint(La);

    return 0;

}
```



#### 5. 递归实现求链表中的最大整数

```c
//AI
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

// 链表节点的定义
typedef struct ListNode {
    int data;
    struct ListNode *next;
} ListNode;

// 递归函数，找到链表中的最大整数
int find_max(ListNode *head) {
    // 如果链表为空，返回最小的整数值
    if (head == NULL) {
        return INT_MIN;
    }
    // 如果只有一个节点，返回该节点的值
    if (head->next == NULL) {
        return head->data;
    }
    // 递归地比较当前节点的值与剩余链表中的最大值
    int max_rest = find_max(head->next);
    return head->data > max_rest ? head->data : max_rest;
}

int main() {
    int n;
    scanf("%d", &n); // 读取链表的长度
    ListNode *head = NULL;
    ListNode *prev = NULL;
    
    // 构建链表
    for (int i = 0; i < n; i++) {
        int val;
        scanf("%d", &val);
        ListNode *node = (ListNode *)malloc(sizeof(ListNode));
        node->data = val;
        node->next = NULL;
        if (head == NULL) {
            head = node;
        } else {
            prev->next = node;
        }
        prev = node;
    }
    
    // 调用递归函数找到最大值并输出
    int max_value = find_max(head);
    printf("%d\n", max_value);

    // 释放链表内存
    ListNode *current = head;
    while (current != NULL) {
        ListNode *temp = current;
        current = current->next;
        free(temp);
    }
    
    return 0;
}

```



```c
//自己的代码
#include <stdio.h>
#include <stdlib.h>

/* run this program using the console pauser or add your own getch, system("pause") or input loop */

typedef struct	L_Node
{
	int data;
	struct L_Node *next; 
}LNode,*LinkList;

void InitList_L(LinkList *L)
{
	(*L) = (LinkList)malloc(sizeof(LNode));
	if(!(*L))	return ;
	(*L)->next = NULL;
}

void CreateList_L(LinkList L,int n)
{
	LNode *p = L; 
	
	int arr,i;
	for(i = 0;i < n;i ++)
	{
		scanf("%d",&arr); 
		LNode *r ;
		r = (LinkList)malloc(sizeof(LNode));
		if(!r)	return ;
		r->data = arr;
		r->next = NULL;
		p->next = r;
		p = p->next;
	 } 
}

int find_max(LinkList L)
{
	if(!L|| !L->next)	return 0;
	if(!L->next->next)	return L->next->data;
	return L->next->data >= find_max(L->next) ? L->next->data : find_max(L->next);
}


int main(int argc, char *argv[]) 
{
	int n;
	scanf("%d",&n);
	
	LinkList L;
	
	InitList_L(&L);
	
	CreateList_L(L,n);
	
	printf("%d",find_max(L));

	return 0;
}
```



#### 6. 递归实现求链表的结点个数

```c
//AI
#include <stdio.h>
#include <stdlib.h>

// 链表节点的定义
typedef struct ListNode {
    int data;
    struct ListNode *next;
} ListNode;

// 递归函数，计算链表中的节点数量
int count_nodes(ListNode *head) {
    // 如果链表为空，返回0
    if (head == NULL) {
        return 0;
    }
    // 递归地计算剩余链表中的节点数量，并加上当前节点
    return 1 + count_nodes(head->next);
}

int main() {
    int n;
    scanf("%d", &n); // 读取链表的长度
    ListNode *head = NULL;
    ListNode *prev = NULL;
    
    // 构建链表
    for (int i = 0; i < n; i++) {
        int val;
        scanf("%d", &val);
        ListNode *node = (ListNode *)malloc(sizeof(ListNode));
        node->data = val;
        node->next = NULL;
        if (head == NULL) {
            head = node;
        } else {
            prev->next = node;
        }
        prev = node;
    }
    
    // 调用递归函数计算节点数量并输出
    int node_count = count_nodes(head);
    printf("%d\n", node_count);

    // 释放链表内存
    ListNode *current = head;
    while (current != NULL) {
        ListNode *temp = current;
        current = current->next;
        free(temp);
    }
    
    return 0;
}

```



```c
//自己的代码
#include <stdio.h>
#include <stdlib.h>

typedef struct L_Node
{
	int data;
	struct L_Node *next;
}LNode,*LinkList;

void InitList_L(LinkList *L)
{
	(*L) = (LinkList)malloc(sizeof(LNode));
	if(!(*L))	return ;
	(*L)->next = NULL; 
}

void CreateList_L(LinkList L,int n) 
{
	int i ,arr;
	LNode *p = L;
	for(i = 0;i < n; i ++)
	{
		scanf("%d",&arr);
		LNode *r;
		r = (LinkList)malloc(sizeof(LNode));
		r->data = arr;
		r->next = NULL;
		p->next = r;
		p = p->next;
	}
}

int Count_Node(LinkList L)
{
	if(!L->next)	return 0;
	return 1 + Count_Node(L->next);	
} 


int main(int argc, char *argv[]) 
{
	int n;
	scanf("%d",&n);
	
	LinkList L;
	
	InitList_L(&L);
	
	CreateList_L(L,n);
	
	printf("%d",Count_Node(L));
	
	return 0;
}
```



### 作业8——树

#### 学习代码：

###### 二叉链表的第一种创建方法：

```c++
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define OK 1
#define ERROR 0

typedef struct BiTNode 
{
    char data;
    struct BiTNode *lchild;
    struct BiTNode *rchild;
} BiTNode, *BiTree;

int CreateBiTree(BiTree *T) 
{
    char ch;
    scanf("%c", &ch);
    getchar(); // Consume the newline character

    if (ch == '#')// Assuming '#' represents empty node
        *T = NULL;
    else {
        *T = (BiTree)malloc(sizeof(BiTNode));// Allocate memory for the new node
        if (!*T)// Check if memory allocation failed
            exit(EXIT_FAILURE);

        (*T)->data = ch;// Set the data of the node

        // Recursively create left and right subtrees
        if (CreateBiTree(&((*T)->lchild)) == ERROR)
            return ERROR;
        if (CreateBiTree(&((*T)->rchild)) == ERROR)
            return ERROR;
    }
    return OK;
}

int Height_BiTree(BiTree T) 
{
    if (!T)//T为空树
        return 0;
    int left_height = Height_BiTree(T->lchild);
    int right_height = Height_BiTree(T->rchild);
    return fmax(left_height, right_height) + 1;
}

int LeafCount_BiTree(BiTree T) 
{
    if (!T)//若T为空树
        return 0;
    if (T->lchild == NULL && T->rchild == NULL)//T为叶子结点 
        return 1;
    return LeafCount_BiTree(T->lchild) + LeafCount_BiTree(T->rchild);
}

void Level_BiTree(BiTree T, int level) 
{
    if (T) {//T不为空树 
        printf("%c at level %d\n", T->data, level);
        Level_BiTree(T->lchild, level + 1);//求左子树的节点层数 
        Level_BiTree(T->rchild, level + 1);//求右子树的节点层数 
    }
}

void Visit(char data) 
{
    printf("%c ", data);
}

int found = 0;//全局变量，或作参数传递
void Decendents(BiTree T,char e)
{
	if(!T)	return ;//遇空树，直接返回 
	if(T->data == e)	found = 1;//先序遍历时找到e,置“找到”标记 
    if(found)	Visit(T->data);//访问该结点，如打印 
	//if(found)	printf("%c ",T->data);//访问该结点，如打印 
	Decendents(T->lchild, e);//递归地在左子树中搜索 
	Decendents(T->rchild, e);//递归地在右子树中搜索 
	if(T->data == e)	found = 0;//后序遍历时找到e,置“退出”以e为根的子树标记 
 }

void InOrderTraversal(BiTree T) 
{
    if (T) {
        InOrderTraversal(T->lchild);
        printf("%c ", T->data);
        InOrderTraversal(T->rchild);
    }
}

void PreOrderTraversal(BiTree T) 
{
    if (T) {
        printf("%c ", T->data);
        PreOrderTraversal(T->lchild);
        PreOrderTraversal(T->rchild);
    }
}

void PostOrderTraversal(BiTree T) 
{
    if (T) {
        PostOrderTraversal(T->lchild);
        PostOrderTraversal(T->rchild);
        printf("%c ", T->data);
    }
}

void DestroyBiTree(BiTree *T) 
{
    if (*T) 
    {
        DestroyBiTree(&((*T)->lchild));
        DestroyBiTree(&((*T)->rchild));
        free(*T);
        *T = NULL;
    }
}

int main() {
    BiTree T = NULL;
    printf("Enter the binary tree (use '#' for empty nodes):\n");
    if (CreateBiTree(&T) == OK) 
    {
        printf("Binary tree created successfully!\n");

        printf("Inorder traversal: ");
        InOrderTraversal(T);
        printf("\n");

        printf("Preorder traversal: ");
        PreOrderTraversal(T);
        printf("\n");

        printf("Postorder traversal: ");
        PostOrderTraversal(T);
        printf("\n");

        printf("Height of the binary tree: %d\n", Height_BiTree(T));
        printf("Number of leaf nodes: %d\n", LeafCount_BiTree(T));

        printf("Nodes at different levels:\n");
        Level_BiTree(T, 1);

        char node_to_find;
        printf("Enter a node to find its descendants: ");
        scanf(" %c", &node_to_find);
        Decendents(T, node_to_find);
        printf("\n");
    } 
    else 
    {
        printf("Failed to create binary tree.\n");
    }

    DestroyBiTree(&T);
    return 0;
}

```



###### 二叉链表的第二种创建方法：

```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef char DataType;

// Define the structure of a binary tree node
typedef struct TreeNode 
{
    DataType data;
    struct TreeNode *lchild;
    struct TreeNode *rchild;
} LinkBiTree;

// Function to perform postorder traversal and print the binary tree
void PostOrderTraverse(LinkBiTree* T) 
{
    if (T) 
	{
        PostOrderTraverse(T->lchild); // Traverse left subtree
        PostOrderTraverse(T->rchild); // Traverse right subtree
        printf("%c ", T->data);       // Print root
    }
}

// Function to create a binary tree from given preorder and inorder sequences
void CreateBiTree(LinkBiTree **T, char *PreStr, char *InStr, int L1, int R1, int L2, int R2) 
{
    if (L1 > R1 || L2 > R2) // Base case: empty subtree
        *T = NULL;
    else 
	{
        (*T) = (LinkBiTree *)malloc(sizeof(LinkBiTree)); // Allocate memory for the new node
        if (!(*T))    exit(OVERFLOW);

        (*T)->data = PreStr[L1]; // Set the data of the node

        int root;
        for (root = L2; root <= R2; root++) 
		{
            if (InStr[root] == PreStr[L1])     break;
        }
        printf("Root node '%c' is at index %d in the inorder sequence.\n", PreStr[L1], root);
        
        if (root - L2 != 0) // If there are left children
            CreateBiTree(&(*T)->lchild, PreStr, InStr, L1 + 1, L1 + root - L2, L2, root - 1);
        else
            (*T)->lchild = NULL;

        if (R2 - root != 0) // If there are right children
            CreateBiTree(&(*T)->rchild, PreStr, InStr, R1 - R2 + root + 1, R1, root + 1, R2);
        else
            (*T)->rchild = NULL;
    }
}

int main() {
    char PreStr[30], InStr[30];
    printf("Enter the preorder sequence: ");
    scanf("%s", PreStr);
    printf("Enter the inorder sequence: ");
    scanf("%s", InStr);

    int len1 = strlen(PreStr);
    int len2 = strlen(InStr);

    LinkBiTree *T = NULL;
    CreateBiTree(&T, PreStr, InStr, 0, len1 - 1, 0, len2 - 1);

    printf("Postorder traversal of the binary tree: ");
    PostOrderTraverse(T);
    printf("\n");

    return 0;
}
```



##### 层次遍历：

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

// Define the structure for a Binary Tree Node
typedef struct BTNode
{
    char _data;
    struct BTNode* _left;
    struct BTNode* _right;
} BTNode;

// Define the structure for a Queue Node
typedef struct QueueNode
{
    BTNode* _data;
    struct QueueNode* _next;
} QueueNode;

// Define the structure for a Queue
typedef struct Queue
{
    QueueNode* _front;
    QueueNode* _rear;
} Queue;

// Initialize an empty queue
void QueueInit(Queue* q)
{
    q->_front = q->_rear = NULL;
}

// Check if the queue is empty
int isEmptyQueue(Queue* q)
{
    return q->_front == NULL;
}

// Enqueue an item into the queue
void QueuePush(Queue* q, BTNode* data)
{
    QueueNode* newNode = (QueueNode*)malloc(sizeof(QueueNode));
    newNode->_data = data;
    newNode->_next = NULL;

    if (isEmptyQueue(q)) {
        q->_front = q->_rear = newNode;
    } else {
        q->_rear->_next = newNode;
        q->_rear = newNode;
    }
}

// Dequeue an item from the queue
void QueuePop(Queue* q)
{
    if (!isEmptyQueue(q))
    {
        QueueNode* temp = q->_front;
        q->_front = q->_front->_next;
        free(temp);
        if (q->_front == NULL)
        {
            q->_rear = NULL;
        }
    }
}

// Get the front item of the queue
BTNode* QueueFront(Queue* q)
{
    if (!isEmptyQueue(q))
    {
        return q->_front->_data;
    }
    return NULL; // Queue is empty
}

// Destroy the queue and deallocate memory
void QueueDestroy(Queue* q)
{
    while (!isEmptyQueue(q))
    {
        QueuePop(q);
    }
}

// Function to perform level-order traversal of a binary tree
void BinaryTreeLevelOrder(BTNode* root)
{
    Queue q;
    QueueInit(&q);

    if (root != NULL)
        QueuePush(&q, root);

    while (!isEmptyQueue(&q))
    {
        BTNode* front = QueueFront(&q);
        printf("%c ", front->_data);

        if (front->_left != NULL)
            QueuePush(&q, front->_left);

        if (front->_right != NULL)
            QueuePush(&q, front->_right);

        QueuePop(&q);
    }

    printf("\n");
    QueueDestroy(&q);
}

// Function to check if a binary tree is a complete binary tree
bool isBinaryTreeComplete(BTNode* root)
{
    if(root == NULL)    return true; // An empty tree is complete
    BTNode *front = root;
    Queue q;
    QueueInit(&q);
    if(front != NULL)
        QueuePush(&q, front);
    bool encounteredNull = false; // Flag to track if a null node has been encountered
    while(!isEmptyQueue(&q))
    {
        front = QueueFront(&q);
        if(front == NULL)
        {
            encounteredNull = true; // Set flag when encountering a null node
        }
        else
        {
            // If a null node has been encountered previously, and a non-null node is encountered now, it's not a complete binary tree
            if (encounteredNull)
            {
                return false;
            }
            QueuePush(&q, front->_left);
            QueuePush(&q, front->_right);
        }
        QueuePop(&q);
    }
    return true; // If no inconsistency found, it's a complete binary tree
}


//老师版
//bool isBinaryTreeComplete(BTNode* root)
//{
//    if(root == NULL)    return true;
//    BTNode *front = root;
//    Queue q;
//    QueueInit(&q);
//    if(front != NULL)
//        QueuePush(&q, front);
//    while(!isEmptyQueue(&q))
//    {
//        front = QueueFront(&q);
//        if(front == NULL)
//        {
//            //如果取出的节点为空，则停止入队操作，开始检查队列中是否还有非空节点
//            break;
//        }
//        //将当前节点的左右子节点入队
//        QueuePush(&q, front->_left);
//        QueuePush(&q, front->_right);
//        QueuePop(&q);
//    }
//    while(!isEmptyQueue(&q))
//    {
//        //循环结束后，检查队列中是否还有非空结点
//        front = QueueFront(&q);
//        QueuePop(&q);
//        if(front != NULL)
//        {
//            //如果存在非空节点，则说明该二叉树不是完全二叉树
//            QueueDestroy(&q);
//            return false;
//        }
//    }
//    QueueDestroy(&q);
//    return true;
//}



int main()
{
    // Example usage
    // Create a binary tree
    BTNode* root = (BTNode*)malloc(sizeof(BTNode));
    root->_data = 'A';
    root->_left = (BTNode*)malloc(sizeof(BTNode));
    root->_left->_data = 'B';
    root->_left->_left = NULL;
    root->_left->_right = NULL;
    root->_right = (BTNode*)malloc(sizeof(BTNode));
    root->_right->_data = 'C';
    root->_right->_left = NULL;
    root->_right->_right = NULL;

    // Perform level-order traversal
    BinaryTreeLevelOrder(root);

    printf("%d", isBinaryTreeComplete(root));

    // Free memory
    free(root->_left);
    free(root->_right);
    free(root);

    return 0;
}

//输出结果是:
//A B C
//1
```



##### 哈夫曼编码：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h> // for INT_MAX

typedef struct HuffmanTreeNode {
    int weight;
    int parent;
    int lchild;
    int rchild;
} HTNode, *HuffmanTree;

// 选择两个权重最小且尚未加入树中的节点
// 参数：
//   HT: 哈夫曼树节点数组
//   n: 当前可供选择的节点数
//   s1: 指向第一个最小权重节点的指针
//   s2: 指向第二个最小权重节点的指针
void Select(HuffmanTree HT, int n, int *s1, int *s2) 
{
    int min1 = INT_MAX, min2 = INT_MAX;
    *s1 = 0, *s2 = 0;
	//遍历所有节点以找到两个权重最小的节点
    for (int i = 1; i <= n; i++) 
    {
        if (HT[i].parent == 0) 
        { // Node is not yet part of the tree
            if (HT[i].weight < min1) 
            {//更新最小和次小权重节点
                min2 = min1;
                *s2 = *s1;
                min1 = HT[i].weight;
                *s1 = i;
            } 
            else if (HT[i].weight < min2) 
            {
                min2 = HT[i].weight;
                *s2 = i;
            }
        }
    }
}

void CreateHuffmanTree(HuffmanTree *HT, int n) 
{
    if (n <= 1) return;
    int m = 2 * n + 1;
    *HT = (HuffmanTree)malloc((m + 1) * sizeof(HTNode));//0单元未用，所以需要动态分配m+1个单元，HT[m]表示根节点
    for (int i = 1; i <= m; i++) 
    {//将1~m号单元中的双亲、左孩子、右孩子的下标都初始化为0
        (*HT)[i].lchild = 0;
        (*HT)[i].rchild = 0;
        (*HT)[i].parent = 0;
    }
    for (int i = 1; i <= n; i++) 
    {//输入前n个单元中叶子结点的权值
        scanf("%d", &((*HT)[i].weight));
    }
/*------初始化工作结束，下面开始创建哈夫曼树------*/
    for(int i = n + 1;i <= m;i ++) 
    {//通过n-1次的选择、删除、合并来创建哈夫曼树
        int s1, s2;
        Select(*HT, i - 1, &s1, &s2);
		//在HT[k](i<=k<=i-1)中选择两个其双亲域为0且权值最小的结点
        //并返回他们在HT中的序号s1和s2
        (*HT)[s1].parent = i;
        (*HT)[s2].parent = i;
        //得到新节点i，从森林中删除s1，s2，将s1和s2的双亲域由0改为i
        
        //将s1,s2分别作为i的左右孩子
        (*HT)[i].lchild = s1;
        (*HT)[i].rchild = s2;
        
        //i的权值为做左右孩子权值之和
        (*HT)[i].weight = (*HT)[s1].weight + (*HT)[s2].weight;
    }
}

typedef char **HuffmanCode;//动态分配数组存储哈夫曼编码表

void CreateHuffmanCode(HuffmanTree *HT, HuffmanCode *HC, int n) 
{
    *HC = (char **)malloc((n + 1) * sizeof(char *));//分配存储n个字符编码表空间
    char *cd = (char *)malloc(n * sizeof(char));
    cd[n - 1] = '\0';
    int start, c, f;

    for (int i = 1; i <= n; i++) {
        start = n - 1;
        c = i;
        f = (*HT)[i].parent;
        while (f != 0) {
            --start;
            if ((*HT)[f].lchild == c)
                cd[start] = '0';
            else
                cd[start] = '1';
            c = f;
            f = (*HT)[f].parent;
        }
        (*HC)[i] = (char *)malloc((n - start) * sizeof(char));
        strcpy((*HC)[i], &cd[start]);
    }
    free(cd);
}

int main() {
    int n = 8;
    HTNode HTree[] = {
            {0, 0, 0, 0}, // Dummy node for 0th element
            {5, 0, 0, 0},
            {3, 0, 0, 0},
            {7, 0, 0, 0},
            {9, 0, 0, 0},
            {11, 0, 0, 0}
    };

    HuffmanTree HT;
    HuffmanCode HC;

    CreateHuffmanTree(&HT, n);
    printf("\nnode: weight  parent  lchild  rchild\n");
    for (int i = 1; i <= 2 * n - 1; i++) {
        printf("%3d: %4d %6d %6d %6d\n", i, HT[i].weight, HT[i].parent, HT[i].lchild, HT[i].rchild);
       //free(HC[i]);
    }
    CreateHuffmanCode(&HT, &HC, n);

    printf("Huffman Codes:\n");
    for (int i = 1; i <= n; i++) {
        printf("%d: %s\n", i, HC[i]);
        free(HC[i]);
    }

    free(HC);
    free(HT);

    return 0;
}
```





#### 1. 二叉树基本操作



```c
#include <stdio.h>

#include <string.h>

#include<malloc.h>

typedef struct node         //二叉树结点类型的定义

{

    char data;

    struct node *lchild;      //定义结点的左孩子指针

    struct node *rchild;      //定义结点的右孩子指针

} BinTNode;


BinTNode *CreateBinTree()  //输入二叉树的先序遍历序列，创建二叉链表

{

    BinTNode *t;

    char ch;

    ch = getchar();

    if (ch == '0')             //如果读入0，创建空树

        t = NULL;

    else
    {
		t = (BinTNode*)malloc(sizeof(BinTNode));
		//if(!t)	exit(-1);
		t->data = ch;
		t->lchild = CreateBinTree();
		t->rchild = CreateBinTree(); 

    }


    return t;

}


void ListBinTree(BinTNode *t)                  //用广义表表示二叉树

{

    if (t != NULL)
    {

        printf("%c", t->data);                //打印数据

        if (t->lchild != NULL || t->rchild != NULL)
        {

            printf("(");                      //打印广义表的左括号

            ListBinTree(t->lchild);           //用广义表表示左子树

            if (t->rchild != NULL)

                printf(",");                    //打印左子树和右子树之间的逗号

            ListBinTree(t->rchild);         //用广义表表示右子树

            printf(")");                    //打印广义表的右括号

        }
    }
}

void preorder(BinTNode *t)   //对二叉树进行先序遍历  注意: 课件中的Visit(T->data)在此

//处是 printf("%3c",t->data),下同。
{
 	if(t)
	{
		printf("%3c",t->data);
		preorder(t->lchild);
		preorder(t->rchild);
	}
}

void inorder(BinTNode *t) //对二叉树进行中序遍历

{
	if(t)
	{
		inorder(t->lchild);
		printf("%3c",t->data);
		inorder(t->rchild);
	}

}


void postorder(BinTNode *t) //对二叉树进行后序遍历

{
	if(t)
	{
		postorder(t->lchild);
		postorder(t->rchild);
		printf("%3c",t->data);
	}



}


int Height(BinTNode *t)//节点深度

{
    if(!t)	return 0;
    return (Height(t->lchild) > Height(t->rchild) ? Height(t->lchild) : Height(t->rchild)) + 1;


}

//二叉树的总结点数

int Size(BinTNode *t)
{


    if(!t)	return 0;
	return 1 + Size(t->lchild) + Size(t->rchild);

}

//二叉树的叶子结点数

int Leaf(BinTNode *t)
{

	if(!t)	return 0;
	if(t->lchild == NULL && NULL == t->rchild)	return 1;
	return 	Leaf(t->lchild) + Leaf(t->rchild);
    
}

//二叉树的最大值

int Max(BinTNode *t)
{

    if (t == NULL) return 0;

    if (t->lchild == NULL && t->rchild == NULL)

        return t->data;

    int l = Max(t->lchild);

    int r = Max(t->rchild);

    return l > r ? l : r;

}


int main()
{

    BinTNode *t = NULL;

    //int TreeHeight;

    printf("请输入先序序列,虚结点用0表示：\n");

    t = CreateBinTree();

    printf("广义表表示的二叉树的输出：\n");

    ListBinTree(t);                          //调用二叉树的广义表表示函数

    printf("\n二叉树的前序遍历结果为:\n");

    preorder(t);                             //调用二叉树先序遍历函数

    printf("\n二叉树的中序遍历结果为:\n");

    inorder(t);                              //调用二叉树中序遍历函数

    printf("\n二叉树的后序遍历结果为:\n");

    postorder(t);                            //调用二叉树后序遍历函数

    printf("\n");

    printf("二叉树的高度为：%d\n", Height(t));

    printf("二叉树的总结点数为：%d\n", Size(t));

    printf("二叉树的叶子结点数为：%d\n", Leaf(t));

    printf("二叉树的最大值为：%c\n", Max(t));
    
    return 0;

}
```



#### 2. 二叉树的遍历与应用

```c
#include <stdio.h>

#include <malloc.h>

#include <stdlib.h>

#define OVERFLOW 0

#define OK 1

typedef struct node         //二叉树结点类型的定义

{

    char data;

    struct node *lchild; //定义结点的左孩子指针

    struct node *rchild; //定义结点的右孩子指针

} BinTNode, *BTNode;


BinTNode *CreateBinTree()  //输入二叉树的先序遍历序列，创建二叉链表

{

    BinTNode *t;

    char ch;

    ch = getchar();

    if (ch == '0')             //如果读入0，创建空树

        t = NULL;

    else
    {

        t = (BinTNode *) malloc(sizeof(BinTNode)); //申请根结点*t空间

        if (!t) exit(OVERFLOW);

        t->data = ch;                                  //将结点数据ch放入跟结点的数据域

        t->lchild = CreateBinTree();                        //建左子树

        t->rchild = CreateBinTree();                        //建右子树

    }

    return t;

}


void preorder(BTNode t)   //对二叉树进行先序遍历。提示：打印采用 %3c

{

    if (t != NULL)
    {

        printf("%3c", t->data);  //打印节点数据

        preorder(t->lchild);   //先序遍历左子树

        preorder(t->rchild);   //先序遍历右子树

    }

}


void inorder(BTNode t) //对二叉树进行中序遍历。提示：打印采用 %3c

{

    //★★★请补全代码
    if (t != NULL)
    {

        inorder(t->lchild);   //先序遍历左子树 
        
        printf("%3c", t->data);  //打印节点数据

        inorder(t->rchild);   //先序遍历右子树

    }

}

//二叉树的叶子结点数

int Leaf(BTNode t)
{

    //★★★请补全代码
    if(!t)	return 0;
    if(t->lchild == NULL && NULL == t->rchild)		return 1;
	return Leaf(t->lchild) + Leaf(t->rchild);
}



//二叉树的最大值

int Max(BTNode t)
{

    //★★★请补全代码
    if(!t)	return 0;
    if(t->lchild == NULL && NULL == t->rchild)	return t->data;
    return Max(t->lchild) > Max(t->rchild) ? Max(t->lchild) : Max(t->rchild);

}


    int main()
    {

        BTNode t = NULL;

        //int TreeHeight;

        t = CreateBinTree();

        preorder(t);                             //调用二叉树先序遍历函数

        printf("\n");

        inorder(t);                              //调用二叉树中序遍历函数

        printf("\n");

        printf("%d\n", Leaf(t));

        printf("%c\n", Max(t));


    }
```



#### 3.打印二叉树中的所有从根结点到叶子结点的路径

```c
#include<stdio.h>
#include<malloc.h>

#define OK 1
#define ERROR 0

typedef int TElemType;
typedef int Status;

typedef struct Tnode{
    TElemType data;
    struct Tnode *leftchild;
    struct Tnode *rightchild;
}TNode, *BiTree;  

// 根据先序扩展序列构建二叉链表
// a[]为先序扩展序列数组，n为数组长度
Status CreateBiTree1(BiTree *T, char a[], int n)
{
    static int count = 0; // 静态变量，用于记录当前处理的序列下标
    if(count >= n) return ERROR; // 若序列已处理完毕，则返回ERROR
    if(a[count] == '#') // 若当前结点为空
    {
        *T = NULL;
        count++; // 继续处理下一个结点
    }
    else
    {
        *T = (BiTree)malloc(sizeof(TNode)); // 创建新结点
        (*T)->data = a[count++]; // 读取结点的值
        CreateBiTree1(&((*T)->leftchild), a, n); // 递归构建左子树
        CreateBiTree1(&((*T)->rightchild), a, n); // 递归构建右子树
    }
    return OK;
} 

// 打印二叉树
void PrintBiTree(BiTree T)
{
    if(T)
    {
        printf("%c", T->data); // 打印当前结点的值
        PrintBiTree(T->leftchild); // 递归打印左子树
        PrintBiTree(T->rightchild); // 递归打印右子树
    }
}

// 辅助函数：打印路径
void printPath(char path[], int pathLen)
{
    //不能改成path[i]; 或 path[i] != '\0';
    //因为该路径未必能够覆盖之前路径，则path末尾不一定是'\n'
    for(int i = 0; i < pathLen; ++i)
        printf("%c", path[i]); // 打印路径
    printf("\n");
}

// 打印从根结点到叶子结点的所有路径
void printAllPaths(BiTree T, char path[], int pathLen)
{
    if(T == NULL) return; // 若当前结点为空，则直接返回

    path[pathLen++] = T->data; // 将当前结点的值加入路径
    if(T->leftchild == NULL && T->rightchild == NULL) // 若当前结点为叶子结点
    {
        printPath(path, pathLen); // 打印当前路径
        //pathlen传进去是为了区分之前的路径，因为现在新的路径未必能够覆盖之前的路径
        //如若不传进去，则会出现本路径末尾还有结点打印
    }
    else // 若当前结点不是叶子结点，则继续向下递归
    {
        printAllPaths(T->leftchild, path, pathLen); // 递归遍历左子树
        printAllPaths(T->rightchild, path, pathLen); // 递归遍历右子树
    }
}

int main()
{
    char arr[1000], ch;
    int len = 0;
    
//	while(scanf("%c",&arr[len]) != EOF)
//	{
//		if(arr[len] == '\n') // 若输入换行符，则结束循环
//            break;
//        len ++;      
//	}
//这样也行，但会警告，还是下面一种更为稳妥
    
    while((ch = getchar()) != EOF)
    {
        if(ch == '\n') // 若输入换行符，则结束循环
            break;
        arr[len++] = ch;
    }

    BiTree T = NULL;
    CreateBiTree1(&T, arr, len);

    char path[1000]; // 存储当前路径
    int pathLen = 0; // 当前路径长度
    printAllPaths(T, path, pathLen);

    return 0;
}

```



#### 4NR010:求任意二叉树最长路径

```c
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef struct TNode
{
	char data;
	struct TNode *lchild;
	struct TNode *rchild;
}TNode, *BiTree;

void CreateBiTree(BiTree *T)
{
	char ch;
	ch = getchar();//压根没有换行，可以用putchar(ch)试一下 ，最后会自动递归终止 
	//if(ch == '\n')	return;
	if(ch == '0')	*T = NULL;
	else
	{
		*T = (BiTree)malloc(sizeof(TNode));
		(*T)->data = ch;
		CreateBiTree(&(*T)->lchild);
		CreateBiTree(&(*T)->rchild);
	}
}

int Max(int a, int b)
{
	return a > b ? a : b;
}

int Height_BiTree(BiTree T)
{
	if(!T)	return 0;
	return Max(Height_BiTree(T->lchild), Height_BiTree(T->rchild))+ 1;
	
}

void PrintBiTree(BiTree T)
{
    if(T)
    {    
        PrintBiTree(T->lchild); // 递归打印左子树
        printf("%c", T->data); // 打印当前结点的值
        PrintBiTree(T->rchild); // 递归打印右子树
    }
}

void PrintPath(char *Path, int Pathlen)
{
	int i = 0;
	//printf("%d",Pathlen); 
	for(i = 0;i < Pathlen;i ++)
	{
		printf("%c->",Path[i]);
	}
	printf("NULL");
}


void printLongestPath(BiTree T,char* path, int pathlen, int count)
{
	if(!T)	return ;
	path[count ++] = T->data;
	if(T->lchild == NULL && NULL == T->rchild && count == pathlen)
	{
		PrintPath(path,pathlen);
		exit(1);
	}
	else
	{
		printLongestPath(T->lchild, path, pathlen, count);
		printLongestPath(T->rchild, path, pathlen, count);
	}
}

void Destroy_BiTree(BiTree *T)
{
	if(*T)
	{
		Destroy_BiTree(&(*T)->lchild);
		Destroy_BiTree(&(*T)->rchild);
		free(*T);
		*T = NULL;
	}
}

int main()
{
	BiTree T;
	
	CreateBiTree(&T);
	
	int pathlen = Height_BiTree(T);
	
	char path[1000];
	
	printLongestPath(T, path, pathlen, 0);
	
	Destroy_BiTree(&T);
	
	return 0;
}
```



```c
//AI错得离谱
#include <stdio.h>
#include <stdlib.h>

// 定义树节点结构体
typedef struct TreeNode {
    char val;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;

// 创建树节点
TreeNode* createNode(char val) {
    TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
    newNode->val = val;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// 从先序序列构建二叉树
TreeNode* buildTreeFromPreorder(char* preorder) {
    if (!preorder || *preorder == '\0') {
        return NULL;
    }
    TreeNode* root = createNode(*preorder++);
    if (*preorder == '0') {
        preorder++;
    } else {
        root->left = buildTreeFromPreorder(preorder);
        root->right = buildTreeFromPreorder(preorder);
    }
    return root;
}

// 深度优先搜索查找最长路径
void findLongestPath(TreeNode* root, char* path, char** longestPath, int* maxLength, int length) {
    if (!root) {
        if (length > *maxLength) {
            *maxLength = length;
            *longestPath = path;
        }
        return;
    }
    path[length++] = root->val;
    path[length] = '\0';
    findLongestPath(root->left, path, longestPath, maxLength, length);
    findLongestPath(root->right, path, longestPath, maxLength, length);
}

// 打印路径
void printPath(char* path) {
    while (*path != '\0') {
        printf("%c -> ", *path++);
    }
    printf("NULL\n");
}

int main() {
    char preorder[] = "ABD00E00CFG0000";
    TreeNode* root = buildTreeFromPreorder(preorder);

    // 初始化路径变量
    char path[100] = "";
    char* longestPath = NULL;
    int maxLength = 0;

    // 查找最长路径
    findLongestPath(root, path, &longestPath, &maxLength, 0);

    // 打印最长路径
    printPath(longestPath);

    // 释放内存
    free(root);

    return 0;
}
```



### 作业9——图

#### 学习代码：

##### 邻接矩阵法：

```c
//C语言版

/*
测试案例：
4 5
A B C D
A B 1
A C 2
B C 3
B D 4
C D 5

输出：
Enter the number of vertices and arcs: 4 5
Enter the vertex labels: A B C D
Enter the edges (v1 v2 weight):
A B 1
A C 2
B C 3
B D 4
C D 5
DFS Traversal of the graph:
A B C D 

*/
#include <stdio.h>
#include <stdbool.h>

#define MaxInt 32767	//表示极大值，为∞
#define MVNum 100		//最大顶点数
#define OK 1			
#define ERROR 0
#define OVERFLOW -1
typedef int Status;
typedef char VerTexType;		//假设顶点的数据类型为字符型
typedef int ArcType;			//假设边的权值类型为整型

typedef struct 
{
    VerTexType vexs[MVNum];		//顶点表
    ArcType arcs[MVNum][MVNum];	//邻接矩阵
    int vexnum, arcnum;		//图的当前点数和边数
} AMGraph;

// Function to locate the index of a vertex in the graph
int LocateVex(AMGraph *G, VerTexType v) 
{
    for (int i = 0; i < G->vexnum; ++i) 
    {
        if (G->vexs[i] == v) 
        {
            return i;
        }
    }
    return -1; // Return -1 if the vertex is not found
}

Status CreateUDN(AMGraph *G) 
{
    printf("Enter the number of vertices and arcs: ");
    scanf("%d %d", &(G->vexnum), &(G->arcnum));

    printf("Enter the vertex labels: ");
    for (int i = 0; i < G->vexnum; i++) 
    {
        scanf(" %c", &(G->vexs[i]));//依次输入点的信息
    }

    for (int i = 0; i < G->vexnum; i++) 
    {
        for (int j = 0; j < G->vexnum; j++) 
        {//初始化邻接矩阵，边的权值，均值为极大值MaxInt
            G->arcs[i][j] = MaxInt;
        }
    }

    printf("Enter the edges (v1 v2 weight):\n");
    
    for (int k = 0; k < G->arcnum; k++) {
        VerTexType v1, v2;
        ArcType w;
        scanf(" %c %c %d", &v1, &v2, &w);
        int i = LocateVex(G, v1);
        int j = LocateVex(G, v2);
        if (i == -1 || j == -1) 
        {
            printf("Vertex not found!\n");
            return ERROR;
        }
        G->arcs[i][j] = w;
        G->arcs[j][i] = w;
    }
    return OK;
}

bool visited[MVNum];	//访问标志数组，其初值为“false”

void DFS_AM(AMGraph *G, int v) 
{//图G为邻接矩阵类型，从第v个顶点出发深度优先搜索遍历图
    printf("%c ", G->vexs[v]);//访问第v个结点
    visited[v] = true;		//并置访问标志数组相应分量值为true
    for (int w = 0; w < G->vexnum; w++) 
    {//依次检查邻接矩阵v所在的行
        if (G->arcs[v][w] != MaxInt && !visited[w]) 
        {
            DFS_AM(G, w);
            //G.arcs[v][w] != MaxInt 表示w是v的邻接点，如果w未访问，则递归调用DFS_AM()
        }
    }
}

void DFSTraverse(AMGraph *G) 
{//对非连通图G进行深度优先遍历
    for (int v = 0; v < G->vexnum; v++) 
    {//访问标志数组初始化
        visited[v] = false;
    }
    for (int v = 0; v < G->vexnum; v++) 
    {
        if (!visited[v]) 
        {
            DFS_AM(G, v);//对尚未访问的顶点调用DFS_AM()
        }
    }
}

int main() {
    AMGraph G;
    if (CreateUDN(&G) == OK) 
    {
        printf("DFS Traversal of the graph:\n");
        DFSTraverse(&G);
    } 
    else 
    {
        printf("Failed to create the graph.\n");
    }
    return 0;
}

```



```c++
//C++版
//测试案例同上
#include <iostream>
using namespace std;

#define MaxInt 32767
#define MVNum 100
#define OK 1
#define ERROR 0
#define OVERFLOW -1
typedef int Status;
typedef char VerTexType;
typedef int ArcType;

typedef struct {
    VerTexType vexs[MVNum];
    ArcType arcs[MVNum][MVNum];
    int vexnum, arcnum;
} AMGraph;

// Function to locate the index of a vertex in the graph
int LocateVex(AMGraph &G, VerTexType v) {
    for (int i = 0; i < G.vexnum; ++i) {
        if (G.vexs[i] == v) {
            return i;
        }
    }
    return -1; // Return -1 if the vertex is not found
}

Status CreateUDN(AMGraph &G) {
    cout << "Enter the number of vertices and arcs: ";
    cin >> G.vexnum >> G.arcnum;

    cout << "Enter the vertex labels: ";
    for (int i = 0; i < G.vexnum; i++) {
        cin >> G.vexs[i];
    }

    for (int i = 0; i < G.vexnum; i++) {
        for (int j = 0; j < G.vexnum; j++) {
            G.arcs[i][j] = MaxInt;
        }
    }

    cout << "Enter the edges (v1 v2 weight): " << endl;
    for (int k = 0; k < G.arcnum; k++) {
        VerTexType v1, v2;
        ArcType w;
        cin >> v1 >> v2 >> w;
        int i = LocateVex(G, v1);
        int j = LocateVex(G, v2);
        if (i == -1 || j == -1) {
            cout << "Vertex not found!" << endl;
            return ERROR;
        }
        G.arcs[i][j] = w;
        G.arcs[j][i] = w;
    }
    return OK;
}

bool visited[MVNum];

void DFS_AM(AMGraph &G, int v) {
    cout << G.vexs[v] << " ";
    visited[v] = true;
    for (int w = 0; w < G.vexnum; w++) {
        if (G.arcs[v][w] != MaxInt && !visited[w]) {
            DFS_AM(G, w);
        }
    }
}

void DFSTraverse(AMGraph &G) {
    for (int v = 0; v < G.vexnum; v++) {
        visited[v] = false;
    }
    for (int v = 0; v < G.vexnum; v++) {
        if (!visited[v]) {
            DFS_AM(G, v);
        }
    }
}

int main() {
    AMGraph G;
    if (CreateUDN(G) == OK) {
        cout << "DFS Traversal of the graph:" << endl;
        DFSTraverse(G);
    } else {
        cout << "Failed to create the graph." << endl;
    }
    return 0;
}

```



**书中伪代码：**

```c++
#include <iostream>

using namespace std;

#define MaxInt 32767
#define MVNum 100
#define OK 1
#define ERROR 0
#define OVERFLOW -1
typedef int Status;
typedef char VerTexType;
typedef int ArcType;
typedef struct
{
    VerTexType vexs[MVNum];
    ArcType arcs[MVNum][MVNum];
    int vexnum, arcnum;
}AMGraph;

Status CreateUDN(AMGraph &G)
{
    cin>>G.vexnum>>G.arcnum;
    for(int i = 0; i < G.vexnum; i++)
        for(int j = 0; j < G.vexnum; j ++)
            G.arcs[i][j] = MaxInt;
    for(int k = 0; k < G.arcnum; k ++)
    {
        cin>>v1>>v2>>w;
        int i = LocateVex(G, v1);
        int j = LocateVex(G, v2);
        G.arcs[i][j] = w;
        G.arcs[j][i] = G.arcs[i][j];
    }
    return OK;
}

bool visited[MVNum];
void DFS(Graph G, int v)
{
    cout<<v;
    visited[v] = true;
    for(w = FirstAdjVex(G, v);w >= 0; w = NextAdjVex(G, v, w))
        if(!visited[w]) DFS(G, w);
}

void DFSTraverse(Graph G)
{
    for(int v = 0; v < G.vexnum; v++)
        visited[v] = false;
    for(int v = 0; v < G.vexnum; v ++)
        if(!visited[v]) DFS(G, v);
}

void DFS_AM(AMGraph G, int v)
{
    cout << v;
    visited[v] = true;
    for(int w = 0; w < G.vexnum; w++)
        if((G.arcs[v][w] != 0) && (!visited[w])) DFS_AM(G, w);
}

int main()
{
    
    return 0;
}
```



##### 邻接表法：



```c++
//C语言版

#include <stdio.h>
#include <stdlib.h>

#define MVNum 100	//最大顶点数
#define OK 1
#define ERROR 0
#define OVERFLOW -1

typedef int Status;
typedef char VerTexType; // 顶点类型改为char

typedef struct ArcNode //边结点
{
    int adjvex;		//该边所指向的顶点的位置
    struct ArcNode *nextarc;	//指向下一条边的指针
    struct OtherInfo 
    {
        // 可根据需要添加额外信息
    } info;
    
} ArcNode;

typedef struct VNode //顶点信息
{
    VerTexType data;	
    ArcNode *firstarc;		//指向第一条依附该顶点的边的指针
} VNode, AdjList[MVNum];	//AdjList表示邻接表类型

typedef struct //邻接表
{
    AdjList vertices;
    int vexnum, arcnum;		//图的当前顶点数和边数
} ALGraph;

// 根据顶点值查找顶点索引
int LocateVex(ALGraph *G, VerTexType v) 
{
    for (int i = 0; i < G->vexnum; i++) 
    {
        if (G->vertices[i].data == v) 
        {
            return i;
        }
    }
    return -1; // 如果没有找到，返回 -1
}

Status CreateUDG(ALGraph *G) {
    int i, j, k;
    VerTexType v1, v2;
    scanf("%d %d", &G->vexnum, &G->arcnum);//输入总顶点数，总边数
    
    for (i = 0; i < G->vexnum; i++) 
    {//输入各点，构造表头结点表
        scanf(" %c", &G->vertices[i].data);	//输入顶点值
        G->vertices[i].firstarc = NULL;		//初始化表头节点的指针域为NULL
    }
    
    for (k = 0; k < G->arcnum; k++) 
    {//输入各边，构造边表
        scanf(" %c %c", &v1, &v2);//输入一条边依附的两个顶点
        i = LocateVex(G, v1);
        j = LocateVex(G, v2);
        if (i == -1 || j == -1) 
        {
            return ERROR; // 错误处理
        }
        //生成一个新的边结点*p1
        ArcNode *p1 = (ArcNode *)malloc(sizeof(ArcNode));	
        //邻接表的序号为j
        p1->adjvex = j;
        //将新结点*p1插入顶点vi的边表头部
        p1->nextarc = G->vertices[i].firstarc;
        G->vertices[i].firstarc = p1;
        
       //生成另一个对称的新的边结点*p2
        ArcNode *p2 = (ArcNode *)malloc(sizeof(ArcNode));
        //邻接表的序号为i
        p2->adjvex = i;
        //将新结点*p2插入顶点vj的边表头部
        p2->nextarc = G->vertices[j].firstarc;
        G->vertices[j].firstarc = p2;
    }
    return OK;
}

bool visited[MVNum];//访问标志数组，其初值为“false”

void DFS(ALGraph *G, int v) 
{//图G为邻接矩阵类型，从第v个顶点出发深度优先搜索遍历图G
    printf("%c ", G->vertices[v].data);
    visited[v] = true;//访问第v个顶点，并置访问标志数组相应分量值为true
    for (ArcNode *p = G->vertices[v].firstarc; p != NULL; p = p->nextarc) 
    {
        int w = p->adjvex;	//表示w是v的邻接点
        if (!visited[w]) DFS(G, w);	//如果w未访问，则递归调用DFS()
    }
}

void DFSTraverse(ALGraph *G) {
    for (int v = 0; v < G->vexnum; v++) {
        visited[v] = false;
    }
    for (int v = 0; v < G->vexnum; v++) {
        if (!visited[v]) DFS(G, v);
    }
}

int main() {
    ALGraph G;
    if (CreateUDG(&G) == OK) 
    {
        DFSTraverse(&G);
    } 
    else 
    {
        printf("Error creating graph\n");
    }
    return 0;
}

```





```c++
//c++版

/*
测试案例：
5 5
A B C D E
A B
A C
B D
C D
C E
输出：
A C E D B

*/

#include <iostream>
using namespace std;

#define MaxInt 32767
#define MVNum 100
#define OK 1
#define ERROR 0
#define OVERFLOW -1

typedef int Status;
typedef char VerTexType; // 顶点类型改为char

typedef struct ArcNode {
    int adjvex;
    struct ArcNode *nextarc;
    struct OtherInfo {
        // 可根据需要添加额外信息
    } info;
} ArcNode;

typedef struct VNode {
    VerTexType data;
    ArcNode *firstarc;
} VNode, AdjList[MVNum];

typedef struct {
    AdjList vertices;
    int vexnum, arcnum;
} ALGraph;

// 根据顶点值查找顶点索引
int LocateVex(ALGraph &G, VerTexType v) {
    for (int i = 0; i < G.vexnum; i++) {
        if (G.vertices[i].data == v) {
            return i;
        }
    }
    return -1; // 如果没有找到，返回 -1
}

Status CreateUDG(ALGraph &G) {
    int i, j;
    VerTexType v1, v2;
    cin >> G.vexnum >> G.arcnum;
    for (int i = 0; i < G.vexnum; i++) {
        cin >> G.vertices[i].data;
        G.vertices[i].firstarc = NULL;
    }
    for (int k = 0; k < G.arcnum; k++) {
        cin >> v1 >> v2;
        i = LocateVex(G, v1);
        j = LocateVex(G, v2);
        if (i == -1 || j == -1) {
            return ERROR; // 错误处理
        }
        ArcNode *p1 = new ArcNode;
        p1->adjvex = j;
        p1->nextarc = G.vertices[i].firstarc;
        G.vertices[i].firstarc = p1;
        ArcNode *p2 = new ArcNode;
        p2->adjvex = i;
        p2->nextarc = G.vertices[j].firstarc;
        G.vertices[j].firstarc = p2;
    }
    return OK;
}

bool visited[MVNum];

void DFS(ALGraph &G, int v) {
    cout << G.vertices[v].data << " ";
    visited[v] = true;
    for (ArcNode *p = G.vertices[v].firstarc; p != NULL; p = p->nextarc) {
        int w = p->adjvex;
        if (!visited[w]) DFS(G, w);
    }
}

void DFSTraverse(ALGraph &G) {
    for (int v = 0; v < G.vexnum; v++) {
        visited[v] = false;
    }
    for (int v = 0; v < G.vexnum; v++) {
        if (!visited[v]) DFS(G, v);
    }
}

int main() {
    ALGraph G;
    if (CreateUDG(G) == OK) {
        DFSTraverse(G);
    } else {
        cout << "Error creating graph" << endl;
    }
    return 0;
}

```



**书中伪代码：**

```c++
//
// Created by lct2023 on 2024/5/20.
//
#include <iostream>
using namespace std;

#define MaxInt 32767
#define MVNum 100
#define OK 1
#define ERROR 0
#define OVERFLOW -1
typedef int Status;
typedef struct ArcNode
{
    int adjvex;
    struct ArcNode * nextarc;
    OtherInfo info;
}ArcNode;

typedef struct VNode
{
    VerTexType data;
    ArcNode *firstarc;
}VNode, AdjList[MVNum];

typedef struct
{
    AdjList vertices;
    int vexnum, arcnum;
}ALGraph;

Status CreateUDG(ALGraph &G)
{
    cin>>G.vexnum>>G.arcnum;
    for(int i = 0; i <G.vexnum; i ++)
    {
        cin>>G.vexnum[i].data;
        G.vertices[i].firstarc = NULL;
    }
    for(int k = 0; k < G.arcnum; k++)
    {
        cin>>v1>>v2;
        i = LocateVex(G, v1);
        j = LocateVex(G, v2);
        p1 = new ArcNode;
        p1->adjvex = j;
        p1->nextarc = G.vertices[i].firstarc;
        G.vertices[i].firstarc = p1;
        p2 = new ArcNode;
        p2->adjvex = i;
        p2->nextarc = G.vertices[j].firstarc;
        G.vertices[j].firstarc = p2;
    }
    return OK;
}

bool visited[MVNum];
void DFS(Graph G, int v)
{
    cout<<v;
    visited[v] = true;
    for(w = FirstAdjVex(G, v);w >= 0; w = NextAdjVex(G, v, w))
        if(!visited[w]) DFS(G, w);
}

void DFSTraverse(Graph G)
{
    for(int v = 0; v < G.vexnum; v++)
        visited[v] = false;
    for(int v = 0; v < G.vexnum; v ++)
        if(!visited[v]) DFS(G, v);
}

void DFS_AL(ALGraph G, int v)
{
    cout<<v;
    visited[v] = true;
    p = G.vertices[v].firstarc;
    while(p != NULL)
    {
        w = p->adjvex;
        if(!visited[w]) DFS_AL(G, w);
        p = p->nextarc;
    }
}
```



#### 图的操作例子：

##### 邻接矩法:

```c++
#include <stdio.h>
#include <limits.h>
#include <stdlib.h> // For memory allocation functions

#define INFINITY INT_MAX
#define MAX_VNUM 20
#define ERROR 0
#define OK 1
#define OVERFLOW -1

typedef int Status;
typedef enum {DG, DN, UDG, UDN} GraphKind;

typedef int VRType;
typedef char VertexType;
typedef char InfoType;

typedef struct ArcCell 
{
    VRType adj;
    InfoType *info;
} ArcCell, AdjMatrix[MAX_VNUM][MAX_VNUM];

typedef struct 
{
    VertexType vexs[MAX_VNUM];
    AdjMatrix arcs;
    int vexnum, arcnum;
    GraphKind kind;
} MGraph;

// Function prototypes
Status CreateDG(MGraph &G);//构造有向图G
Status CreateDN(MGraph &G);//构造有向网G
Status CreateUDG(MGraph &G);//构造无向图G
Status CreateUDN(MGraph &G);//构造无向网G

int LocateVex(MGraph &G, VertexType v)
{//初始条件：图G存在，u和G中顶点有相同特征
    //操作结果：若G中存在顶点u，则返回该顶点在图中位置；否则返回-1
    for (int i = 0; i < G.vexnum; i++) {
        if (G.vexs[i] == v) {
            return i;
        }
    }
    return -1; // Vertex not found
}

void Input(InfoType &info) {
    // 从标准输入中读取一个字符
    scanf(" %c", &info);
}

Status CreateDG(MGraph &G) {
    // Placeholder implementation for directed graph creation
    printf("Creating Directed Graph (DG)\n");
    return OK;
}

Status CreateDN(MGraph &G) {
    // Placeholder implementation for directed network creation
    printf("Creating Directed Network (DN)\n");
    return OK;
}

Status CreateUDG(MGraph &G) {
    // Placeholder implementation for undirected graph creation
    printf("Creating Undirected Graph (UDG)\n");
    return OK;
}

Status CreateUDN(MGraph &G)
{//采用邻接矩阵表示法，构造无向网
    int Inclnfo; // Variable to indicate if there is additional information
    scanf("%d %d %d", &G.vexnum, &G.arcnum, &Inclnfo);

    for (int i = 0; i < G.vexnum; i++) {
        scanf(" %c", &G.vexs[i]);
    }

    for (int i = 0; i < G.vexnum; i++) {
        for (int j = 0; j < G.vexnum; j++) {
            G.arcs[i][j].adj = INFINITY;
            G.arcs[i][j].info = NULL;
        }
    }

    for (int k = 0; k < G.arcnum; k++) {
        VertexType v1, v2;
        VRType w;
        getchar();//吸收 上个scanf后续没接收换行或空格
        scanf("%c %c %d", &v1, &v2, &w);
        int i = LocateVex(G, v1);
        int j = LocateVex(G, v2);

        G.arcs[i][j].adj = w;
        G.arcs[j][i].adj = w; // Ensure symmetry for undirected graph
        if (Inclnfo)
        {
            G.arcs[i][j].info = (InfoType *)malloc(sizeof(InfoType)); // Allocate memory for info
            Input(*G.arcs[i][j].info);
            G.arcs[j][i].info = G.arcs[i][j].info; // Ensure same info for symmetric edge
        }
        // Debugging output to ensure edges are being added correctly
        printf("Added edge: %c - %c with weight %d\n", v1, v2, w);
    }
    return OK;
}

Status CreateGraph(MGraph &G) {
    int kind;
    if (scanf("%d", &kind) != 1) {
        return ERROR;
    }
    //将从输入中读取的整数值 kind 转换为枚举类型 GraphKind
    //并将结果存储在结构体 MGraph 的成员变量 kind 中。
    G.kind = (GraphKind)kind;//枚举法

    switch (G.kind) {
        case DG:
            return CreateDG(G);
        case DN:
            return CreateDN(G);
        case UDG:
            return CreateUDG(G);
        case UDN:
            return CreateUDN(G);
        default:
            return ERROR;
    }
}

VertexType& GetVex(MGraph G, int v)
{//初始条件：图G存在，v是G中某个顶点的序号
    //操作结果：返回v的值
    if (v >= G.vexnum || v < 0) exit(ERROR);
    return G.vexs[v];
}

Status PutVex(MGraph &G, VertexType v, VertexType value)
{//初始条件：图G存在，v是G中的某个顶点
    //操作结果：对v赋新值value
    int k = LocateVex(G, v);//k为顶点v在图G中的序号
    if (k < 0) return ERROR;
    G.vexs[k] = value;
    return OK;
}

int FirstAdjVex(MGraph G, VertexType v)
{//初始条件：图G存在，v是G中某个顶点
    //操作结果：返回v的第一个邻接顶点的序号
    //若顶点在G中没有邻接顶点，则返回-1
    int k = LocateVex(G, v);//k为顶点v在图G中的序号
    if (k < 0) return ERROR;

    for (int i = 0; i < G.vexnum; i++)
    {
        if (G.arcs[k][i].adj != INFINITY) {
            return i;
        }
    }
    return ERROR;
}

int NextAdjVex(MGraph G, VertexType v, VertexType w)
{//初始条件：图G存在，v是G中某个顶点
    //操作结果：返回v的（相对与w的)下一个邻接顶点的序号。
    //若w是v的最后一个邻接顶点，则返回-1
    int k1 = LocateVex(G, v);
    int k2 = LocateVex(G, w);
    if (k1 < 0 || k2 < 0) return ERROR;

    for (int i = k2 + 1; i < G.vexnum; i++)
    {
        if (G.arcs[k1][i].adj != INFINITY)
        {
            return i;
        }
    }
    return ERROR;
}

void PrintGraph(MGraph G)
{
    printf("Graph vertices: ");
    for (int i = 0; i < G.vexnum; i++)
    {
        printf("%c ", G.vexs[i]);
    }
    printf("\nGraph adjacency matrix:\n");
    for (int i = 0; i < G.vexnum; i++)
    {
        for (int j = 0; j < G.vexnum; j++)
        {
            if (G.arcs[i][j].adj == INFINITY)
            {
                printf("INF ");
            }
            else
            {
                printf("%d ", G.arcs[i][j].adj);
            }
        }
        printf("\n");
    }
}

int main()
{
    MGraph G;
    Status status = CreateGraph(G);
    if (status == OK)
    {
        printf("Graph created successfully\n");
        PrintGraph(G);
    }
    else
    {
        printf("Error in creating graph\n");
    }
    return 0;
}

```



##### 邻接链表法：

```c++
#include <iostream>
#include <cstring>
#include <cstdlib>
#include "queue"

#define MAX_VERTEX_NUM 20
#define OK 1
#define ERROR 0
typedef char InfoType;
typedef char VertexType;
typedef int Status;
typedef struct ArcNode
{//表结点
    int adjvex;//该弧所指向的顶点的位置
    struct ArcNode *nextarc;//指向下一条弧的指针
    InfoType *info;//该弧相关信息的指针
};

typedef struct VNode
{//头结点
    VertexType data;//顶点信息
    ArcNode *firstarc;//指向第一个表结点
} VNode, AdjList[MAX_VERTEX_NUM];

typedef struct
{
    AdjList vertices;
    int vexnum, arcnum;
    int kind;//表示图的种类
} ALGraph;

int LocateVex(ALGraph &G, VertexType v)
{//初始条件：图G存在，u和G中顶点有相同特征
    //操作结果：若G中存在顶点u，则返回该顶点在图中位置；否则返回-1
    for (int i = 0; i < G.vexnum; i++) {
        if (G.vertices[i].data == v) {
            return i;
        }
    }
    return -1; // Vertex not found
}

Status CreateUDG(ALGraph *G) {
    int i, j, k;
    VertexType v1, v2;
    scanf("%d %d", &G->vexnum, &G->arcnum);//输入总顶点数，总边数

    for (i = 0; i < G->vexnum; i++)
    {//输入各点，构造表头结点表
        getchar();
        scanf("%c", &G->vertices[i].data);	//输入顶点值
        G->vertices[i].firstarc = NULL;		//初始化表头节点的指针域为NULL
    }

    for (k = 0; k < G->arcnum; k++)
    {//输入各边，构造边表
        getchar();
        scanf("%c %c", &v1, &v2);//输入一条边依附的两个顶点
        i = LocateVex(*G, v1);
        j = LocateVex(*G, v2);
        if (i == -1 || j == -1)
        {
            return ERROR; // 错误处理
        }
        //生成一个新的边结点*p1
        ArcNode *p1 = (ArcNode *)malloc(sizeof(ArcNode));
        //邻接表的序号为j
        p1->adjvex = j;
        //将新结点*p1插入顶点vi的边表头部
        p1->nextarc = G->vertices[i].firstarc;
        G->vertices[i].firstarc = p1;

        //生成另一个对称的新的边结点*p2
        ArcNode *p2 = (ArcNode *)malloc(sizeof(ArcNode));
        //邻接表的序号为i
        p2->adjvex = i;
        //将新结点*p2插入顶点vj的边表头部
        p2->nextarc = G->vertices[j].firstarc;
        G->vertices[j].firstarc = p2;
        printf("Added edge: %c --> %c\n", v1, v2);
    }
    return OK;
}

// 获取某个顶点的第一个邻接顶点
int FirstAdjVex(ALGraph G, VertexType v)
{//初始条件：图G存在，v是G中某个顶点
    //操作结果：返回v的第一个邻接顶点的序号
    //若顶点在G中没有邻接顶点，则返回-1
    ArcNode *p;
    int v1 = LocateVex(G, v);
    p = G.vertices[v1].firstarc;
    if (p)   return p->adjvex;
    else return -1;
}

// 获取某个顶点的下一个邻接顶点
int NextAdjVex(ALGraph G, VertexType v, VertexType w)
{//初始条件：图G存在，v是G中某个顶点
    //操作结果：返回v的（相对于w的）下一个邻接顶点的序号。
    //若w是v的最后一个邻接顶点，则返回-1
    ArcNode *p;
    int i = LocateVex(G, v);
    int j = LocateVex(G, w);
    p = G.vertices[i].firstarc;
    if (!p || !p->nextarc)   return -1;//没找到w或w是最后一个邻接点
    else    return p->nextarc->adjvex;
}

void InsertVex(ALGraph &G, VertexType v)
{//初始条件：图G存在，v和图中顶点有相同的特征
    //操作结果：在图G中增添新顶点v（不增添与顶点相关的弧，留待InsertArc()去做）
    strcpy(reinterpret_cast<char *>(G.vertices[G.vexnum].data), reinterpret_cast<const char *>(v));//构造新顶点向量
    G.vertices[G.vexnum].firstarc = NULL;
    G.vexnum++;
}

Status InsertArc(ALGraph &G, VertexType v, VertexType w)
{
    ArcNode *p;
    int w1, i, j;
    i = LocateVex(G, v);
    j = LocateVex(G, w);
    if (i < 0 || j < 0) return ERROR;
    G.arcnum++;
    if (G.kind % 2)
    {
        printf("Please enter the weight of the arc (edge)%s->%s:", v, w);
        scanf("%d", &w1);
    }
    p = (ArcNode*)malloc(sizeof(ArcNode));
    p->adjvex = j;
    if (G.kind % 2)
    {//网
        p->info = (char*)malloc(sizeof(char));
        *(p->info) = w1;
    }
    else    p->info = NULL;
    p->nextarc = G.vertices[i].firstarc;
    G.vertices[i].firstarc = p;
    if (G.kind >= 2)
    {//无向，生成另一个表结点
        p = (ArcNode*)malloc(sizeof(ArcNode));
        p->adjvex = i;
        if (G.kind == 3)
        {
            p->info = (char*)malloc(sizeof(char));
            *(p->info) = w1;
        }
        else    p->info = NULL;
        p->nextarc = G.vertices[i].firstarc;
        G.vertices[i].firstarc = p;
    }
    return OK;
}

void Visit(ALGraph G,int v) 
{
    std::cout << "Visited vertex: " << G.vertices[v].data << std::endl;
}

bool visited[MAX_VERTEX_NUM] = {false}; // 初始化所有顶点为未访问状态

class queue;

void DFS(ALGraph G, int v0)
{
    visited[v0] = true; // 标记当前顶点为已访问
    Visit(G, v0); // 访问当前顶点，例如打印操作
    ArcNode *p = G.vertices[v0].firstarc;
    while(p)
    {
        int w = p->adjvex;
        if(!visited[w]) // 如果相邻顶点未被访问
            DFS(G, w); // 递归访问相邻顶点
        p = p->nextarc;
    }
}

void BFS(ALGraph G, int v0) 
{
    std::queue<int> q;
    visited[v0] = true;
    Visit(G, v0);
    q.push(v0);

    while (!q.empty()) 
    {
        int v = q.front();
        q.pop();
        ArcNode *p = G.vertices[v].firstarc;
        while (p) 
        {
            int w = p->adjvex;
            if (!visited[w]) 
            {
                visited[w] = true;
                Visit(G, w);
                q.push(w);
            }
            p = p->nextarc;
        }
    }
}

/*
void BFS(AdjList *g, int i)
{
    int q[max_vertex_num]; // 用于模拟访问过结点的队列
    int front = 0, rear = 0; // front为队列的头部，rear为队列的尾部

    printf("%c", g->vertex[i].data);
    visisted1[i] = 1;
    q[rear++] = i; // 模拟入队

    Node *p;

    while (rear > front)
    {
        int temp = q[front++]; // 模拟出队
        p = g->vertex[temp].firstarc;

        while (p != NULL)
        {
            int neighbor = p->adjvex;
            if (!visisted1[neighbor])
            {
                printf("%c", g->vertex[neighbor].data);
                visisted1[neighbor] = 1;
                q[rear++] = neighbor; // 模拟入队
            }
            p = p->nextarc;
        }
    }
}
*/

void PrintGraph(ALGraph G) {
    std::cout << "Graph vertices: ";
    for (int i = 0; i < G.vexnum; ++i)
    {
        std::cout << G.vertices[i].data << " ";
    }
    std::cout << std::endl << "Graph adjacency list:" << std::endl;
    for (int i = 0; i < G.vexnum; ++i)
    {
        std::cout << G.vertices[i].data << " -> ";
        ArcNode *p = G.vertices[i].firstarc;
        while (p != NULL)
        {
            std::cout << G.vertices[p->adjvex].data << " ";
            p = p->nextarc;
        }
        std::cout << std::endl;
    }
}

void isConnected(ALGraph G, int v1, int v2, int &flag)
{
    if (v1 == v2)
    {
        flag = true;
        return;
    }
    visited[v1] = true;
    ArcNode *p = G.vertices[v1].firstarc;
    while (p != NULL)
    {
        int w = p->adjvex;
        if (!visited[w])
            isConnected(G, w, v2, flag);
        if (flag) // If connection found, no need to continue
            return;
        p = p->nextarc;
    }
}

int CountConnectedComponents(ALGraph G) 
{
    int count = 0;
    memset(visited, false, sizeof(visited));
    for (int i = 0; i < G.vexnum; i++) 
    {
        if (!visited[i]) 
        {
            DFS(G, i);
            count++;
        }
    }
    return count;
}


bool DFSForCycle(ALGraph G, int v, int parent) 
{
    visited[v] = true;
    ArcNode *p = G.vertices[v].firstarc;
    while (p != NULL) 
    {
        int w = p->adjvex;
        if (!visited[w]) 
        {
            if (DFSForCycle(G, w, v)) 
            {
                return true;
            }
        } 
        else if (w != parent) 
        {
            return true; // Cycle found
        }
        p = p->nextarc;
    }
    return false;
}

bool hasCycle(ALGraph G) 
{
    memset(visited, false, sizeof(visited));
    for (int i = 0; i < G.vexnum; i++) 
    {
        if (!visited[i]) 
        {
            if (DFSForCycle(G, i, -1)) 
            {
                return true;
            }
        }
    }
    return false;
}

int main()
{
    ALGraph G;
    G.vexnum = 0;
    G.arcnum = 0;
    G.kind = 3; // Assume undirected graph for this example

    CreateUDG(&G);
    PrintGraph(G);

    // 从第一个顶点开始进行深度优先搜索
    std::cout << "DFS Traversal:" << std::endl;
    memset(visited, false, sizeof(visited)); // 重置访问标志
    DFS(G, 0); // 从第一个顶点开始深度优先搜索

    std::cout << "BFS Traversal:" << std::endl;
    memset(visited, false, sizeof(visited));
    BFS(G, 0);

    // 检查两个顶点是否连通
    VertexType v1, v2;
    std::cout << "Enter two vertices to check if they are connected (as characters): ";
    std::cin >> v1 >> v2;

    int v1Index = LocateVex(G, v1);
    int v2Index = LocateVex(G, v2);

    if (v1Index == -1 || v2Index == -1)
    {
        std::cout << "Invalid vertex." << std::endl;
        return 1;
    }

    int flag = false;
    memset(visited, false, sizeof(visited)); // 重置访问标志
    isConnected(G, v1Index, v2Index, flag);

    if (flag) std::cout << "Vertices " << v1 << " and " << v2 << " are connected." << std::endl;
    else std::cout << "Vertices " << v1 << " and " << v2 << " are not connected." << std::endl;

    int connectedComponents = CountConnectedComponents(G);
    std::cout << "Number of connected components in the graph: " << connectedComponents << std::endl;

    bool cycleExists = hasCycle(G);
    if (cycleExists) std::cout << "The graph contains a cycle." << std::endl;
    else std::cout << "The graph does not contain a cycle." << std::endl;

    return 0;
}

//int main()
//{
//    ALGraph G;
//    G.vexnum = 0;
//    G.arcnum = 0;
//    G.kind = 3; // Assume undirected graph for this example
//
//    // 创建无向图
//    CreateUDG(&G);
//
//    PrintGraph(G);
//
//    // 插入新顶点 'A'
//    InsertVex(G, 'A');
//
//    PrintGraph(G);
//
//    // 插入新顶点 'B'
//    InsertVex(G, 'B');
//
//    PrintGraph(G);
//
//    // 插入边 'A' -> 'B'
//    InsertArc(G, 'A', 'B');
//
//    PrintGraph(G);
//
//    // 获取顶点 'A' 的第一个邻接顶点
//    int adj = FirstAdjVex(G, 'A');
//
//    if (adj != -1)
//    {
//        std::cout << "First adjacent vertex of A: " << G.vertices[adj].data << std::endl;
//    }
//    else
//    {
//        std::cout << "A has no adjacent vertices." << std::endl;
//    }
//
//    // 获取顶点 'A' 的下一个邻接顶点
//    int nextAdj = NextAdjVex(G, 'A', G.vertices[adj].data);
//    if (nextAdj != -1)
//    {
//        std::cout << "Next adjacent vertex of A after " << G.vertices[adj].data << ": " << G.vertices[nextAdj].data << std::endl;
//    }
//    else
//    {
//        std::cout << "No more adjacent vertices of A after " << G.vertices[adj].data << std::endl;
//    }
//
//    // 打印图的信息
//    PrintGraph(G);
//
//    return 0;
//}
```



#### 最小生成树算法（邻接矩阵法）：

```c
#include <iostream>
#include <cstring>

#define OK 1
#define ERROR -1
#define MAX_VERTEX_NUM 100
#define INFINITY 99999  // Use a large value to represent infinity

typedef char InfoType;
typedef char VertexType;
typedef int Status;
typedef int VRType;

typedef struct ArcCell {
    VRType adj;
    InfoType *info;
} ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];

typedef struct {
    VertexType vexs[MAX_VERTEX_NUM];
    AdjMatrix arcs;
    int vexnum, arcnum;
    int kind;
} AMGraph;

int LocateVex(AMGraph G, VertexType v) {
    for (int k = 0; k < G.vexnum; k++)
        if (G.vexs[k] == v) return k;
    return -1;
}

void Input(InfoType &info) {
    // 从标准输入中读取一个字符
    scanf(" %c", &info);
}

Status CreateUDN(AMGraph &G)
{//采用邻接矩阵表示法，构造无向网
    int Inclnfo; // Variable to indicate if there is additional information
    scanf("%d %d %d", &G.vexnum, &G.arcnum, &Inclnfo);

    for (int i = 0; i < G.vexnum; i++) {
        scanf(" %c", &G.vexs[i]);
    }

    for (int i = 0; i < G.vexnum; i++) {
        for (int j = 0; j < G.vexnum; j++) {
            G.arcs[i][j].adj = INFINITY;
            G.arcs[i][j].info = NULL;
        }
    }

    for (int k = 0; k < G.arcnum; k++) {
        VertexType v1, v2;
        VRType w;
        getchar();//吸收 上个scanf后续没接收换行或空格
        scanf("%c %c %d", &v1, &v2, &w);
        int i = LocateVex(G, v1);
        int j = LocateVex(G, v2);

        G.arcs[i][j].adj = w;
        G.arcs[j][i].adj = w; // Ensure symmetry for undirected graph
        if (Inclnfo)
        {
            G.arcs[i][j].info = (InfoType *)malloc(sizeof(InfoType)); // Allocate memory for info
            Input(*G.arcs[i][j].info);
            G.arcs[j][i].info = G.arcs[i][j].info; // Ensure same info for symmetric edge
        }
        // Debugging output to ensure edges are being added correctly
        printf("Added edge: %c - %c with weight %d\n", v1, v2, w);
    }
    return OK;
}


//普利姆算法
typedef struct
{//辅助数组的定义，用来记录从顶点集U到V—U的权值最小的边
    VertexType adjvex;//最小边在U中的那个顶点
    VRType lowcost;//最小边上的权值
} EdgeNode;

//辅助数组的定义，用来记录从顶点集U到V—U的权值最小的边
EdgeNode closedge[MAX_VERTEX_NUM];  // Correct definition of closedge

void MiniSpanTree_Prim(AMGraph G, VertexType u)
{
    int k = LocateVex(G, u);
    if (k == -1)
    {
        std::cerr << "Vertex not found!" << std::endl;
        return;
    }

    for (int j = 0; j < G.vexnum; j++)
    {//对V—U的每一个顶点初始化closedge[j]
        if (j != k)
            closedge[j] = {G.vexs[k], G.arcs[k][j].adj};
    }
    closedge[k].lowcost = 0;  // Initialize the starting vertex cost to 0

    int totalWeight = 0;

    for (int i = 1; i < G.vexnum; i++)
    {//选择其余n - 1个顶点，生成n - 1条边(n = G.vexnum)
        VRType min = INFINITY;
        int minIndex = -1;
        for (int j = 0; j < G.vexnum; j++)
        {
            if (closedge[j].lowcost != 0 && closedge[j].lowcost < min)
            {
                min = closedge[j].lowcost;
                minIndex = j;
            }
        }

        if (minIndex == -1)
        {
            std::cerr << "No connected minimum edge found!" << std::endl;
            return;
        }

        std::cout << "(" << closedge[minIndex].adjvex << ", " << G.vexs[minIndex] << ")"
            << " with weigth " << closedge[minIndex].lowcost << std::endl;
        totalWeight += closedge[minIndex].lowcost;
        closedge[minIndex].lowcost = 0;//第minIndex个顶点并入U集

        for (int j = 0; j < G.vexnum; j++)
        {
            if (G.arcs[minIndex][j].adj < closedge[j].lowcost && closedge[j].lowcost != 0)
            {//新顶点并入U后重新选择最小边
                closedge[j] = {G.vexs[minIndex], G.arcs[minIndex][j].adj};
            }
        }
    }
    printf("Total weight of the Minimum Spanning Tree: %d\n", totalWeight);
}



//克鲁斯卡尔算法
typedef struct
{
    VertexType Head;//边的始点
    VertexType Tail;//边的终点
    VRType weight;//边上的权值
} Edge;//存储边的信息

void SwapEdges(Edge *a, Edge *b)
{
    Edge temp = *a;
    *a = *b;
    *b = temp;
}

void SortEdges(Edge edges[], int edgeCount)
{
    // Simple bubble sort for edges based on their weights
    for (int i = 0; i < edgeCount - 1; i++)
    {
        for (int j = 0; j < edgeCount - 1 - i; j++)
        {
            if (edges[j].weight > edges[j + 1].weight)
            {
                SwapEdges(&edges[j], &edges[j + 1]);
            }
        }
    }
}

void MiniSpanTree_Kruskal(AMGraph G)
{
    Edge edges[MAX_VERTEX_NUM * (MAX_VERTEX_NUM - 1) / 2];
    int edgeCount = 0;

    // Collect all edges from the adjacency matrix
    for (int i = 0; i < G.vexnum; i++)
    {
        for (int j = i + 1; j < G.vexnum; j++)
        {
            if (G.arcs[i][j].adj != INFINITY)
            {
                edges[edgeCount].Head = G.vexs[i];
                edges[edgeCount].Tail = G.vexs[j];
                edges[edgeCount].weight = G.arcs[i][j].adj;
                edgeCount++;
            }
        }
    }

    // Sort edges based on weight
    SortEdges(edges, edgeCount);

    int Vexset[MAX_VERTEX_NUM];//标识各个顶点所属的连通分量

    for (int i = 0; i < G.vexnum; i++)
        Vexset[i] = i;//初始化，这表示各顶点自成一个连通分量

    int totalWeight = 0;

    // Kruskal's algorithm
    for (int i = 0; i < edgeCount; i++)
    {
        int v1 = LocateVex(G, edges[i].Head);
        int v2 = LocateVex(G, edges[i].Tail);
        int vs1 = Vexset[v1];
        int vs2 = Vexset[v2];

        if (vs1 != vs2)//边的两个顶点分属不同的连通分量
        {
            //输出此边
            printf("%c - %c with weight %d\n", edges[i].Head, edges[i].Tail, edges[i].weight);

            totalWeight += edges[i].weight;

            //集合编号为vs2的都改为vs1
            for (int j = 0; j < G.vexnum; j++)
                if (Vexset[j] == vs2) Vexset[j] = vs1;
        }
    }
    printf("Total weight of the Minimum Spanning Tree: %d\n", totalWeight);
}


/*
//克鲁斯卡尔算法(C++版)
typedef struct {
    int begin;
    int end;
    int weight;
} Edge;

// 并查集相关函数
int find(int *parent, int i) {
    while (parent[i] != i) {
        i = parent[i];
    }
    return i;
}

void Union(int *parent, int i, int j) {
    int irep = find(parent, i);
    int jrep = find(parent, j);
    if (irep != jrep) {
        parent[irep] = jrep;
    }
}

int compareEdges(const void *a, const void *b) {
    Edge *edge1 = (Edge *)a;
    Edge *edge2 = (Edge *)b;
    return edge1->weight - edge2->weight;
}

void MiniSpanTree_Kruskal(AMGraph G) {
    Edge edges[MAX_VERTEX_NUM * (MAX_VERTEX_NUM - 1) / 2];
    int edgeCount = 0;

    for (int i = 0; i < G.vexnum; i++) {
        for (int j = i + 1; j < G.vexnum; j++) {
            if (G.arcs[i][j].adj != INFINITY) {
                edges[edgeCount].begin = i;
                edges[edgeCount].end = j;
                edges[edgeCount].weight = G.arcs[i][j].adj;
                edgeCount++;
            }
        }
    }

    qsort(edges, edgeCount, sizeof(Edge), compareEdges);

    int parent[MAX_VERTEX_NUM];
    for (int i = 0; i < G.vexnum; i++) {
        parent[i] = i;
    }

    int numEdges = 0;
    for (int i = 0; i < edgeCount; i++) {
        int u = find(parent, edges[i].begin);
        int v = find(parent, edges[i].end);

        if (u != v) {
            printf("(%c, %c) - %d\n", G.vexs[edges[i].begin], G.vexs[edges[i].end], edges[i].weight);
            Union(parent, u, v);
            numEdges++;
        }

        if (numEdges == G.vexnum - 1) {
            break;
        }
    }
}
*/

int main() {
    // Create an example graph for demonstration.
    AMGraph G;

    CreateUDN(G);

    std::cout << "Minimum Spanning Tree using Prim's Algorithm:" << std::endl;
    MiniSpanTree_Prim(G, 'A');

    std::cout << "Minimum Spanning Tree using Kruskal's Algorithm:" << std::endl;
    MiniSpanTree_Kruskal(G);

    return 0;
}

```



#### 1. 图的基本操作--图的深度优先和广度优先遍历

```c
//
// Created by lct2023 on 2024/5/26.
//
#include <stdio.h>

#include <stdlib.h>

#define max_vertex_num 100 //最多顶点个数

typedef char VertexData;

typedef int AdjType;

typedef int OtherInfo;

int visisted[max_vertex_num] = {0}; //供深度优先遍历使用

int visisted1[max_vertex_num] = {0};//供广度优先遍历使用


typedef struct Node
{

    int adjvex;  //定义该弧指向顶点的位置

    struct Node *nextarc; //定义下一条弧上网指针

} Node;


typedef struct VVertexNode
{

    char data; //定义顶点的数据

    Node *firstarc;  //定义该顶点第一条弧的指针

} VertexNode[max_vertex_num];


typedef struct
{

    VertexNode vertex;
	int vexnum, arcnum;

} AdjList;  //定义邻接表



int LocateVertex(AdjList *G, VertexData v)  //求顶点的位置

{

    int j = -1, k;

    for (k = 0; k < G->vexnum; k++)
    {
    	if(G->vertex[k].data == v)	return k;
	}

    return (j);

}


void CreateList(AdjList *G) //用邻接表创建无向图

{

    int i;

    char v1, v2;

    printf("用邻接表来创建图\n请输入图的顶点个数和弧数\n");

    scanf("%d%d", &G->vexnum, &G->arcnum);

    printf("请用一行输入图的各个顶点,不用逗号隔开\n");

    getchar();

    for (i = 0; i < G->vexnum; i++)
    {

        scanf("%c", &G->vertex[i].data); //输入图的各个顶点

        G->vertex[i].firstarc = NULL;

    }

    printf("请用一行输入图中所有两顶点之间的弧，例如，a,b b,c b,d\n");

    int a1, a2;

    for (i = 0; i < G->arcnum; i++)
    {

        getchar();

        scanf("%c,%c", &v1, &v2);

        a1 = LocateVertex(G, v1);
        a2 = LocateVertex(G, v2);
        if(a1 == -1 || a2 == -1)	return ;
        
        Node* p1 = (Node*)malloc(sizeof(Node));
        p1->adjvex = a2;
        p1->nextarc = G->vertex[a1].firstarc;
        G->vertex[a1].firstarc = p1;
        
        Node* p2 = (Node*)malloc(sizeof(Node));
		p2->adjvex = a1;
		p2->nextarc = G->vertex[a2].firstarc;
		G->vertex[a2].firstarc = p2; 

    }
}


void print(AdjList *G)  //打印邻接表建立的图

{

    int i;

    printf("打印出用邻接表创建的无向图\n");

    for (i = 0; i < G->vexnum; i++)
    {

        printf("%c---->", G->vertex[i].data);

        Node *t;

        t = G->vertex[i].firstarc;

        while (t != NULL)
        {

            printf(" %c ", G->vertex[t->adjvex].data);

            t = t->nextarc;

        }

        printf("\n");

    }

}


void DFS(AdjList *g, int i)
{//单个节点开始进行深度优先遍历

    Node *t;

    printf("%c", g->vertex[i].data);

    visisted[i] = 1;

    t = g->vertex[i].firstarc;

    while (t)
    {

        int w = t->adjvex;
        if(!visisted[w])
        	DFS(g, w);
        t = t->nextarc;

    }

}



void BFS(AdjList *g, int i)
{
    int q[max_vertex_num]; // 用于模拟访问过结点的队列
    int front = 0, rear = 0; // front为队列的头部，rear为队列的尾部

    printf("%c", g->vertex[i].data);
    visisted1[i] = 1;
    q[rear++] = i; // 模拟入队

    Node *p;

    while (rear > front)
    {
        int temp = q[front++]; // 模拟出队
        p = g->vertex[temp].firstarc;

        while (p != NULL)
        {
            int neighbor = p->adjvex;
            if (!visisted1[neighbor])
            {
                printf("%c", g->vertex[neighbor].data);
                visisted1[neighbor] = 1;
                q[rear++] = neighbor; // 模拟入队
            }
            p = p->nextarc;
        }
    }
}


int main()
{

    AdjList GG;

    CreateList(&GG);

    print(&GG);

    printf("以A开始的深度优先遍历(DFS):\n");

    DFS(&GG, 0);

    printf("\n以A开始的广度优先遍历(BFS):\n");

    BFS(&GG, 0);

    printf("\n");

    return 0;

}
```





#### 2. 图的基本操作--基于邻接矩阵建立图

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_VERTEX_NUM 100 // 最多顶点个数
#define OK 1
#define ERROR -1

typedef char VertexData;
typedef int AdjType;
typedef int OtherInfo;

typedef struct 
{
    AdjType adj; // 对于无权图，用1表示相邻，0表示不相邻；对于带权图，则为权值类型
    OtherInfo info;
} ArcNode;

typedef struct 
{
    VertexData vertex[MAX_VERTEX_NUM]; // 存储顶点的数组
    ArcNode arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM]; // 邻接矩阵
    int vexnum, arcnum; // 顶点的个数和边的个数
} AdjMatrix; // 邻接矩阵的结构体

int LocateVertex(AdjMatrix *G, VertexData v) 
{
    // 求顶点的位置
    for (int k = 0; k < G->vexnum; k++) 
    {
        if (G->vertex[k] == v) return k;
    }
    return -1; // 未找到顶点返回-1
}

void CreateMatrix(AdjMatrix *G) 
{
    // 用邻接矩阵创建无向图
    int i, j, k;
    char v1, v2;

    printf("用邻接矩阵来创建图\n请输入图的顶点个数和弧数\n");
    scanf("%d%d", &G->vexnum, &G->arcnum);

    // 初始化邻接矩阵
    for (i = 0; i < G->vexnum; i++) 
    {
        for (j = 0; j < G->vexnum; j++) 
        {
            G->arcs[i][j].adj = 0;
        }
        
    }

    printf("请用一行输入图的各个顶点,不用逗号隔开\n");
    getchar(); // 清除缓冲区中的换行符
    for (i = 0; i < G->vexnum; i++) 
    {
        scanf("%c", &G->vertex[i]);
    }

    printf("请用一行输入图中所有两顶点之间的弧，例如，a,b b,c b,d\n");
    for (k = 0; k < G->arcnum; k++) 
    {
        getchar(); // 清除缓冲区中的换行符
        scanf("%c,%c", &v1, &v2);

        int a1 = LocateVertex(G, v1);
        int a2 = LocateVertex(G, v2);

        if (a1 == -1 || a2 == -1) 
        {
            printf("顶点不存在.\n");
            return;
        }

        G->arcs[a1][a2].adj = 1;
        G->arcs[a2][a1].adj = 1;
    }
}

void PrintMatrix(AdjMatrix *G) 
{
    // 打印邻接矩阵建立的图
    printf("打印出用邻接矩阵创建的无向图\n");
    for (int i = 0; i < G->vexnum; i++) 
    {
        for (int j = 0; j < G->vexnum; j++) 
        {
            printf("%d ", G->arcs[i][j].adj);
        }
        printf("\n");
    }
}

int main() 
{
    AdjMatrix G;

    CreateMatrix(&G);
    PrintMatrix(&G);

    return 0;
}

```



#### 3. 图的基本操作--基于邻接表建立图

```c
#include <stdio.h>
#include <stdlib.h>

#define max_vertex_num 100 //最多顶点个数

typedef char VertexData;

typedef struct Node 
{
    int adjvex;  //定义该弧指向顶点的位置
    struct Node *nextarc; //定义下一条弧上网指针
} Node;

typedef struct 
{
    VertexData data; //定义顶点的数据
    Node *firstarc;  //定义该顶点第一条弧的指针
} VertexNode;

typedef struct 
{
    VertexNode vertex[max_vertex_num];
    int vexnum, arcnum;
} AdjList;  //定义邻接表

int LocateVertex(AdjList *G, VertexData v)  //求顶点的位置
{
    for (int k = 0; k < G->vexnum; k++) {
        if (G->vertex[k].data == v) return k; 
    }
    return -1;
}

void CreateList(AdjList *G) //用邻接表创建无向图
{
    int i;
    char v1, v2;

    printf("用邻接表来创建图\n请输入图的顶点个数和弧数\n");
    scanf("%d%d", &G->vexnum, &G->arcnum);

    printf("请用一行输入图的各个顶点,不用逗号隔开\n");
    getchar(); // Consume the newline character left by previous input

    for (i = 0; i < G->vexnum; i++) 
    {
        scanf("%c", &G->vertex[i].data); //输入图的各个顶点
        G->vertex[i].firstarc = NULL;
    }

    printf("请用一行输入图中所有两顶点之间的弧，例如，a,b b,c b,d\n");

    for (i = 0; i < G->arcnum; i++) 
    {
        getchar(); // Consume the newline character left by previous input
        scanf("%c,%c", &v1, &v2);

        int a1 = LocateVertex(G, v1);
        int a2 = LocateVertex(G, v2);

        if (a1 == -1 || a2 == -1) 
        {
            printf("顶点未找到\n");
            return;
        }

        // Create first node and link it to the first arc of a1
        Node *p1 = (Node *)malloc(sizeof(Node));
        p1->adjvex = a2;
        p1->nextarc = G->vertex[a1].firstarc;
        G->vertex[a1].firstarc = p1;

        // Create second node and link it to the first arc of a2 (since the graph is undirected)
        Node *p2 = (Node *)malloc(sizeof(Node));
        p2->adjvex = a1;
        p2->nextarc = G->vertex[a2].firstarc;
        G->vertex[a2].firstarc = p2;
    }
}

void print(AdjList *G)  //打印邻接表建立的图
{
    printf("打印出用邻接表创建的无向图\n");

    for (int i = 0; i < G->vexnum; i++) 
    {
        printf("%c---->", G->vertex[i].data);

        Node *t = G->vertex[i].firstarc;
        while (t != NULL) 
        {
            printf(" %c ", G->vertex[t->adjvex].data);
            t = t->nextarc;
        }
        printf("\n");
    }
}

int main()
{
    AdjList GG;

    CreateList(&GG);
    print(&GG);

    return 0;
}

```



#### 4. 社交网络下的谣言传播分析（1）

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_VERTEX_NUM 20  // 最大顶点数

typedef struct ArcNode {
    int adjvex;  // 该边所连接的顶点的位置（即该顶点的数组下标）
    struct ArcNode *nextarc;  // 指向下一条边的指针
    int info;  // 边的权值
} ArcNode;

typedef struct VNode {
    int data;  // 顶点信息
    ArcNode *firstarc;  // 指向第一条依附该顶点的边的指针
} VNode, AdjList[MAX_VERTEX_NUM];

typedef struct ALGraph {
    AdjList vertices;
    int vexnum, arcnum;  // 图的当前顶点数和弧数
} ALGraph;

// 建立关系网的邻接表数据存储结构
void CreateUDN(ALGraph *G) {
    scanf("%d %d", &G->vexnum, &G->arcnum);
    
    // 初始化顶点表
    for (int i = 1; i <= G->vexnum; i++) {
        G->vertices[i].data = i;
        G->vertices[i].firstarc = NULL;
    }
    
    // 构建边表
    for (int i = 0; i < G->arcnum; i++) {
        int a1, a2, w;
        scanf("%d %d %d", &a1, &a2, &w);
        
        // 插入边 a1 -> a2
        ArcNode *p1 = (ArcNode*)malloc(sizeof(ArcNode));
        p1->adjvex = a2;
        p1->info = w;
        p1->nextarc = G->vertices[a1].firstarc;
        G->vertices[a1].firstarc = p1;
        
        // 插入边 a2 -> a1
        ArcNode *p2 = (ArcNode*)malloc(sizeof(ArcNode));
        p2->adjvex = a1;
        p2->info = w;
        p2->nextarc = G->vertices[a2].firstarc;
        G->vertices[a2].firstarc = p2;
    }
}

// 统计顶点的边的权值之和
int VexCount(ALGraph G, int v) 
{
    int sum = 0;
    ArcNode *p = G.vertices[v].firstarc;
    while (p != NULL) 
    {
        sum += p->info;
        p = p->nextarc;
    }
    return sum;
}

int main() 
{
    ALGraph G;
    CreateUDN(&G);

    for (int i = 0; i < G.vexnum; i++) 
    {
        printf("%d ", VexCount(G, i + 1));
    }
    printf("\n");
    return 0;
}

```



```c
//这是基于这道题的广度搜索，与这道题的逐点累加所连着的边的权值不同
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_VERTEX_NUM 20  // 最大顶点数

typedef struct ArcNode {
    int adjvex;  // 该边所连接的顶点的位置（即该顶点的数组下标）
    struct ArcNode *nextarc;  // 指向下一条边的指针
    int info;  // 边的权值
} ArcNode;

typedef struct VNode {
    int data;  // 顶点信息
    ArcNode *firstarc;  // 指向第一条依附该顶点的边的指针
} VNode, AdjList[MAX_VERTEX_NUM];

typedef struct ALGraph {
    AdjList vertices;
    int vexnum, arcnum;  // 图的当前顶点数和弧数
} ALGraph;

typedef struct Queue {
    int data[MAX_VERTEX_NUM];
    int front;
    int rear;
} Queue;

void InitQueue(Queue *Q) {
    Q->front = Q->rear = 0;
}

bool IsQueueEmpty(Queue Q) {
    return Q.front == Q.rear;
}

void EnQueue(Queue *Q, int e) {
    Q->data[Q->rear++] = e;
}

int DeQueue(Queue *Q) {
    return Q->data[Q->front++];
}

// 建立关系网的邻接表数据存储结构
void CreateUDN(ALGraph *G) {
    scanf("%d %d", &G->vexnum, &G->arcnum);
    
    // 初始化顶点表
    for (int i = 1; i <= G->vexnum; i++) {
        G->vertices[i].data = i;
        G->vertices[i].firstarc = NULL;
    }
    
    // 构建边表
    for (int i = 0; i < G->arcnum; i++) {
        int a1, a2, w;
        scanf("%d %d %d", &a1, &a2, &w);
        
        // 插入边 a1 -> a2
        ArcNode *p1 = (ArcNode*)malloc(sizeof(ArcNode));
        p1->adjvex = a2;
        p1->info = w;
        p1->nextarc = G->vertices[a1].firstarc;
        G->vertices[a1].firstarc = p1;
        
        // 插入边 a2 -> a1
        ArcNode *p2 = (ArcNode*)malloc(sizeof(ArcNode));
        p2->adjvex = a1;
        p2->info = w;
        p2->nextarc = G->vertices[a2].firstarc;
        G->vertices[a2].firstarc = p2;
    }
}

// 广度优先搜索（BFS）
void BFS(ALGraph G, int v, bool visited[]) {
    Queue Q;
    InitQueue(&Q);
    EnQueue(&Q, v);
    visited[v] = true;

    while (!IsQueueEmpty(Q)) {
        int u = DeQueue(&Q);
        printf("Visited vertex: %d\n", G.vertices[u].data);
        
        ArcNode *p = G.vertices[u].firstarc;
        while (p != NULL) {
            if (!visited[p->adjvex]) {
                EnQueue(&Q, p->adjvex);
                visited[p->adjvex] = true;
            }
            p = p->nextarc;
        }
    }
}

int main() {
    ALGraph G;
    CreateUDN(&G);

    bool visited[MAX_VERTEX_NUM] = {false};

    for (int i = 1; i <= G.vexnum; i++) {
        if (!visited[i]) {
            BFS(G, i, visited);
        }
    }

    return 0;
}
```



#### 5. 求最小生成树的权值之和



```c
//普利姆算法
#include <stdio.h>

#define MAX_VERTEX_NUM 100
#define INFINITY 1999999  // 用一个足够大的值表示无穷大

typedef int VertexType;
typedef int VRType;
typedef struct 
{
    VRType arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];
    VertexType vexs[MAX_VERTEX_NUM];
    int vexnum, arcnum;
} AMGraph;

void CreateUDN(AMGraph *G) 
{
	int i, j;
    // 输入顶点数和边数
    scanf("%d %d", &G->vexnum, &G->arcnum);
    
    // 初始化邻接矩阵
    for (i = 1; i <= G->vexnum; i++) 
    {
        for (j = 1; j <= G->vexnum; j++) 
        {
            if (i == j) 
            {
                G->arcs[i][j] = 0;  // 自环边权值为0
            } 
            else 
            {
                G->arcs[i][j] = INFINITY;  // 其他边初始为无穷大
            }
        }
    }
    
    // 输入每条边的信息
    for (j = 0; j < G->arcnum; j++) 
    {
        int a1, a2, w;
        getchar();  // 吸收上一个输入后的换行符
        scanf("%d %d %d", &a1, &a2, &w);
        G->arcs[a1][a2] = w;
        G->arcs[a2][a1] = w;  // 无向图对称
    }
}

typedef struct 
{
    int adjvex;  // 边的终点
    VRType lowcost;  // 边的权值
} EdgeNode;

EdgeNode closedge[MAX_VERTEX_NUM];

int MiniSpanTree_Prim(AMGraph G) 
{
	int i, j;
    // 初始化 closedge 数组
    for (i = 2; i <= G.vexnum; i++) 
    {
        closedge[i].adjvex = 1;
        closedge[i].lowcost = G.arcs[1][i];
    }
    closedge[1].lowcost = 0;  // 从第一个顶点开始生成树
    
    int totalweight = 0;
    
    for (i = 2; i <= G.vexnum; i++) 
    {
        // 找到权值最小的边
        VRType min = INFINITY;
        int min_Index = -1;
        for (j = 1; j <= G.vexnum; j++) 
        {
            if (closedge[j].lowcost != 0 && closedge[j].lowcost < min) {
                min = closedge[j].lowcost;
                min_Index = j;
            }
        }
        if (min_Index == -1) 
        {
            printf("ERROR\n");
            return -1;
        }
    
        totalweight += closedge[min_Index].lowcost;  // 累加权值
        closedge[min_Index].lowcost = 0;  // 将该顶点加入生成树
        
        // 更新 closedge 数组
        for (j = 1; j <= G.vexnum; j++) 
        {
            if (G.arcs[min_Index][j] < closedge[j].lowcost && closedge[j].lowcost != 0) 
            {
                closedge[j].adjvex = min_Index;
                closedge[j].lowcost = G.arcs[min_Index][j];
            }
        }
    }
    return totalweight;    
}

int main() 
{
    AMGraph G;
    
    CreateUDN(&G);
    
    int totalWeight = MiniSpanTree_Prim(G);
    printf("%d\n", totalWeight);
    
    return 0;
}

```



```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_VERTEX_NUM 100
#define INFINITY 99999

typedef struct {
    int u, v; // 边的两个顶点
    int weight; // 边的权值
} Edge;

typedef struct {
    int vexnum; // 顶点数量
    int edgenum; // 边数量
    Edge edges[MAX_VERTEX_NUM * (MAX_VERTEX_NUM - 1) / 2]; // 边集数组
} Graph;

int parent[MAX_VERTEX_NUM]; // 并查集的父节点数组

// 并查集查找根节点
int find(int x) {
    if (parent[x] != x) {
        parent[x] = find(parent[x]); // 路径压缩
    }
    return parent[x];
}

// 并查集合并
void unionSet(int x, int y) {
    int rootX = find(x);
    int rootY = find(y);
    if (rootX != rootY) {
        parent[rootX] = rootY;
    }
}

// 边的比较函数，用于qsort排序
int compareEdges(const void *a, const void *b) {
    return ((Edge *)a)->weight - ((Edge *)b)->weight;
}

// Kruskal算法求最小生成树的权值
int kruskalMST(Graph *G) 
{
    int totalWeight = 0, i;
    int edgeCount = 0;

    // 初始化并查集
    for (i = 1; i <= G->vexnum; i++) {
        parent[i] = i;
    }

    // 按权值升序排序所有边
    qsort(G->edges, G->edgenum, sizeof(Edge), compareEdges);

    // 选择边加入最小生成树
    for (i = 0; i < G->edgenum; i++) {
        int u = G->edges[i].u;
        int v = G->edges[i].v;
        int weight = G->edges[i].weight;

        // 如果加入这条边不会形成环
        if (find(u) != find(v)) 
        {
            unionSet(u, v);
            totalWeight += weight;
            edgeCount++;
            // 如果边数达到了顶点数-1，说明最小生成树构建完成
            if (edgeCount == G->vexnum - 1) 
            {
                break;
            }
        }
    }

    return totalWeight;
}

int main() 
{
    Graph G;
    int n, count, i;

    // 输入顶点数和边数
    scanf("%d %d", &n, &count);
    G.vexnum = n;
    G.edgenum = count;

    // 输入每条边
    for (i = 0; i < count; i++) 
    {
        int u, v, weight;
        scanf("%d %d %d", &u, &v, &weight);
        G.edges[i].u = u;
        G.edges[i].v = v;
        G.edges[i].weight = weight;
    }

    // 计算并输出最小生成树的权值
    int result = kruskalMST(&G);
    printf("%d\n", result);

    return 0;
}
```



#### 6. 动态规划模拟测试题



```c
//AI大牛 C语言版
#include <stdio.h>
#include <limits.h>

#define VERTEX_NUM 12  // 顶点数量
#define MAX_EDGES 21   // 最大边数量

// 结构体定义边
struct Edge {
    int from, to, weight;
};

// 给定的边及权重
struct Edge edges[MAX_EDGES] = {
    {1, 2, 9}, {1, 3, 7}, {1, 4, 3}, {1, 5, 2},
    {2, 6, 4}, {2, 7, 2}, {2, 8, 1}, {3, 6, 2}, {3, 7, 7},
    {4, 8, 11}, {5, 7, 11}, {5, 8, 8}, {6, 9, 6}, {6, 10, 5},
    {7, 9, 4}, {7, 10, 3}, {8, 10, 5}, {8, 11, 6}, {9, 12, 4},
    {10, 12, 2}, {11, 12, 5}
};

int main() {
    int stages;
    scanf("%d", &stages);

    int stage_nodes[stages][VERTEX_NUM];
    int stage_sizes[stages];  // 每个阶段的节点数量

    for (int i = 0; i < stages; ++i) {
        int node;
        stage_sizes[i] = 0;
        while (scanf("%d", &node) == 1) {
            stage_nodes[i][stage_sizes[i]++] = node;
            if (getchar() == '\n') break;
        }
    }

    int dist[VERTEX_NUM + 1];
    int path[VERTEX_NUM + 1];

    for (int i = 0; i <= VERTEX_NUM; ++i) {
        dist[i] = INT_MAX;
        path[i] = -1;
    }

    dist[1] = 0;  // 源点到自己的距离为0

    for (int i = 0; i < stages - 1; ++i) {
        for (int j = 0; j < stage_sizes[i]; ++j) {
            int u = stage_nodes[i][j];
            for (int k = 0; k < MAX_EDGES; ++k) {
                if (edges[k].from == u) {
                    int v = edges[k].to;
                    if (dist[u] != INT_MAX && dist[u] + edges[k].weight < dist[v]) {
                        dist[v] = dist[u] + edges[k].weight;
                        path[v] = u;
                    }
                }
            }
        }
    }

    int target = 12;
    printf("%d\n", dist[target]);

    int shortest_path[VERTEX_NUM];
    int shortest_path_length = 0;

    for (int v = target; v != -1; v = path[v]) {
        shortest_path[shortest_path_length++] = v;
    }

    for (int i = shortest_path_length - 1; i >= 0; --i) {
        printf("%d ", shortest_path[i]);
    }
    printf("\n");

    return 0;
}

```



```c
//AI大牛, C++版
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

#define VERTEX_NUM 12  // 顶点数量

// 结构体定义边
struct Edge {
    int from, to, weight;
};

// 给定的边及权重
Edge edges[] = {
    {1, 2, 9}, {1, 3, 7}, {1, 4, 3}, {1, 5, 2},
    {2, 6, 4}, {2, 7, 2}, {2, 8, 1}, {3, 6, 2}, {3, 7, 7},
    {4, 8, 11}, {5, 7, 11}, {5, 8, 8}, {6, 9, 6}, {6, 10, 5},
    {7, 9, 4}, {7, 10, 3}, {8, 10, 5}, {8, 11, 6}, {9, 12, 4},
    {10, 12, 2}, {11, 12, 5}
};

const int edge_count = sizeof(edges) / sizeof(edges[0]);

int main() {
    int stages;
    cin >> stages;

    vector<vector<int>> stage_nodes(stages);
    for (int i = 0; i < stages; ++i) {
        int node;
        while (cin >> node) {
            stage_nodes[i].push_back(node);
            if (cin.get() == '\n') break;
        }
    }

    vector<int> dist(VERTEX_NUM + 1, INT_MAX);
    vector<int> path(VERTEX_NUM + 1, -1);
    
    dist[1] = 0;  // 源点到自己的距离为0
    
    for (int i = 0; i < stages - 1; ++i) {
        for (int u : stage_nodes[i]) {
            for (const Edge& edge : edges) {
                if (edge.from == u) {
                    int v = edge.to;
                    if (dist[u] + edge.weight < dist[v]) {
                        dist[v] = dist[u] + edge.weight;
                        path[v] = u;
                    }
                }
            }
        }
    }

    int target = 12;
    cout << dist[target] << endl;

    vector<int> shortest_path;
    for (int v = target; v != -1; v = path[v]) {
        shortest_path.push_back(v);
    }
    
    for (auto it = shortest_path.rbegin(); it != shortest_path.rend(); ++it) {
        cout << *it << " ";
    }
    cout << endl;

    return 0;
}

```



### 作业10——查找排序

#### 1. 查找

```c
#include <stdio.h>
#include <stdlib.h>

//折半查找函数
//int a[ ]:查找表，int n: 查找表长度， int target: 待查找的元素
//如果查找成功，返回元素数组下标（从0开始），如果查找失败，返回-1
int BinarySearch(int a[ ],  int n,  int target) 
{
//★★★请补全代码
	int l = 0, r = n;
	while(l <= r)
	{
		int mid = (r + l) / 2;
		if(a[mid] < target)	l = mid + 1;
		else if(a[mid] == target)	return mid;
		else r = mid - 1; 
	 } 
	 return -1;

}

int main( )
 {
	int a[10], n, i, m;
        scanf("%d", &n);
	for (i = 0; i < n; i++) {
		scanf("%d", &a[i]);
	}

	scanf("%d", &m);
	
	int q;
	q = BinarySearch(a, 10, m);
	if (q != -1) {
		printf("%d", q + 1);
	}
	else {
		printf("not found");
	}
	return 0;
}
```



#### 2. 哈希表的查找

```c
#include <stdio.h>
#include <stdlib.h>

#define OK 0
#define ERROR -1

typedef int Status;/* Status是函数的类型,其值是函数结果状态代码，如TRUE等 */

#define ITEMNO 12
#define HASHSIZE 13 // 定义哈希表长为数组的长度
#define NULLKEY -32768 // 空关键字

typedef struct{
    int* elem; // 数据元素存储基址，动态分配数组
    int count; //  当前数据元素个数
}HashTable;

Status initHashTable(HashTable* hash)
{
    int i;
    hash->count = 0;
    hash->elem = (int*)malloc(HASHSIZE * sizeof(int));
    if(!hash->elem)
        return ERROR;
    for (i = 0; i < HASHSIZE; i++)
        hash->elem[i] = NULLKEY;
    return OK;
}

// 构造哈希函数
int hashFun(int key)
{
    return key % HASHSIZE; // 构造方法为除留余数法
}

// 插入关键字进哈希表
int InsertHash(HashTable* hash, int key)
{
    int addr = hashFun(key); // 求哈希地址
    while (hash->elem[addr] != NULLKEY) // 如果不为空，则冲突
    {
        addr = (addr + 1) % HASHSIZE; // 开放定址法的线性探测
        if (addr > HASHSIZE)
            return ERROR;
    }

    hash->elem[addr] = key; // 直到有空位后插入关键字
    hash->count++;
    return OK;
}
/* 搜索哈希表函数定义，要求：
 * 函数接口定义为：Status SearchHash(HashTable hash, int key, int &addr)
 * 输入参数：hash 待搜索哈希表，key 目标关键字， addr 目标关键字在哈希表中的存储位置
 * 处理规则及返回值：按照线性探索方式查找key在哈希表中的位置。
 *                查找成功返回OK，不成功返回ERROR*/
Status SearchHash(HashTable hash, int key, int *addr)
{
    int ad = hashFun(key), i = 0;
	for(i = 0; i < HASHSIZE; i ++)
	{
		ad = (ad + i) % HASHSIZE;
		if(hash.elem[ad] == key)	
		{
			*addr = ad ;
			return OK;
		}
	 } 
    
    return ERROR;
    //将该函数补充完整
    
    
}

int main()
{
    int arr[HASHSIZE] = { 12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48, 34 };
    int key;
    int addr;
    int i;
    HashTable hash;
    //初始化哈希表
    initHashTable(&hash);
    //插入关键字到哈希表
    for (i = 1; i <= ITEMNO; i++)
    {
        if (ERROR == InsertHash(&hash, arr[i-1]))
            printf("Item No %d is already exist.\n", i);
    }
    scanf("%d", &key);
    if (ERROR != SearchHash(hash, key, &addr))
        printf("The hash address of %d is %d.\n", key, addr);
    else
        printf("%d is not in the table.\n", key);

    return 0;
}
```



#### 3. 折半查找

```c
#include <stdio.h>

#include <stdio.h>

//打印二分查找过程的中间位置mid所对应的数字，使用printf("%d\t", midVal)

int Search (int a[], int n, int key)
{
	int l = 0,r = n;
	while(l <= r)
	{
		int mid = (l + r) / 2;
		printf("%d\t", a[mid]);
		if(a[mid] == key)	return mid;	
		if (a[mid] < key)	l = mid + 1;
		else 	r = mid - 1;
	}
	return -1;
}

 

int main(){

    int i, val;
	int a[15]={5,10,11,15,17,19,21,25,36,38,50,51,55,57,68};
	 

    for(i = 0; i < 15; i ++)
    {
    	printf("%d\t", a[i]);
	}

 

    printf("\n请输入所要查找的元素：");

    scanf("%d",&val);

    int midVal = Search(a, 15, val);

  	if(midVal == -1)
        printf("查找失败\n");

    else		
        printf("查找成功\n");

       return 0;

}
```



#### 4. 简单选择排序

```c
#include <stdio.h>

#include <stdlib.h>

#include <string.h>

 

#define STUDENT_NUMBER 5//排序对象个数

 

#define NAME_ASCEND    0//按姓名递增(非递减）顺序排序

#define NUMBER_ASCEND  1//按学号递增(非递减）顺序排序

#define SCORE_ASCEND   2//按成绩递增(非递减）顺序排序

 

typedef struct STUDENT_STRU

{

    char name[10];//姓名

    char num[6];  //学号

    int score;    //成绩

}STUDENT_STRU;

 

//完成两个结构体（中全部变量）的互换

void SwapStu(STUDENT_STRU *StucA, STUDENT_STRU *StucB)

{

    //请补充代码
    STUDENT_STRU temp = *StucA;
    *StucA = *StucB;
    *StucB = temp;
    

}

 

 

 

 

//按姓名选择

int SelectNameMinKey(STUDENT_STRU a[], int h, int i)

 { // 返回在L.r[i..L.length]中key最小的记录的序号

  //请补充代码
  	int min = i;
  	for(i = i + 1; i <= h ; i ++)
  	{
  		if(strcmp(a[i - 1].name, a[min - 1].name) < 0 )
  		{
  			min = i;
		  }
	  }
  
	return min;
 }

 

//按成绩选择

int SelectScoreMinKey(STUDENT_STRU a[], int h, int i)

 { // 返回在L.r[i..L.length]中key最小的记录的序号

   //请补充代码
     	int min = i;
  	for(i = i + 1; i <= h ; i ++)
  	{
  		if(a[i - 1].score < a[min - 1].score )
  		{
  			min = i;
		  }
	  }
  
	return min;

 }

 

//按学号选择

int SelectNumberMinKey(STUDENT_STRU a[], int h, int i)

 { // 返回在L.r[i..L.length]中key最小的记录的序号

    //请补充代码
      	int min = i;
  	for(i = i + 1; i <= h ; i ++)
  	{
  		if(strcmp(a[i - 1].num, a[min - 1].num) < 0 )
  		{
  			min = i;
		  }
	  }
  
	return min;

 }

 

 

 

/**************************************************************************/

/*选择排序法，根据SortType的取值选择排序的关键字                            */

/**************************************************************************/

 

 

void SelectSort(STUDENT_STRU a[], int n, int SortType)

 { // 对顺序表L作简单选择排序。

  int i, j;

    //struct STUDENT_STRU t;

    switch (SortType)

    {

        case NAME_ASCEND:

        {

         for(i=1;i<n;++i)

               {

            //  选择第i小的记录，并交换到位

        j=SelectNameMinKey(a, n, i); // 选择key最小的记录

        if(i!=j)   SwapStu(&a[i-1], &a[j-1]);  // 与第i个记录交换

            }

        break;

        }

 

      case NUMBER_ASCEND:

        {

         for(i=1;i<n;++i)

               {

            //  选择第i小的记录，并交换到位

        j=SelectNumberMinKey(a,n, i); // 选择key最小的记录

        if(i!=j)   SwapStu(&a[i-1], &a[j-1]);  // 与第i个记录交换

            }

        break;

        }

 

      case SCORE_ASCEND:

        {

         for(i=1;i<n;++i)

               {

            //  选择第i小的记录，并交换到位

        j=SelectScoreMinKey(a,n, i); // 选择key最小的记录

        if(i!=j) SwapStu(&a[i-1], &a[j-1]); // 与第i个记录交换

            }

        break;

        }

 

 }

 

}

 

 

//主函数中定义学生结构体数组信息，并调用排序算法进行排序，每次排序后打印结果进行比对

//注意每一次排序都是在上一次排序结果（而非原始数据）的基础上进行的

int main(void)

{

    int i;

 

    STUDENT_STRU StudentStru[STUDENT_NUMBER] =

    {

        {"James", "00007", 85},

        {"Amy",   "00010", 90},

        {"Zoe",   "00001", 60},

        {"Tom",   "00005", 85},

              {"Tom",   "00015", 70},

    };//学生信息的结构体数组，注意有学生的姓名/成绩是相同的，仔细体会排序算法的稳定性

 

    //打印排序对象

    printf("初始数据为：\n");

    for (i = 0; i < STUDENT_NUMBER; i++)

    {

 

        printf("%s %s %d\n", StudentStru[i].name, StudentStru[i].num, StudentStru[i].score);

    }

 

    //姓名非递减（递增）排序

    SelectSort(StudentStru, STUDENT_NUMBER, NAME_ASCEND);

    //打印排序结果

    printf("姓名非递减（递增）排序后数据：\n");

    for (i = 0; i < STUDENT_NUMBER; i++)

    {

 

        printf("%s %s %d\n", StudentStru[i].name, StudentStru[i].num, StudentStru[i].score);

    }

 

       //学号递增排序

    SelectSort(StudentStru, STUDENT_NUMBER, NUMBER_ASCEND);

    //打印排序结果

    printf("学号递增排序后数据：\n");

    for (i = 0; i < STUDENT_NUMBER; i++)

    {

 

        printf("%s %s %d\n", StudentStru[i].name, StudentStru[i].num, StudentStru[i].score);

    }

 

       //成绩非递减（递增）排序

       SelectSort(StudentStru, STUDENT_NUMBER, SCORE_ASCEND);

    //打印排序结果

    printf("成绩非递减（递增）排序后数据：\n");

    for (i = 0; i < STUDENT_NUMBER; i++)

    {



        printf("%s %s %d\n", StudentStru[i].name, StudentStru[i].num, StudentStru[i].score);

    }

 

       return 0;

}
```



#### 5. 快速排序

```c
#include<stdio.h>

#include<stdlib.h>

#include<string.h>


#define STUDENT_NUMBER 5//排序对象个数

#define NAME_ASCEND    0//按姓名递增(非递减）顺序排序

#define NUMBER_ASCEND  1//按学号递增(非递减）顺序排序

#define SCORE_ASCEND   2//按成绩递增(非递减）顺序排序

 

typedef struct STUDENT_STRU

{

    char name[10];//姓名

    char num[6];  //学号

    int score;    //成绩

}STUDENT_STRU;

 

 
// 按成绩分块函数
int PartitionScore(STUDENT_STRU a[], int low, int high)
{
	STUDENT_STRU temp = a[low];
	while(low < high)
	{
		while(low < high && a[high].score >= temp.score)	--high;
		a[low] = a[high];
		while(low < high && a[low].score <= temp.score)		++low;
		a[high] = a[low];
		
	}
	a[low] = temp;
	return low;
}
 

//按姓名分块函数

int PartitionName(STUDENT_STRU a[], int low, int high)

{

    //请补充代码
    STUDENT_STRU temp = a[low];
    while(low < high)
    {
    	while(low < high && strcmp(a[high].name, temp.name) >= 0)	--high;
    	a[low] = a[high];
    	while(low < high && strcmp(a[low].name, temp.name) <= 0)	++low;
    	a[high] = a[low];
	}
	a[low] = temp;
	return low;

}

 

//按学号分块函数

int PartitionNum(STUDENT_STRU a[], int low, int high)

{

    //请补充代码
    STUDENT_STRU temp = a[low];
    while(low < high)
    {
    	while(low < high && strcmp(a[high].num, temp.num) >= 0 )	--high;
    	a[low] = a[high];
    	while(low < high && strcmp(a[low].num, temp.num) <= 0)	++low;
    	a[high] = a[low];
	}
	a[low] = temp;
	return low;

}

 

 

void QSort(STUDENT_STRU a[], int low, int high,int sortNum)

{

switch (sortNum)

       {

              case NAME_ASCEND:

              {

                     if (low < high)

                     {

                            int pivotloc = PartitionName(a, low, high);

                            QSort(a, low, pivotloc-1, NAME_ASCEND);

                            QSort(a, pivotloc+1, high, NAME_ASCEND);

                     }

 

                     break;

              }

                    

 

              case NUMBER_ASCEND:

              {

                     if (low < high)

                     {

                            int pivotloc = PartitionNum(a, low, high);

                            QSort(a, low, pivotloc-1, NUMBER_ASCEND);

                            QSort(a, pivotloc+1, high, NUMBER_ASCEND);

                     }

 

                     break;

              }

 

              case SCORE_ASCEND:

              {

                     if (low < high)

                     {

                            int pivotloc = PartitionScore(a, low, high);

                            QSort(a, low, pivotloc-1, SCORE_ASCEND);

                            QSort(a, pivotloc+1, high, SCORE_ASCEND);

                     }

 

                     break;

              }

 

              default:

                     break;

       }// end of switch()

}

 

//主函数中定义学生结构体数组信息，并调用排序算法进行排序，每次排序后打印结果进行比对

//注意每一次排序都是在上一次排序结果（而非原始数据）的基础上进行的

int main(void)

{

    int i;

 

    STUDENT_STRU StudentStru[STUDENT_NUMBER] =

    {

        {"James", "00007", 85},

        {"Amy",   "00010", 90},

        {"Zoe",   "00001", 60},

        {"Tom",   "00005", 85},

              {"Tom",   "00015", 70},

    };//学生信息的结构体数组，注意有学生的姓名/成绩是相同的，仔细体会排序算法的稳定性

 

    //打印排序对象

    printf("初始数据为：\n");

    for (i = 0; i < STUDENT_NUMBER; i++)

    {

 

        printf("%s %s %d\n", StudentStru[i].name, StudentStru[i].num, StudentStru[i].score);

    }

 

    //姓名非递减（递增）排序

    QSort(StudentStru, 0, STUDENT_NUMBER-1, NAME_ASCEND);

    //打印排序结果

    printf("姓名非递减（递增）排序后数据：\n");

    for (i = 0; i < STUDENT_NUMBER; i++)

    {

 

        printf("%s %s %d\n", StudentStru[i].name, StudentStru[i].num, StudentStru[i].score);

    }

 

       //学号递增排序

    QSort(StudentStru, 0, STUDENT_NUMBER-1, NUMBER_ASCEND);

    //打印排序结果

    printf("学号递增排序后数据：\n");

    for (i = 0; i < STUDENT_NUMBER; i++)

    {

 

        printf("%s %s %d\n", StudentStru[i].name, StudentStru[i].num, StudentStru[i].score);

    }

 

       //成绩非递减（递增）排序

       QSort(StudentStru, 0, STUDENT_NUMBER-1, SCORE_ASCEND);

    //打印排序结果

    printf("成绩非递减（递增）排序后数据：\n");

    for (i = 0; i < STUDENT_NUMBER; i++)

    {

 

        printf("%s %s %d\n", StudentStru[i].name, StudentStru[i].num, StudentStru[i].score);

    }

       return 0;

}
```



#### 6. 冒泡排序

```c
#include <stdio.h>

#include <stdlib.h>

#include <string.h>

 

#define STUDENT_NUMBER 5//排序对象个数

 

#define NAME_ASCEND    0//按姓名递增(非递减）顺序排序

#define NUMBER_ASCEND  1//按学号递增(非递减）顺序排序

#define SCORE_ASCEND   2//按成绩递增(非递减）顺序排序

 

struct STUDENT_STRU

{

    char name[10];//姓名

    char num[6];  //学号

    int score;    //成绩

};

 

//完成两个结构体（中全部变量）的互换

void SwapStu(struct STUDENT_STRU *StucA, struct  STUDENT_STRU *StucB)

{

//请补充代码
	struct STUDENT_STRU temp;
	temp = *StucA;
	*StucA = *StucB;
	*StucB = temp; 

}

 

 

/**************************************************************************/

/*冒泡排序法，根据SortType的取值选择排序的关键字                            */

/**************************************************************************/

void BubbleSort(struct STUDENT_STRU a[], int n, int SortType)

{

    int i, j;

   

    switch (SortType)

    {

        case NAME_ASCEND:

        {

//请补充代码
			for(i = 0; i < n - 1; i ++)
			{
				for(j = 0; j < n - i - 1; j ++)
				{
					if(strcmp(a[j].name, a[j + 1].name) > 0)
					{
						SwapStu(&a[j + 1], &a[j]);
					}
				}
			}

 				break;//switch里面要格外注意，break千万不能忘

        }

       

        case NUMBER_ASCEND:

        {

//请补充代码
			for(i = 0; i < n - 1; i ++)//  n - 1要格外注意
			{
				for(j = 0; j < n - i - 1; j ++)//没有等号
				{
					if(strcmp(a[j].num, a[j + 1].num) > 0)
					{
						SwapStu(&a[j + 1], &a[j]);
					}
				}
			}
			
			
			break;

        }       

       

        case SCORE_ASCEND:

        {

         //请补充代码
        for(i = 0; i < n - 1; i ++)
			{
				for(j = 0; j < n - i - 1; j ++)
				{
					if(a[j + 1].score < a[j].score)
					{
						SwapStu(&a[j + 1], &a[j]);
					}
				}
			}
			break;

        }

        default:

            break;

    }

}
 

//主函数中定义学生结构体数组信息，并调用排序算法进行排序，每次排序后打印结果进行比对

//注意每一次排序都是在上一次排序结果（而非原始数据）的基础上进行的

int main(void)

{

    int i;

 

    struct STUDENT_STRU StudentStru[STUDENT_NUMBER] =

    {

        {"James", "00007", 85},

        {"Amy",   "00010", 90},

        {"Zoe",   "00001", 60},

        {"Tom",   "00005", 85},

              {"Tom",   "00015", 70},

    };//学生信息的结构体数组，注意有学生的姓名/成绩是相同的，仔细体会排序算法的稳定性

 

    //打印排序对象

    printf("初始数据为：\n");

    for (i = 0; i < STUDENT_NUMBER; i++)

    {

 

        printf("%s %s %d\n", StudentStru[i].name, StudentStru[i].num, StudentStru[i].score);

    }

 
    //姓名非递减（递增）排序

    BubbleSort(StudentStru, STUDENT_NUMBER, NAME_ASCEND);

    //打印排序结果

    printf("姓名非递减（递增）排序后数据：\n");

    for (i = 0; i < STUDENT_NUMBER; i++)

    {

 

        printf("%s %s %d\n", StudentStru[i].name, StudentStru[i].num, StudentStru[i].score);

    }

 

       //学号递增排序

    BubbleSort(StudentStru, STUDENT_NUMBER, NUMBER_ASCEND);

    //打印排序结果

    printf("学号递增排序后数据：\n");

    for (i = 0; i < STUDENT_NUMBER; i++)

    {

        printf("%s %s %d\n", StudentStru[i].name, StudentStru[i].num, StudentStru[i].score);

    }


       //成绩非递减（递增）排序

       BubbleSort(StudentStru, STUDENT_NUMBER, SCORE_ASCEND);

    //打印排序结果

    printf("成绩非递减（递增）排序后数据：\n");

    for (i = 0; i < STUDENT_NUMBER; i++)

    {

        printf("%s %s %d\n", StudentStru[i].name, StudentStru[i].num, StudentStru[i].score);

    }

       return 0;

}
```



#### 7. 直接插入排序

```c
#include <stdio.h>

#include <stdlib.h>

#include <string.h>

 

#define STUDENT_NUMBER 5//排序对象个数

 

#define NAME_ASCEND    0//按姓名递增(非递减）顺序排序

#define NUMBER_ASCEND  1//按学号递增(非递减）顺序排序

#define SCORE_ASCEND   2//按成绩递增(非递减）顺序排序

 

typedef struct STUDENT_STRU

{

    char name[10];//姓名

    char num[6];  //学号

    int score;    //成绩

}STUDENT_STRU;

 

 

/**************************************************************************/

/*直接插入排序法，根据SortType的取值选择排序的关键字                         */

/**************************************************************************/

void StraightInsertionSort(STUDENT_STRU a[], int n, int SortType)

{

  int i, j;

   

    switch (SortType)

    {

        case NAME_ASCEND:

        {

//请补充代码
			for(i = 2; i <= n; i ++)
			{
				if(strcmp(a[i].name, a[i - 1].name) < 0)	
				{
					a[0] = a[i];
					a[i] = a[i - 1];
					for(j = i - 2; strcmp(a[j].name, a[0].name) > 0; j --)
					{
						a[j + 1] = a[j];
					}
					a[j + 1] = a[0]; 
				}
			}
			
			break; 

        }

       

        case NUMBER_ASCEND:

        {

//请补充代码
			for(i = 2; i <= n; i ++)
			{
				if(strcmp(a[i].num, a[i - 1].num) < 0)
				{
					a[0] = a[i];
					a[i] = a[i - 1];
					for(j = i - 2; strcmp(a[j].num, a[0].num) > 0; j--)
					{
						a[j + 1] = a[j];
					}
					a[j + 1] = a[0];
				}
			}
			
			break; 

        }       

       

        case SCORE_ASCEND:

        {

         //请补充代码
         	
         	for(i = 2;i <= n ;i ++)
         	{
         		if(a[i].score < a[i - 1].score)
         		{
         			a[0] = a[i];
         			a[i] = a[i - 1];
         			for(j = i - 2; a[j].score > a[0].score; j --)
         			{
         				a[j + 1] = a[j];
					 }
					 a[j + 1] = a[0];
				 }
			 }
			
			break; 
        }

       

        default:

            break;

    }

 

}

 

 

 

 

//主函数中定义学生结构体数组信息，并调用排序算法进行排序，每次排序后打印结果进行比对

//注意每一次排序都是在上一次排序结果（而非原始数据）的基础上进行的

int main(void)

{

    int i;

 

    //学生信息的结构体数组，注意有学生的姓名/成绩是相同的，仔细体会排序算法的稳定性

    //注意预留数组中0的位置用于当作哨兵使用，实际数据从1开始

    STUDENT_STRU StudentStru[STUDENT_NUMBER+1] =

    {

        {"","",0},

        {"James", "00007", 85},

        {"Amy",   "00010", 90},

        {"Zoe",   "00001", 60},

        {"Tom",   "00005", 85},

              {"Tom",   "00015", 70},

    };

 

    //打印排序对象

    printf("初始数据为：\n");

    for(i = 1; i <=STUDENT_NUMBER; i++)

    {

 

        printf("%s %s %d\n", StudentStru[i].name, StudentStru[i].num, StudentStru[i].score);

    }

 

    //姓名非递减（递增）排序

    StraightInsertionSort(StudentStru, STUDENT_NUMBER, NAME_ASCEND);

    //打印排序结果

    printf("姓名非递减（递增）排序后数据：\n");

    for(i = 1; i <=STUDENT_NUMBER; i++)

    {

 

        printf("%s %s %d\n", StudentStru[i].name, StudentStru[i].num, StudentStru[i].score);

    }

 

       //学号递增排序

    StraightInsertionSort(StudentStru, STUDENT_NUMBER, NUMBER_ASCEND);

    //打印排序结果

    printf("学号递增排序后数据：\n");

    for(i = 1; i <=STUDENT_NUMBER; i++)

    {

 

        printf("%s %s %d\n", StudentStru[i].name, StudentStru[i].num, StudentStru[i].score);

    }

 

       //成绩非递减（递增）排序

       StraightInsertionSort(StudentStru, STUDENT_NUMBER, SCORE_ASCEND);

    //打印排序结果

    printf("成绩非递减（递增）排序后数据：\n");

    for(i = 1; i <=STUDENT_NUMBER; i++)

    {

 

        printf("%s %s %d\n", StudentStru[i].name, StudentStru[i].num, StudentStru[i].score);

    }

       return 0;

}
```



#### 8. 二叉排序树

```c
#include<stdio.h>

#include<stdlib.h>

 

typedef enum

{

    False,

    True

}Bool;

 

typedef struct Node

{

       int data;

       struct Node *lchild;

       struct Node *rchild;

}NODE,*BSTree;

/*

在指针pTree所指的二叉排序树中递归查找关键字为key的元素，

若查找成功，则返回指向该元素节点的指针，否则返回NULL

*/

 

BSTree search(BSTree pTree,int key)

{

	if(!pTree)	return NULL;
	if(pTree->data == key)	return pTree;
	else if(pTree->data < key)	return search(pTree->rchild, key);
	else if(pTree->data > key)	return search(pTree->lchild, key); 
	return NULL;
}

 

Bool search_BSTree(BSTree pTree,int key,BSTree parent,BSTree *p)

{

       if(!pTree)         //如果pTree为NULL，则查找不成功                                                                                  

       {     //这里包含了树空，即pTree为NULL的情况

              *p = parent;

              return False;

       }

       else             //否则，继续查找

       {                                                     

              if(key == pTree->data)                    //如果相等，则查找成功                                  

              {

                     *p = pTree;

                     return True;

              }

              else if(key < pTree->data)        //在左子树中递归查找

                     return search_BSTree(pTree->lchild,key,pTree,p);   

              else                                           //在右子树中递归查找

                     return search_BSTree(pTree->rchild,key,pTree,p);

    }

}

/*

递归中序遍历二叉排序树，得到元素从小到大有序排列的序列

*/

 

void in_traverse(BSTree pTree)

{

       if(pTree)

       {

              if(pTree->lchild)

                     in_traverse(pTree->lchild);

              printf("%d ",pTree->data);

              if(pTree->rchild)

                     in_traverse(pTree->rchild);      

       }

}

 

Bool insert(BSTree *pTree,int key)

{

       BSTree p;

       if(!search_BSTree(*pTree,key,NULL,&p))              //如果查找失败，则执行插入操作

       {

              //为新节点分配空间，并对各域赋值
			
            BSTree res ;
			res = (BSTree)malloc(sizeof(NODE));
			if(!res)	return False;	
			res->data = key;
			res->lchild =NULL;
			res->rchild = NULL;
			if(!p)
			{
				//这里的pTree不能替换成p 
				//如果我们使用 p，由于 p 是 NULL，无法更新树的根节点。 
				*pTree = res;// 这里需要更新树的根节点指针 
			}
			else if(p->data > key)	
			{
				p->lchild = res;
			}
			else 
			{
				p->rchild = res;
			}
			return True;
       }

       else

              return False;

}

/*

根据所给的长为len的arr数组，按数组中元素的顺序构建一棵二叉排序树

*/

 

BSTree create_BSTree(int *arr,int len)

{

       BSTree pTree = NULL;

       int i;

       //按顺序逐个节点插入到二叉排序树中

       for(i=0;i<len;i++)

              insert(&pTree,arr[i]);

       return pTree;

}

 

int main()

{

       int i;

       int num;

       int key;

       int *arr;

       BSTree pTree;

       printf("请输入节点个数：\n");

       scanf("%d",&num);

 

       //输入num个整数

       arr = (int *)malloc(num*sizeof(int));

       printf("请依次输入这%d个整数（必须互不相等）：\n",num);

       for(i=0;i<num;i++)

              scanf("%d",arr+i);

 

       //中序遍历该二叉排序树，使数据按照从小到大的顺序输出

       pTree = create_BSTree(arr,num);

       printf("中序遍历该二叉排序树的结果：");

       in_traverse(pTree);

       printf("\n");

 

       //查找给定的整数

      

       printf("请输入要查找的整数：\n");

       scanf("%d",&key);

       if(search(pTree,key))

              printf("查找成功\n");

       else

              printf("查找不到该整数\n");

       return 0;

}
```



#### 9. 折半插入排序

```c
#include <stdio.h>

#include <stdlib.h>

#include <string.h>

 

#define STUDENT_NUMBER 5//排序对象个数

 

#define NAME_ASCEND    0//按姓名递增(非递减）顺序排序

#define NUMBER_ASCEND  1//按学号递增(非递减）顺序排序

#define SCORE_ASCEND   2//按成绩递增(非递减）顺序排序

 

typedef struct STUDENT_STRU

{

    char name[10];//姓名

    char num[6];  //学号

    int score;    //成绩

}STUDENT_STRU;

 

 

/**************************************************************************/

/*折半插入排序法，根据SortType的取值选择排序的关键字                          */

/**************************************************************************/

void BinaryInsertionSort(STUDENT_STRU a[], int n, int SortType)

{

    int i, j;

    int low, high;

    switch (SortType)

    {

        case NAME_ASCEND:

        {

           //请补充代码
           
           for(i = 2;i <= n; i ++)
           {
           		a[0] = a[i];
           		low = 1, high = i - 1;
           		while(low <= high)
           		{
           			int mid = (low + high) /2;
           			if(strcmp(a[mid].name, a[0].name) <= 0)	low = mid + 1;//这里得用等号，否则就变成不稳定的排序了
           			else high = mid - 1;
				}
				for(j = i - 1; j >= low; j --)
				{
					a[j + 1] = a[j];
				 } 
				a[low] = a[0];
		   }
           
	        break;

        }

 

 

        case NUMBER_ASCEND:

        {

           

          //请补充代码
          	for(i = 2; i <= n; i ++)
          	{
          		a[0] = a[i];
          		low = 1, high = i - 1;
          		while(low <= high)
          		{
          			int mid = (low + high)/ 2;
          			if(strcmp(a[mid].num, a[0].num) < 0)	low = mid + 1;//主关键字，不存在相等
          			else high = mid - 1;
				  }
				  for(j = i - 1; j >= low; j --)
				  {
				  	a[j + 1] = a[j];
				  }
				  a[low] = a[0];
			  }
          	
	        break;
        }       

       

        case SCORE_ASCEND:

        {

         //请补充代码
         	for(i = 2; i <= n; i ++)
         	{
         		a[0] = a[i];
         		low = 1, high = i - 1;
         		while(low <= high)
         		{
         			int mid = (low + high) / 2;
         			if(a[mid].score <= a[0].score)	low = mid + 1;//这里得用等号，否则就变成不稳定的排序了
         			else high = mid - 1;
				 }
				 for(j = i - 1; j >= low; j --)
				 {
				 	a[j + 1] = a[j];
				 }
				 a[low] = a[0];
			 }
         	
         	
		     break;

        }

       

        default:

            break;

    }

}


//主函数中定义学生结构体数组信息，并调用排序算法进行排序，每次排序后打印结果进行比对

//注意每一次排序都是在上一次排序结果（而非原始数据）的基础上进行的

int main(void)

{

    int i;

   

    //学生信息的结构体数组，注意有学生的姓名/成绩是相同的，仔细体会排序算法的稳定性

    //注意预留数组中0的位置用于当作哨兵使用，实际数据从1开始

    STUDENT_STRU StudentStru[STUDENT_NUMBER+1] =

    {

        {"","",0},

        {"James", "00007", 85},

        {"Amy",   "00010", 90},

        {"Zoe",   "00001", 60},

        {"Tom",   "00005", 85},

              {"Tom",   "00015", 70},

    };

 

    //打印排序对象

    printf("初始数据为：\n");

    for(i = 1; i <=STUDENT_NUMBER; i++)

    {

 

        printf("%s %s %d\n", StudentStru[i].name, StudentStru[i].num, StudentStru[i].score);

    }

 

    //姓名非递减（递增）排序

    BinaryInsertionSort(StudentStru, STUDENT_NUMBER, NAME_ASCEND);

    //打印排序结果

    printf("姓名非递减（递增）排序后数据：\n");

    for(i = 1; i <=STUDENT_NUMBER; i++)

    {

 

        printf("%s %s %d\n", StudentStru[i].name, StudentStru[i].num, StudentStru[i].score);

    }

 

       //学号递增排序

    BinaryInsertionSort(StudentStru, STUDENT_NUMBER, NUMBER_ASCEND);

    //打印排序结果

    printf("学号递增排序后数据：\n");

    for(i = 1; i <=STUDENT_NUMBER; i++)

    {

 

        printf("%s %s %d\n", StudentStru[i].name, StudentStru[i].num, StudentStru[i].score);

    }

 

       //成绩非递减（递增）排序

       BinaryInsertionSort(StudentStru, STUDENT_NUMBER, SCORE_ASCEND);

    //打印排序结果

    printf("成绩非递减（递增）排序后数据：\n");

    for(i = 1; i <=STUDENT_NUMBER; i++)

    {

        printf("%s %s %d\n", StudentStru[i].name, StudentStru[i].num, StudentStru[i].score);

    }

       return 0;

}
```

