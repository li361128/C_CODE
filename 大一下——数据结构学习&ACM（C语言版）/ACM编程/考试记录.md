### 2023期中考试



#### 1. 2023春期中机考第一题 顺序表（7+8 = 15分)

```c
#include <stdio.h>

#include <stdlib.h>

#define OK 1

#define ERROR 0



typedef struct

{

	int *elem;

	int length;

	int listsize;

} sqlist;



//初始化一个空的顺序表

int initlist(sqlist *l)

{

	l->elem = (int *)malloc(100 * sizeof(int));

	if (!l->elem)

		return ERROR;

	l->length = 0;

	l->listsize = 100;

	return OK;

}



//根据长度为n的数组x，创建顺序表L   

//如果成功返回OK，否则返回ERROR

int insertlist(sqlist *l, int a[], int n)

{
	int i; 
	for (i = 0; i < n; i++)

	{

		l->elem[i] = a[i];

	}

	l->length = n;

	return OK;

}



//将顺序表a中大于t的元素存入顺序表b中

void getb(sqlist *b, sqlist a, int t)

{

	//★★★请补全代码
	int i = 0,j = 0;
	for(;i < a.length;i ++)
	{
		if(a.elem[i] > t)	
		{
			b->elem[j + b->length] = a.elem[i];	
			j ++;
		}
	} 
	b->length += j;







}



// 将b中的元素逆置，并打印输出逆置后b中所有元素

void  reverselist(sqlist *b)

{

	//★★★请补全代码
	int i = 0;
	for(;i * 2 < b->length;i ++)
	{
		int temp = b->elem[i];
		b->elem[i] = b->elem[b->length - i - 1];
		b->elem[b->length - i - 1] = temp;		
	}

}



int main()

{

	sqlist a,b;

	initlist(&a);

	initlist(&b);

	int x[100];

	int n,i;

	scanf("%d", &n);

	for (i = 0; i < n; i++)

	{

		scanf("%d", &x[i]);

	}

	insertlist(&a, x, n);

	int t;

	scanf("%d", &t);

	getb(&b, a, t);

	reverselist(&b);
	
	for(i = 0;i < b.length;i ++)
	{
		printf("%d ",b.elem[i]);
	}

	return 0;

}


```



#### 2. 2023春期中机考第二题 链表（5+7+8=20分）

```C
#include <stdio.h>

#include <stdlib.h>

#define ERROR -1

#define OK 1



typedef struct Lnode

{

	int data;

	struct Lnode *next;

}LNode,*LinkList;



// 创建带头结点的单链表

int CreateList(LinkList *L)

{

	*L=(LinkList)malloc(sizeof(LNode));

	if((*L)==NULL)

	{

		printf("Memory failure\n");

		return ERROR;

	}

	(*L)->next=NULL;

	LinkList r;

	r=*L;

	int x;

	int i;

	for(i=0; ; i++)

	{

		scanf("%d",&x);

		if(x==-1)

		break;

		LNode *p=(LinkList)malloc(sizeof(LNode));

		if(!p) 

		{

			printf("Initialization failure");

			return ERROR;

		}

		p->data=x;

		p->next= NULL;

		r->next=p;

		r=p;

	}

	return OK;

}



//打印单链表

void ListPrint(LinkList L)

{

	LNode *p;

	for(p=L->next;p!=NULL;p=p->next)

	{

		printf("%d ",p->data);

	}

}



//求单链表长度

int ListLength(LinkList L)

{

	//★★★请补全代码
	int len = 0;
	 LinkList p = L->next;
	 while(p)
	 {
	 	len ++;
	 	p = p->next;
	 }
	return len;






}



//删除单链表的倒数第x个元素, 参数length为单链表长度，

//如果操作成功，返回OK，否则返回ERROR

int DeleteX(LinkList  *L,int length, int x)

{
	
	if(x > ListLength(*L))
	{
		printf("\nThe x value is not valid");
		return 0;
	}

	//★★★请补全代码
	int i = 0;
	LinkList p = (*L);
	while(p->next && i < length - x)
	{
		p = p->next;
		i ++;
	}
	LinkList s = p->next;
	p->next = s->next;
	free(s);
	return OK;







}



//单链表元素求和，并将累加和添加到单链表尾部

//如果操作成功，返回OK，否则返回ERROR

int AppendSumToList(LinkList *L)

{

	//★★★请补全代码
	int sum = 0;
	LinkList p = (*L);
	while(p->next)
	{
		sum += p->next->data;
		p = p->next;
	}
	LinkList s;
	s = (LinkList)malloc(sizeof(LNode));
	if(!s)	return ERROR;
	s->data = sum;
	s->next = NULL;
	p->next = s;
	return 1;
	






} 



int main()

{

	int length;

	int x;

	LinkList L;

	CreateList(&L);

	scanf("%d",&x);
	


	printf("The original linked list is：");

	ListPrint(L);

	printf("\nThe length of list is：");

	length=ListLength(L);

	printf("%d ",length);
	


	DeleteX (&L,length, x);

	printf("\nAfter deleting the element, the linked list is: ");

	ListPrint(L);

	printf("\nAfter inserting the sum, the new list is: ");

	AppendSumToList(&L);

	ListPrint(L);

	return 0;

}
```



#### 3. 2023春期中机考第三题 链队列（7+8=15分）

```c
#include <stdio.h>

#include <stdlib.h>

#define OK 1

#define ERROR 0

#define OVERFLOW 0



typedef char ElemType;

typedef int Status;

typedef struct QNode

{

    ElemType data;

    struct QNode *next;

}QNode,*queuePtr;   



typedef struct

{

    queuePtr front; //指向链队列的头

    queuePtr rear;  //指向链队列的尾 

}LinkQueue;



//队列初始化

Status InitQueue(LinkQueue *q)

{

   q->front=q->rear=(queuePtr)malloc(sizeof(QNode));  //创建头节点 头指针指向头节点

   if(!q->front)  //创建失败

   {

       return ERROR;

   }

   q->front->next=NULL;

   return OK;

}



//判断队列是否为空

Status QueueEmpty(LinkQueue Q)

{

    if(Q.front==Q.rear)

        return OK;

    else

        return ERROR;

}// QueueEmpty



int QueueLength (LinkQueue Q)

{

    int i;

    queuePtr p;

    p = Q.front->next;   //p指向队头

    i=1;

    while(p!=Q.rear)  //遍历链队列,统计结点数

	{

        i++;

        p=p->next;

    }

    return i;

}// QueueLength



//获得队首元素

Status GetHead(LinkQueue q,ElemType *e)

{

    if(q.front == q.rear)

        return ERROR;

    *e = q.front->next->data;

    return OK;

}



//入队

Status EnQueue(LinkQueue *q,ElemType e)

{

    queuePtr p=(queuePtr)malloc(sizeof(QNode)); //为新元素分配空间

    if(!p) return ERROR; 

    p->data=e;

    p->next=NULL;

    q->rear->next=p; //为尾指针的next重新赋值 将元素插入表尾

    q->rear=p;  //重新定位尾指针

    return OK;

}



//删除元素

Status DeQueue(LinkQueue *q,ElemType *e)

{

    if(q->front == q->rear) return ERROR; //此时队列为空

    queuePtr p = q->front->next;  

    *e=p->data;  //删除是队首元素

    q->front->next=p->next;

    if(q->rear == p)

        q->rear=q->front;

    free(p);

    return OK;

}



//清空链队列，如果成功，返回OK，否则返回ERROR

Status ClearQueue (LinkQueue *Q)

{

	//★★★请补全代码
	if(!Q->front)	return ERROR;
	free(Q->front);
	Q->front = Q->rear = 0;
	return OK; 







}// ClearQueue



//输出队列

Status PrintQueue(LinkQueue q)

{

    queuePtr p;

    p = q.front->next;

    while(p)

    {

        printf("%c ",p->data);

        p=p->next;

    }

    return OK;

}



//解密游戏

void DecryptGame(LinkQueue *Q)

{

	//★★★请补全代码
	LinkQueue S;
	InitQueue(&S);
	
	while(!QueueEmpty(*Q))
	{
		char temp;
		DeQueue(Q,&temp);
		EnQueue(&S,temp);
		if(!QueueEmpty(*Q))
		{
			DeQueue(Q,&temp);
			EnQueue(Q,temp);
		}
	} 

	PrintQueue(S);

 



}



int main()

{

    LinkQueue Q;

    InitQueue(&Q);

    int i;

    char a;

    for(i=0;i<10;i++)

    {

        scanf("%c",&a);

        EnQueue(&Q,a);

    }

    DecryptGame(&Q);

    printf("\n");

    ClearQueue(&Q);

    return 0;

}
```



#### 4. 2023春 期中考试 第四题 顺序栈（5+10=15分）

```c
#include<stdio.h>

#include<stdlib.h>

#define OK 1

#define ERROR 0

#define OVERFLOW -2

#define MAXSIZE  100



typedef int Status;

typedef int SElemType;

typedef struct{

	SElemType *base;

	SElemType *top;

	int stacksize;

}SqStack;



//顺序栈的初始化

Status InitStack(SqStack *S){ 

	S->base = (SElemType *)malloc(MAXSIZE * sizeof(SElemType));

	if(!S->base)

		return ERROR;

	S->top = S->base;

	S->stacksize = MAXSIZE;

	return OK;

}



Status Push(SqStack *S,SElemType e)
{

	//★★★请补全代码
	if(S->top - S->base >= S->stacksize)	return ERROR;
	*(S->top ++) = e;
	return OK;


}



//顺序栈的出栈

Status Pop(SqStack *S,SElemType *e){

	if(S->base == S->top)

		return ERROR;

	*e = *(--S->top);

	return OK;

}





// 将一个十进制数转换为二进制数，并打印输出

// 要求使用堆栈来实现，如果未用堆栈，答题无效



int main()

{

	//★★★请补全代码
	int n;
	scanf("%d",&n);
	if(n <= 0)
	{
		printf("Input error!");
		return 0;
	}
	
	SqStack S;
	InitStack(&S);
	
	while(n)
	{
		int x = n%2;
		Push(&S,x);
		n = (n - x) / 2;
	}
	
	while(S.base != S.top)
	{
		int e;
		Pop(&S,&e);
		printf("%d",e);
	}
	return 0;
}






```



#### 5. 2023春 期中考试 第五题 字符串 (7+8=15分)

```c
#include <stdio.h>   

#include <stdlib.h>   



#define ERROR 0

#define OK 1

#define TRUE 1

#define FALSE 0

#define MAXSIZE 20



typedef struct

{

    char *ch;       //若串非空,则按串长分配存储区

    int  length;    //串长度

}HString;



int InitString(HString *T) 

{

    T->ch=(char*)malloc(sizeof(char)*MAXSIZE);

    if(!T->ch)

        return ERROR;

    T->length=0;

    return OK;

}



//将字符数组chars赋值到串T

//如果操作成功，返回OK，否则返回ERROR

int StrAssign(HString *T,char *chars)

{

//★★★请补全代码
	int i = 0;
	for(;chars[i] !='\0';i++)
	{
	}
	if(!i)
	{
		T->ch = NULL;
		T->length = 0;
	}
	else
	{
		int j = 0;
		for(j = 0;chars[j] != '\0';j ++)
		{
			T->ch[j] = chars[j];
			T->length ++;
		}
		
	}
	return OK;


}



   

// 比较字符串大小

//（1）如果两个串长度相等，且每一个相应位置上的字符都一样，则结果为0；

//（2）如果两个串长度不相等，则则以第一个不相同的字符作为基准，返回第一个不相同的字符ASCII差值；

//（3）如果两个串长度不相等，且所有相应位置上的字符都一样，则返回两个字符串的长度之差。

int StrCompare(HString S,HString T)

{

  //★★★请补全代码
  int i = 0;
  while(i < S.length && i < T.length)
  {
  		if(S.ch[i] != T.ch[i])	return (S.ch[i] - T.ch[i]);
  		i++; 
  }
  return S.length - T.length;



}//StrCompare    



int main()

{

    HString S;

    HString T;

    char mainstr[20];

    char substr[10];

    int index;

    InitString(&S);

    InitString(&T);

    gets(mainstr);

    gets(substr);

    StrAssign(&S,mainstr);

    StrAssign(&T,substr);

    printf("%d\n",StrCompare(S,T));

    return 1;

}
```



#### 6. 2023春 期中考试 第六题 综合题（一） (7分)

```c
#define MAXINTSIZE 512 /* 最大整数长度 */

#include<stdio.h>

#include<stdlib.h>



#define ERROR 0

#define OK 1

typedef int Status;



typedef struct Node

{

    int data;

    struct Node *next;

} LNode;

typedef LNode *LinkList;



/* 用头插法建立单链表 */

Status CreateList(LinkList *L, char *chars)

{

     //★★★请补全代码
    LinkList p = (*L);
	int i = 0;
	for(;chars[i] != '\0';i ++)
	{
		LNode *r;
		r = (LinkList)malloc(sizeof(LNode));
		if(!r)	return ERROR;
		r->data = chars[i] - '0';
		r->next = p->next;
		p->next = r;
		//p = r;
	}
	return OK;



}



int ListLength_L(LinkList L){

    LinkList p;

    int i=0;             

    p=L->next;        //p指向第一个结点

    while(p){         //遍历单链表,统计结点数

        i++;

        p=p->next;

    } 

    return i;                             

}// ListLength_L



Status  InversePrint(LinkList p){

   //逆序打印不带头结点的单链表的元素    

   if(!p) return OK;
   
   //printf("%d",p->data);

   InversePrint(p->next);

   printf("%d",p->data);

   return OK;

}// 



int main()

{

    int len;

    char str[MAXINTSIZE+1];

    LinkList L;

    scanf("%s", str);
    
    L = (LinkList)malloc(sizeof(LNode));

    CreateList(&L, str);

    len=ListLength_L(L);

    printf("the length of the integer is %d\n", len);

    InversePrint(L->next);

    printf("\n");

    return 0;

}


```



#### 7. 2023春 期中考试 第六题 综合题（二） (7+6=13分)

```c
#include<stdio.h>

#include<stdlib.h>



#define ERROR 0

#define OK 1



typedef int Status;



typedef struct Node

{

    int data;

    struct Node *next;

} LNode;

typedef LNode *LinkList;



Status InitList(LinkList *L)

{

    *L = (LinkList)malloc(sizeof(LNode));

    if (*L == NULL)

        return ERROR;

    (*L)->next = NULL;

    return OK;

}

// 单链表表示的大整数与整数相乘

//自己的代码
//int int_mult(LinkList *L, int base) 
//{
//	
//	int carry = 0;
//	LNode *p = (*L);
//	LNode *pre = NULL;
//	
//	while(p)
//	{
//		p->data = p->data * base + carry;
//		carry = p->data / 10;
//		p->data = p->data % 10;
//		pre = p;
//		p = p->next;
//	}
//	
//	if(!p && carry)
//	{
//		p = (LinkList)malloc(sizeof(LNode));
//		if(!p)	return ERROR;
//		p->data = carry;
//		p->next = NULL;
//		pre->next = p;
//	}
//	return OK;
//}

// 单链表表示的大整数与整数相乘

int int_mult(LinkList *L, int base) {
    int carry = 0;
    LinkList p = *L; // 从链表头开始遍历
    LinkList pre = NULL; // 记录当前节点的前一个节点，为后面进行尾插新节点提供前驱

    // 遍历链表
    while (p || carry != 0) {
        if (!p) {
            // 如果 p 为空，创建一个数据为 0 的新节点
            LNode *r = (LinkList)malloc(sizeof(LNode));
            if (r == NULL)
                return ERROR; // 如果内存分配失败，则返回错误
            r->data = 0;
            r->next = NULL;

            // 将新节点插入到链表末尾
            if (pre) {
                pre->next = r;
            } else {
                *L = r; // 如果链表为空，则将新节点设为链表头
            }
            p = r; // 更新 p 为新插入的节点
        }

        // 将当前数字乘以基数，并加上进位
        p->data = p->data * base + carry;
        carry = p->data / 10; // 更新下一轮迭代的进位
        p->data %= 10; // 更新当前数字

        pre = p; // 更新前一个节点为当前节点
        p = p->next; // 移动到链表中的下一个节点
    }
    
    return OK; // 如果乘法运算成功，则返回 OK
}



//统计计算结果中0-9出现个数    

void CountNum(LinkList L, int *num)

{

//★★★请补全代码
	LinkList p = L->next;
	while(p)
	{
		num[p->data]  ++;
		p = p->next;
	 } 

}



Status InversePrint(LinkList p){

   //逆序打印不带头结点的单链表的元素    

   if(!p) return OK;

   InversePrint(p->next);

   printf("%d",p->data);

   return OK;

}// 



int main()

{

    int a,n; /* a为底数(0<a<9)，n为指数 */

    int len=0;

    int num[10]; /* 用于统计计算结果中0-9出现次数 */

    LinkList p;

    LinkList L;

    InitList(&L);

    scanf("%d%d",&a,&n);

    int i;

    for(i=0; i<10; i++)

        num[i]=0;        

    /* 生成表头节点并放入1 */

    p=(LinkList)malloc(sizeof(LNode));

    if(p==NULL) return ERROR;

    p->data=1;

    p->next=NULL;

    L->next=p;

    /* 反复调用乘a操作n次 */

    for(i=0; i<n; i++)

        int_mult(&L, a);



    /* 打印计算结果 */

    InversePrint(L->next);

    printf("\n");

    /* 统计计算结果中0-9出现个数 */

    CountNum(L, num);

    for(i=0; i<10; i++){

        printf("the number of %d is: %d\n", i, num[i]);

        len+=num[i];

    }

    printf("the length of the result is %d\n", len);

    return 0;

}
```



### 2024期中考试

#### 1. 期中-顺序表基本操作

```c
#include <stdio.h>

#include <stdlib.h>

#define List_init_size 1000

typedef int Element;

typedef int Status;

#define OK 1

#define ERROR 0

#define TRUE 1

#define FALSE 0

 

typedef struct

{

    Element *elem;

    int length;

    int listsize;

} Sqlist;

 

//初始化顺序表Initialize sequence table

int Initlist(Sqlist *L)

{

    L->elem = (Element *)malloc(List_init_size * sizeof(Element));

    if (!L->elem) return ERROR;

    L->length = 0;

    L->listsize = List_init_size;

    return OK;

}

 

void Createlist(Sqlist *L, int m)

{

    int i;

    for (i = 0; i < m; i++)

    {

       scanf("%d", &L->elem[i]);

    }

    L->length = m;

}

 

int Listinsert(Sqlist *L, int k, int e)

{

    //将元素e插入到第k个元素之前Insert element e before the kth element

    if (k < 1 || k > L->length + 1)return ERROR;

    int j;

    int pos = k;

 

    for (j = L->length - 1; j >= pos - 1; j--)

    {

       L->elem[j + 1] = L->elem[j];

    }

    L->elem[pos - 1] = e;

    L->length++;

    return OK;

 

}

 

//取顺序表的第i个元素Get the i-th element of the sequencial list

Status GetElem(Sqlist L,int i, int *e)

{

   if(i<1 || i>L.length)

      return ERROR;

    *e=L.elem[i-1];

    return OK;

}

 

//判断在顺序表中是否存在某元素（存在返回值TRUE；不存在返回值FALSE）

//Determine whether an element exists in the sequencial list (return value TRUE exists; return value FALSE does not exist)

Status isPresent(Sqlist L, int e){

 

//★★★请补全代码Please complete the code
	int i = 0;
	for(;i < L.length;i ++)
	{
		if(L.elem[i] == e)	return TRUE;
	} 
	return FALSE;
   

}

 

void ComplemSet (Sqlist L1, Sqlist L2, Sqlist *L3)

{

//★★★请补全代码Please complete the code
	int i = 0,k = 1;
	for(;i < L1.length && i < L2.length;i ++)
	{
		if(!isPresent(L2,L1.elem[i]))
		{
			Listinsert(L3,k,L1.elem[i]);
			k++;
		}
	}

}

 

void Display(Sqlist L)

{

//★★★请补全代码Please complete the code
	int i = 0;
	for(;i < L.length;i ++)
	{
		printf("%d ",L.elem[i]);
	}
	printf("\n");

   

}

 

int main()

{

    int m, n;

    Sqlist A, B, C;

    printf("Please enter the number of elements in List A and List B in sequence: \n");

    scanf("%d%d", &m, &n);

    Initlist(&A);

    Initlist(&B);

    Initlist(&C);

    printf("Please enter the elements in List A in sequence: \n");

    Createlist(&A, m);

    printf("Please enter the elements in List B in sequence: \n");

    Createlist(&B, n);

    ComplemSet (A, B, &C);

    printf("The elements of List C are: \n");

    Display(C);

    return 0;

}
```



#### 2. 期中-单链表基本操作

```c
 #include <stdio.h>

#include "stdio.h"

#include "malloc.h"

#include "stdlib.h"

 

#define ERROR -1

#define OK 1

 

typedef struct Lnode

{

       int data;

      struct Lnode *next;

}LNode,*LinkList;

 

int Initlist(LinkList *L)

{

     (*L)=(LinkList)malloc(sizeof(LNode));

     if(L==NULL)

     {

                printf("Memory failure \n");

              return ERROR;

     }

     (*L)->next=NULL;

 

       LinkList r;

       r=*L;

       int x;

       int i;

       for(i=0; ; i++)

       {

              scanf("%d",&x);

              if(x==-1)

              break;

              LNode *p=(LinkList)malloc(sizeof(LNode));

              if(!p)

              {

                     printf("Initialization failure ");

                  return ERROR;

              }

              p->data=x;

              p->next= NULL;

              r->next=p;

              r=p;

       }

      return OK;

}

 

void ListPrint(LinkList L)

{

       LNode *p;

       for(p=L->next;p!=NULL;p=p->next){

              printf("%d ",p->data);

       }

      

}


int ListLength(LinkList L)

{

       //★★★请补全代码
       LNode *p = L->next;
       int count = 0;	//count 作计数器
	   while(p)
	   {
	   		count ++;
	   		p = p->next;
		} 
		return count;

}



void MoveMin(LinkList *L)

{

//★★★请补全代码
	int min = (*L)->next->data;
	LNode *p = (*L)->next;
	while(p)
	{
		if(p->data < min)
		{
			min = p->data;//找到链表的最小值
		}
		p = p->next;
	}
	
	LNode *min_p = (*L)->next;
	LNode *min_pre = (*L);//记录最小值所在节点的前驱结点，以便删除操作
	LNode *r = (*L);//记录头结点位置，以便插入操作，当然直接用*L也行
	int i = 0;
	for(;i < ListLength(*L);i ++)
	{
        if(min_p->data == min)
		{//检索最小值所在节点，并进行移动
			min_pre->next = min_p->next;//去除原链表中最小值所在节点
			min_p->next =  r->next;//将最小值结点插入到首元结点
			r->next = min_p;
			return ;
		}
        min_pre = min_pre->next;
		min_p = min_p->next;
	}
}

int SumToNewlist(LinkList *L)

{

//★★★请补全代码
	int sum = 0;
	LNode *p = (*L)->next;
	while(p)
	{
		sum += p->data;//求和
		p = p->next;
	}
    //创建sum节点
	LNode *r ;
	r = (LNode*)malloc(sizeof(LNode));
	r->data = sum;
	r->next = NULL;
    
    //插到尾节点
	LNode *q = (*L);
	while(q->next)
	{
		q = q->next;
	}
	q->next = r;
    
	return 1;
}

 

int main()

{

       int length;

       LinkList L;

       Initlist(&L);

        printf("The original linked list is：");

       ListPrint(L);

       printf("\nThe length of list is：");

       length=ListLength(L);

       printf("%d ",length);

       MoveMin(&L);

       printf("\nAfter moving the minimum, the linked list is: ");

       ListPrint(L);

       printf("\nAfter inserting the sum, the new list is: ");

       SumToNewlist(&L);

       ListPrint(L);

       return 0;

}
```



#### 3. 期中-顺序栈基本操作及应用

```c
#include "stdio.h"

#include "stdlib.h"

#define OK 1

#define ERROR 0

#define TRUE 1

#define FALSE 0

#define MAXSIZE  20   //堆栈的最大容量

typedef int Status;

typedef char ElemType;

 

//顺序栈的结构定义

typedef struct

{

         ElemType data[MAXSIZE]; //存放堆栈元素的数组

         int top;                 //top指向栈顶元素，top=-1，表示空栈

} SqStack;

 

//初始化一个空栈

void InitStack(SqStack *S)

{

         S->top = -1;

}

Status Push(SqStack *S, ElemType e)

{

//★★★请补全代码
	if((S->top + 1) > MAXSIZE) return ERROR;
	S->top ++;
	S->data[S->top] = e;

 

 

return OK;

}

 

Status Pop(SqStack *S, ElemType *e)

{

//★★★请补全代码
		if(S->top == -1)	return ERROR;
		*e = S->data[S->top];
		S->top--;
         return OK;

}

 

//如果是空栈，返回1，否则返回0

Status StackEmpty(SqStack S)

{

         return S.top == -1;

}

 

char GetTop(SqStack S, ElemType *e)

{

//★★★请补全代码
	if(S.top == -1)	return ERROR;
	*e = S.data[S.top];
	return *e;
 

        

}

 

int main()

{

         char a[20], b[20];

         char temp;

         SqStack Stack;

         InitStack(&Stack);

         printf("Please enter a string with a length no longer than 20:\n");

         gets(a);

        int i = 0;
        char e;
        for(;a[i] != '\0';i ++)
        {
        	if(StackEmpty(Stack) || GetTop(Stack,&e) != a[i])
        	{
        		Push(&Stack,a[i]);
			}
			else if(a[i] != a[i + 1])
			{//因为当a[i] == a[i + 1]时，说明至少有3个重复项，则可能存在奇数个重复项，一进一出肯定就少了
		   		//if(a[i] == a[i + 1])	continue;
				Pop(&Stack,&e);
			}
		}
		int j = 0;
		while(StackEmpty(Stack) == 0)
		{
			Pop(&Stack,&b[j++]);
		}
		printf("The resulting string is: ");
		for(j = j - 1;j >= 0;j --)
		{
			printf("%c",b[j]);
		}

//★★★请补全代码

         return 0;

}
```



#### 4. 期中-删除链队列中的重复元素

```c
#include <stdio.h>

#include <stdlib.h>



typedef int Status;

#define OK 1

#define ERROR 0

#define OVERFLOW -2



//链队列的存储结构

typedef struct QNode {

     int data;

     struct QNode *next;

} QNode, *QueuePtr;



typedef struct {

     QueuePtr front; //队头指针

     QueuePtr rear; //队尾指针

     int QLength; //队长 

} LinkQueue;



//链队列的初始化

Status InitQueue(LinkQueue *Q) {

     Q->front = Q->rear = (QueuePtr) malloc(sizeof(QNode));

     Q->front->next = NULL;

     Q->QLength = 0; 

     return OK;

}



//插入元素e为链队列Q的新的队尾元素

Status EnQueue(LinkQueue *Q, int e) {

     QueuePtr p;

     p = (QueuePtr) malloc(sizeof(QNode));

     p->data = e;

     p->next = NULL;

     Q->rear->next = p;

     Q->rear = p;

     Q->QLength++;

     return OK;

}

//删除链队列Q的队头元素，用e返回其值
Status DeQueue(LinkQueue *Q, int *e) { 
    // 当队列为空时，头指针应该与尾指针相等
    if (Q->QLength == 0 || Q->front == Q->rear)
        return ERROR;
    
    QueuePtr p = Q->front->next;
    *e = p->data;  
    Q->front->next = p->next;
    if (Q->rear == p) // 如果出队的是最后一个元素，则将尾指针指向头结点
        Q->rear = Q->front;
    free(p);
    Q->QLength--;
    return OK;
}



//返回链队列Q的队头元素，不修改队头指针

int GetHead(LinkQueue Q) 
{
     if ((Q.front != Q.rear) && (Q.QLength != 0))
          return Q.front->next->data;
}

int main() {

    //请补全代码
    LinkQueue Q;
    InitQueue(&Q);
    
    int n,i;
    scanf("%d",&n);
    int arr[n];
    for(i = 0;i < n;i ++)
    {
    	scanf("%d",&arr[i]); 
    	EnQueue(&Q,arr[i]);
	}
	//if(n == 1)	printf("%d",arr[i]);
	for(i = 0;i < n;i ++)
	{
		int temp;
		DeQueue(&Q,&temp);
		if(Q.rear->data != temp)	EnQueue(&Q,temp);
	}
		
	QueuePtr p = Q.front->next;
	while(p)
	{
		printf("%d ",p->data);
		p = p->next;
	}
    return 0;
}

```



#### 5. 期中-串的堆分配基本操作

```c
#include <stdio.h>
#include <stdlib.h>


typedef struct{
   char *ch;       //若串非空,则按串长分配存储区,
                   //否则ch为NULL
   int  length;    //串长度
}HString;

typedef int Status;
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0

Status InitString(HString *T) {
	(*T).length=0;
	(*T).ch=NULL;
	return OK;
}


Status ClearString(HString *S){
//将S清为空串
	if((*S).ch) {
		free((*S).ch); 
	}
	(*S).ch = NULL;
	(*S).length=0;
	return OK;
}//ClearString

Status StrAssign(HString *T,char *chars){

//*************补全代码*************
	int i = 0;
	T->ch = (char*)malloc(100 *sizeof(char));
	for(;chars[i] != '\0';i ++)
	{
		(*T).ch[i] = chars[i];
	} 
	(*T).length = i;
	return OK;

}//StrAssign    


int StrLength(HString S){
//返回S的元素个数,称为串的长度
	return S.length;
}//StrLength

int StrCompare(HString S,HString T){
//若S=T,返回值=0;
	
	//*****补全代码********
	int i = 0;
	for(;i < S.length && i < T.length;i++)
	{
		if(S.ch[i] != T.ch[i])	return S.ch[i] - T.ch[i];
	}
	return S.length - T.length;
	

}//StrCompare    

Status StrInsert(HString *S,int pos,HString T){

 //*********补全代码***********
 	int i = 0;
 	if(pos > S->length + 1 || pos < 1)		return ERROR;
 	
 	for(i = S->length;i >= pos;i --)
 	{//将S->ch中第pos位及以后的总计S->length - pos + 1个字符往后移T->length个长度
 		S->ch[i + T.length - 1] = S->ch[i - 1];
	}
	for(i = 0;i < T.length ;i ++)
	{//将S->ch中第pos位及以后总计T->length个字符replace成T->ch中的字符
		S->ch[i + pos - 1] = T.ch[i];
	}
	S->length += T.length; //更新S->length
	return OK;

	
}//StringInsert    


void StrTravel(HString S)
{
	int i;
	for(i=0;i<S.length;i++)
	{
		printf("%c",S.ch[i]);
	}
	printf("\n");
}

int main()
{
	HString S1,S2,S3;
	InitString(&S1);//初始化串1
	InitString(&S2);//初始化串2
	InitString(&S3);//初始化串3
	char str1[100],str2[100],str3[100];
	scanf("%s",str1);
	scanf("%s",str2);
	scanf("%s",str3);
	StrAssign(&S1,str1);//串1赋值
	StrAssign(&S2,str2);//串2赋值
	StrAssign(&S3,str3);//串3赋值
	int pos;
	scanf("%d",&pos);

	StrTravel(S1);
	StrTravel(S2);
	StrTravel(S3);
	if(StrInsert(&S1,pos,S2)==OK)//串插入
	{
		StrTravel(S1);//串打印输出
	}
	else
	{
		printf("insert fail\n");
	}
	int cmp = StrCompare(S1,S3);
	if(cmp == 0)
		printf("equal\n");
	else
		printf("not equal\n");
	ClearString(&S1);
	ClearString(&S2);
	ClearString(&S3);
	return 0;
}

```



#### 6. 期中-逆波兰表达式求值

```c
#include<stdio.h>
#include<malloc.h>

#define OK 1
#define ERROR 0

typedef int SElemType;

typedef int Status;

typedef struct Lnode{
	SElemType data;
	struct Lnode *next;
	
}LNode,*LinkList;

typedef struct{
	LinkList Head;
	int length;
	
}LinkStack;

Status InitLinkStack(LinkStack *S)
{
	S->Head = (LinkList)malloc(sizeof(LNode));
	if(!S->Head)
		return ERROR;
	
	S->Head->next = NULL;
	S->length = 0;
	
	return OK;
} 


Status StackEmpty(LinkStack S)
{

	return (S.Head->next == NULL);
	
}

Status Push(LinkStack *S, SElemType e)
{
	LinkList p;
	
	p = (LinkList)malloc(sizeof(LNode));
	if(!p)
		return ERROR;
	
	p->data = e;
	p->next = S->Head->next;
	S->Head->next = p;
	S->length++;
	
	return OK;
	
}

Status GetTop(LinkStack S, SElemType *e)
{
	if(!S.Head->next )
		return ERROR;
	
	*e = S.Head->next->data;
	
	return OK;
	
}

Status Pop(LinkStack *S, SElemType *e)
{
	
	LinkList p;
	
	p = S->Head->next;
	
	if(!p)
		return ERROR;

	*e = p->data;
	
	S->Head->next = p->next;
	free(p);
	
	S->length--;
	
	return OK;
	
}

int StackLength(LinkStack S)
{
	return S.length;
	
}

/* 四则运算函数定义：
  * 输入参数：操作数n1,n2,运算符op,运算结果指针out；
  * 处理规则及返回值：计算n1 op n2的结果，并将结果赋给*out；
  *                如果出现除零，返回ERROR，否则返回OK；*/
 Status Operate(int n1,char op,int n2,int *out){
     switch (op) {
         case '+':
             *out = n1 + n2;
             return OK;
         case '-':
             *out = n1 - n2;
             return OK;
         case '*':
             *out = n1 * n2;
             return OK;
         case '/':
             if(n2 == 0)
                 return ERROR;
             else{
                 *out = n1 / n2;
                 return OK;
             }
     }
 }
 
 /* 逆波兰表达式计算函数定义：
  * 输入参数：表达式字符串指针s,运算结果指针res；
  * 处理规则及返回值：计算表达式*s的值，并将结果赋给*out；
  *               如果出现逆波兰表达式错误，返回ERROR，否则返回OK；*/
Status calculate_RP(char *s, int *res){

  //=============================
  //请补充完整
  //=============================
	  int i = 0,n1,n2;
	  LinkStack S;
	  InitLinkStack(&S);
	  for(;s[i] != '\0';i ++)
	  {
	  	if (s[i] >= '0' && s[i] <= '9') 
        {//两位及以上的数字字符（数字中间没有空格）转化为10进制数
            int num = 0;
            while (s[i] >= '0' && s[i] <= '9') 
            {
                num = num * 10 + (s[i] - '0');
                i++;
            }
            Push(&S,num);
        }
		else if(s[i] != ' ')//细节：输入进栈的时候，是有空格号的，这个不要忘了
		{
			if(Pop(&S,&n1) == ERROR)	return ERROR;
			if(Pop(&S,&n2) == ERROR)	return ERROR;
			if(Operate(n2,s[i],n1,res) == ERROR)	return ERROR;
			Push(&S,*res);
		}	
	   } 
	   if(S.length != 1)	return ERROR;
	return OK;
}

int main() {
    int result = 0;
    char notation[100];
    gets(notation);
    //puts(notation);
    //计算逆波兰表达式的值
    if(calculate_RP(notation,&result)){
        printf("%d\n",result);
    }
    else{
        printf("Wrong notation!\n");
    }

    return 0;
}

```



#### 7. 期中-2024年春晚扑克牌游戏模拟

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define OK 1
#define ERROR 0
#define OVERFLOW -1
typedef int Status;

// 定义扑克牌结构

typedef struct {
    char suit[10];   //花色： "Hearts", "Diamonds", "Clubs", "Spades"
    char face[10];   //面值： "Ace", "2", "3", "4", "5", "6", "7", "8", "9", "10", "Jack", "Queen", "King" 
} Card, QElemType, SElemType;


typedef struct Lnode{
	SElemType data;
	struct Lnode *next;
	
}LNode,*LinkList;

typedef struct{
	LinkList Head;
	int length;
	
}LinkStack;

Status InitLinkStack(LinkStack *S)
{
	S->Head = (LinkList)malloc(sizeof(LNode));
	if(!S->Head)
		return ERROR;
	
	S->Head->next = NULL;
	S->length = 0;
	
	return OK;
} 


Status StackEmpty(LinkStack S)
{
	return (S.Head->next == NULL);
	
}

Status Push(LinkStack *S, SElemType e)
{
	LinkList p;
	
	p = (LinkList)malloc(sizeof(LNode));
	if(!p)
		return ERROR;
	
	p->data = e;
	p->next = S->Head->next;
	S->Head->next = p;
	S->length++;
	
	return OK;
	
}

Status GetTop(LinkStack S, SElemType *e)
{
	if(!S.Head->next )
		return ERROR;
	
	*e = S.Head->next->data;
	
	return OK;
	
}

Status Pop(LinkStack *S, SElemType *e)
{
	
	LinkList p;
	
	p = S->Head->next;
	
	if(!p)
		return ERROR;

	*e = p->data;
	
	S->Head->next = p->next;
	free(p);
	
	S->length--;
	
	return OK;
	
}

int StackLength(LinkStack S)
{
	return S.length;
	
}


#define MAXQSIZE  10   //最大队列长度
typedef struct {
   QElemType *base;   //初始化的动态分配存储空间
   int  front;                    //头指针   
   int  rear;                     //尾指针
}SqQueue;  


char suits[4][10] = {"Hearts", "Diamonds", "Clubs", "Spades"};
char faces[13][10] = {"Ace", "2", "3", "4", "5", "6", "7", "8", "9", "10", "Jack", "Queen", "King"};

Status InitQueue (SqQueue *Q){
   //构造一个空队列Q
   Q->base=(QElemType *) malloc(MAXQSIZE *sizeof(QElemType)); 
   if(!Q->base) return ERROR;
   Q->front=Q->rear=0;
   return OK;
}//InitQueue

Status QueueEmpty (SqQueue Q){
    return (Q.front==Q.rear);                             
}// QueueEmpty

Status EnQueue(SqQueue *Q,QElemType e){
    if((Q->rear+1)%MAXQSIZE==Q->front)  return ERROR;//队列满
    Q->base[Q->rear]=e;
    Q->rear=(Q->rear+1)%MAXQSIZE;
     return OK;
}//EnQueue

Status DeQueue (SqQueue *Q,QElemType *e){
   if(Q->front==Q->rear) return ERROR;
   *e=Q->base[Q->front];
   Q->front=(Q->front+1)%MAXQSIZE;
   return OK;
}//DeQueue

Status QueueTraverse(SqQueue Q,void(*vi)(QElemType))
{ /* 从队头到队尾依次对队列Q中每个元素调用函数vi().一旦vi失败,则操作失败 */
   int i;
   i=Q.front;
   while(i!=Q.rear)
   {
     vi(*(Q.base+i));
     i=(i+1)%MAXQSIZE;
   }
   printf("\n");
   return OK;
}

/* prepare card */
void prepare_card(LinkStack *S, char suit, int face)
{
  
//***补全代码****  
	if(face > 13 || face < 1 || suit != 'H' || suit != 'D' || suit != 'C' || suit != 'S' )
	{
		printf("Illegal suit input");
		exit(-1);
		 }	 
	
  
  
}
/* expand cards */
void expand_card(SqQueue *Q)
{

//***补全代码****


}
/* shuffle cards */
void shuffle_card(SqQueue *Q, int num){

    int i;
    QElemType e;
    for(i=0; i<num; i++){
        DeQueue(Q, &e);
        EnQueue(Q, e);
    }

}

/* insert first k cards into bottom after pos  */
void insert_card(SqQueue *Q, int k, int pos)
{

//***补全代码****


}


// print card
void printCard(Card card) {
    if(card.face[1]=='0')
        printf("[%c-%c%c]", card.suit[0], card.face[0], card.face[1]);
    else
        printf("[%c-%c]", card.suit[0], card.face[0]);
}

int main() {
    int i;
    char suit;  /* 存储扑克花色的首字母  */
    int face;  /* 存储扑克牌的分值, 分值为1~13 */
    int pos; /* 存储第3步插入那张牌后面 */
    int name; /* 名字字数 */
    int gender;  /* 存储扔掉牌数量：男生1 或女生 2 */
    Card card, secret;

    SqQueue Q; /* 存储扑克牌堆 */
    LinkStack S;
    InitQueue(&Q);
    InitLinkStack(&S);
/* 1. 拿出4张扑克牌并随意打乱顺序； */
/* 根据输入的数字和花色抽取4张牌，完成第1步 */
    // printf("Please input 4 card suit and face (example: H-3):\n");
    for(i=0; i<4; i++) {
        /* 顺序输入4章扑克牌的花色和分值和，花色在后;分值在前 */
        scanf("%c-%d", &suit, &face);
        getchar();
        prepare_card(&S, suit, face);
    }

    for(i=0; i<4; i++){
        Pop(&S, &card);
        EnQueue(&Q, card);
    }
    printf("After 1-step process:\n");
    QueueTraverse(Q, printCard);
/* 2. 撕开扑克牌重叠放在一起； */    
    expand_card(&Q);
    printf("After 2-step process:\n");
    QueueTraverse(Q, printCard);

/* 3.根据名字字数循环扑克n次；*/
    // printf("Please input the length of your name: ");
    scanf("%d", &name);
    shuffle_card(&Q, name);
    printf("After 3-step process:\n");
    QueueTraverse(Q, printCard);
/* 4. 将最上面的3张扑克牌随机插入下面的扑克牌中间； */
    // printf("Please input the 1-st insert position(3<k<n): ");
    scanf("%d", &pos);
    insert_card(&Q, 3, pos);
    printf("After 4-step process:\n");
    QueueTraverse(Q, printCard);
/* 5.将最上面的扑克牌最为谜底保存起来； */ 
    DeQueue(&Q, &secret);
    printf("After 5-step process:\n");
    QueueTraverse(Q, printCard);
/* 6.将最上面的3张扑克牌随机插入下面的扑克牌中间； */    
    // printf("Please input the 2nd insert position(3<k<n): ");
    scanf("%d", &pos);
    insert_card(&Q, 3, pos);
    printf("After 6-step process:\n");
    QueueTraverse(Q, printCard);
/* 7. 根据男生或者女生，将最上面的扑克牌扔出去1张或者2张； */
    // printf("Please input your gender(male:1, fename:2): ");
    scanf("%d", &gender);
    DeQueue(&Q, &card);
    if(gender==2)
        DeQueue(&Q, &card);
    printf("After 7-step process:\n");
    QueueTraverse(Q, printCard);
/* 8. “见证奇迹的时刻”，将扑克牌循环7次 */
    shuffle_card(&Q, 7);
    printf("After 8-step process:\n");
    QueueTraverse(Q, printCard);
/* 9. “好运留下来，烦恼丢出去”，循环一次丢弃一次 */
    while((Q.rear-Q.front+MAXQSIZE)%MAXQSIZE != 1){
        shuffle_card(&Q, 1);
        DeQueue(&Q, &card);
        // QueueTraverse(Q, printCard);
    }

    DeQueue(&Q, &card);
    printf("Final 9-step process:\n");
    printCard(card);
    printf("\n");
    printf("Secrete card:\n");
    printCard(secret);
    printf("\n");
    return 0;
}


```

