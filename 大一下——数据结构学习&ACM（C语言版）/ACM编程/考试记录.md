### 2023期中考试

#### 1. 2023春期中机考第一题 顺序表（7+8 = 15分)

```c
#include <stdio.h>

#include <stdlib.h>

#define OK 1

#define ERROR 0



typedef struct

{

	int *elem;

	int length;

	int listsize;

} sqlist;



//初始化一个空的顺序表

int initlist(sqlist *l)

{

	l->elem = (int *)malloc(100 * sizeof(int));

	if (!l->elem)

		return ERROR;

	l->length = 0;

	l->listsize = 100;

	return OK;

}



//根据长度为n的数组x，创建顺序表L   

//如果成功返回OK，否则返回ERROR

int insertlist(sqlist *l, int a[], int n)

{
	int i; 
	for (i = 0; i < n; i++)

	{

		l->elem[i] = a[i];

	}

	l->length = n;

	return OK;

}



//将顺序表a中大于t的元素存入顺序表b中

void getb(sqlist *b, sqlist a, int t)

{

	//★★★请补全代码
	int i = 0,j = 0;
	for(;i < a.length;i ++)
	{
		if(a.elem[i] > t)	
		{
			b->elem[j + b->length] = a.elem[i];	
			j ++;
		}
	} 
	b->length += j;

}



// 将b中的元素逆置，并打印输出逆置后b中所有元素

void  reverselist(sqlist *b)

{

	//★★★请补全代码
	int i = 0;
	for(;i * 2 < b->length;i ++)
	{
		int temp = b->elem[i];
		b->elem[i] = b->elem[b->length - i - 1];
		b->elem[b->length - i - 1] = temp;		
	}

}



int main()

{

	sqlist a,b;

	initlist(&a);

	initlist(&b);

	int x[100];

	int n,i;

	scanf("%d", &n);

	for (i = 0; i < n; i++)

	{

		scanf("%d", &x[i]);

	}

	insertlist(&a, x, n);

	int t;

	scanf("%d", &t);

	getb(&b, a, t);

	reverselist(&b);
	
	for(i = 0;i < b.length;i ++)
	{
		printf("%d ",b.elem[i]);
	}

	return 0;

}


```



#### 2. 2023春期中机考第二题 链表（5+7+8=20分）

```C
#include <stdio.h>

#include <stdlib.h>

#define ERROR -1

#define OK 1



typedef struct Lnode

{

	int data;

	struct Lnode *next;

}LNode,*LinkList;



// 创建带头结点的单链表

int CreateList(LinkList *L)

{

	*L=(LinkList)malloc(sizeof(LNode));

	if((*L)==NULL)

	{

		printf("Memory failure\n");

		return ERROR;

	}

	(*L)->next=NULL;

	LinkList r;

	r=*L;

	int x;

	int i;

	for(i=0; ; i++)

	{

		scanf("%d",&x);

		if(x==-1)

		break;

		LNode *p=(LinkList)malloc(sizeof(LNode));

		if(!p) 

		{

			printf("Initialization failure");

			return ERROR;

		}

		p->data=x;

		p->next= NULL;

		r->next=p;

		r=p;

	}

	return OK;

}



//打印单链表

void ListPrint(LinkList L)

{

	LNode *p;

	for(p=L->next;p!=NULL;p=p->next)

	{

		printf("%d ",p->data);

	}

}



//求单链表长度

int ListLength(LinkList L)

{

	//★★★请补全代码
	int len = 0;
	 LinkList p = L->next;
	 while(p)
	 {
	 	len ++;
	 	p = p->next;
	 }
	return len;






}



//删除单链表的倒数第x个元素, 参数length为单链表长度，

//如果操作成功，返回OK，否则返回ERROR

int DeleteX(LinkList  *L,int length, int x)

{
	
	if(x > ListLength(*L))
	{
		printf("\nThe x value is not valid");
		return 0;
	}

	//★★★请补全代码
	int i = 0;
	LinkList p = (*L);
	while(p->next && i < length - x)
	{
		p = p->next;
		i ++;
	}
	LinkList s = p->next;
	p->next = s->next;
	free(s);
	return OK;







}



//单链表元素求和，并将累加和添加到单链表尾部

//如果操作成功，返回OK，否则返回ERROR

int AppendSumToList(LinkList *L)

{

	//★★★请补全代码
	int sum = 0;
	LinkList p = (*L);
	while(p->next)
	{
		sum += p->next->data;
		p = p->next;
	}
	LinkList s;
	s = (LinkList)malloc(sizeof(LNode));
	if(!s)	return ERROR;
	s->data = sum;
	s->next = NULL;
	p->next = s;
	return 1;
	






} 



int main()

{

	int length;

	int x;

	LinkList L;

	CreateList(&L);

	scanf("%d",&x);
	


	printf("The original linked list is：");

	ListPrint(L);

	printf("\nThe length of list is：");

	length=ListLength(L);

	printf("%d ",length);
	
	DeleteX (&L,length, x);

	printf("\nAfter deleting the element, the linked list is: ");

	ListPrint(L);

	printf("\nAfter inserting the sum, the new list is: ");

	AppendSumToList(&L);

	ListPrint(L);

	return 0;

}
```



#### 3. 2023春期中机考第三题 链队列（7+8=15分）

```c
#include <stdio.h>

#include <stdlib.h>

#define OK 1

#define ERROR 0

#define OVERFLOW 0



typedef char ElemType;

typedef int Status;

typedef struct QNode

{

    ElemType data;

    struct QNode *next;

}QNode,*queuePtr;   



typedef struct

{

    queuePtr front; //指向链队列的头

    queuePtr rear;  //指向链队列的尾 

}LinkQueue;



//队列初始化

Status InitQueue(LinkQueue *q)

{

   q->front=q->rear=(queuePtr)malloc(sizeof(QNode));  //创建头节点 头指针指向头节点

   if(!q->front)  //创建失败

   {

       return ERROR;

   }

   q->front->next=NULL;

   return OK;

}



//判断队列是否为空

Status QueueEmpty(LinkQueue Q)

{

    if(Q.front==Q.rear)

        return OK;

    else

        return ERROR;

}// QueueEmpty



int QueueLength (LinkQueue Q)

{

    int i;

    queuePtr p;

    p = Q.front->next;   //p指向队头

    i=1;

    while(p!=Q.rear)  //遍历链队列,统计结点数

	{

        i++;

        p=p->next;

    }

    return i;

}// QueueLength



//获得队首元素

Status GetHead(LinkQueue q,ElemType *e)

{

    if(q.front == q.rear)

        return ERROR;

    *e = q.front->next->data;

    return OK;

}



//入队

Status EnQueue(LinkQueue *q,ElemType e)

{

    queuePtr p=(queuePtr)malloc(sizeof(QNode)); //为新元素分配空间

    if(!p) return ERROR; 

    p->data=e;

    p->next=NULL;

    q->rear->next=p; //为尾指针的next重新赋值 将元素插入表尾

    q->rear=p;  //重新定位尾指针

    return OK;

}



//删除元素

Status DeQueue(LinkQueue *q,ElemType *e)

{

    if(q->front == q->rear) return ERROR; //此时队列为空

    queuePtr p = q->front->next;  

    *e=p->data;  //删除是队首元素

    q->front->next=p->next;

    if(q->rear == p)

        q->rear=q->front;

    free(p);

    return OK;

}



//清空链队列，如果成功，返回OK，否则返回ERROR

Status ClearQueue (LinkQueue *Q)

{

	//★★★请补全代码
	if(!Q->front)	return ERROR;
	free(Q->front);
	Q->front = Q->rear = 0;
	return OK; 

}// ClearQueue



//输出队列

Status PrintQueue(LinkQueue q)

{

    queuePtr p;

    p = q.front->next;

    while(p)

    {

        printf("%c ",p->data);

        p=p->next;

    }

    return OK;

}



//解密游戏

void DecryptGame(LinkQueue *Q)

{

	//★★★请补全代码
	LinkQueue S;
	InitQueue(&S);
	
	while(!QueueEmpty(*Q))
	{
		char temp;
		DeQueue(Q,&temp);
		EnQueue(&S,temp);
		if(!QueueEmpty(*Q))
		{
			DeQueue(Q,&temp);
			EnQueue(Q,temp);
		}
	} 

	PrintQueue(S);

 



}



int main()

{

    LinkQueue Q;

    InitQueue(&Q);

    int i;

    char a;

    for(i=0;i<10;i++)

    {

        scanf("%c",&a);

        EnQueue(&Q,a);

    }

    DecryptGame(&Q);

    printf("\n");

    ClearQueue(&Q);

    return 0;

}
```



#### 4. 2023春 期中考试 第四题 顺序栈（5+10=15分）

```c
#include<stdio.h>

#include<stdlib.h>

#define OK 1

#define ERROR 0

#define OVERFLOW -2

#define MAXSIZE  100



typedef int Status;

typedef int SElemType;

typedef struct{

	SElemType *base;

	SElemType *top;

	int stacksize;

}SqStack;



//顺序栈的初始化

Status InitStack(SqStack *S){ 

	S->base = (SElemType *)malloc(MAXSIZE * sizeof(SElemType));

	if(!S->base)

		return ERROR;

	S->top = S->base;

	S->stacksize = MAXSIZE;

	return OK;

}



Status Push(SqStack *S,SElemType e)
{

	//★★★请补全代码
	if(S->top - S->base >= S->stacksize)	return ERROR;
	*(S->top ++) = e;
	return OK;


}



//顺序栈的出栈

Status Pop(SqStack *S,SElemType *e){

	if(S->base == S->top)

		return ERROR;

	*e = *(--S->top);

	return OK;

}


// 将一个十进制数转换为二进制数，并打印输出

// 要求使用堆栈来实现，如果未用堆栈，答题无效



int main()

{

	//★★★请补全代码
	int n;
	scanf("%d",&n);
	if(n <= 0)
	{
		printf("Input error!");
		return 0;
	}
	
	SqStack S;
	InitStack(&S);
	
	while(n)
	{
		int x = n%2;
		Push(&S,x);
		n = (n - x) / 2;
	}
	
	while(S.base != S.top)
	{
		int e;
		Pop(&S,&e);
		printf("%d",e);
	}
	return 0;
}

```



#### 5. 2023春 期中考试 第五题 字符串 (7+8=15分)

```c
#include <stdio.h>   

#include <stdlib.h>   



#define ERROR 0

#define OK 1

#define TRUE 1

#define FALSE 0

#define MAXSIZE 20



typedef struct

{

    char *ch;       //若串非空,则按串长分配存储区

    int  length;    //串长度

}HString;



int InitString(HString *T) 

{

    T->ch=(char*)malloc(sizeof(char)*MAXSIZE);

    if(!T->ch)

        return ERROR;

    T->length=0;

    return OK;

}



//将字符数组chars赋值到串T

//如果操作成功，返回OK，否则返回ERROR

int StrAssign(HString *T,char *chars)

{

//★★★请补全代码
	int i = 0;
	for(;chars[i] !='\0';i++)
	{
	}
	if(!i)
	{
		T->ch = NULL;
		T->length = 0;
	}
	else
	{
		int j = 0;
		for(j = 0;chars[j] != '\0';j ++)
		{
			T->ch[j] = chars[j];
			T->length ++;
		}
		
	}
	return OK;


}



   

// 比较字符串大小

//（1）如果两个串长度相等，且每一个相应位置上的字符都一样，则结果为0；

//（2）如果两个串长度不相等，则则以第一个不相同的字符作为基准，返回第一个不相同的字符ASCII差值；

//（3）如果两个串长度不相等，且所有相应位置上的字符都一样，则返回两个字符串的长度之差。

int StrCompare(HString S,HString T)

{

  //★★★请补全代码
  int i = 0;
  while(i < S.length && i < T.length)
  {
  		if(S.ch[i] != T.ch[i])	return (S.ch[i] - T.ch[i]);
  		i++; 
  }
  return S.length - T.length;



}//StrCompare    



int main()

{

    HString S;

    HString T;

    char mainstr[20];

    char substr[10];

    int index;

    InitString(&S);

    InitString(&T);

    gets(mainstr);

    gets(substr);

    StrAssign(&S,mainstr);

    StrAssign(&T,substr);

    printf("%d\n",StrCompare(S,T));

    return 1;

}
```



#### 6. 2023春 期中考试 第六题 综合题（一） (7分)

```c
#define MAXINTSIZE 512 /* 最大整数长度 */

#include<stdio.h>

#include<stdlib.h>



#define ERROR 0

#define OK 1

typedef int Status;



typedef struct Node

{

    int data;

    struct Node *next;

} LNode;

typedef LNode *LinkList;



/* 用头插法建立单链表 */

Status CreateList(LinkList *L, char *chars)

{

     //★★★请补全代码
    LinkList p = (*L);
	int i = 0;
	for(;chars[i] != '\0';i ++)
	{
		LNode *r;
		r = (LinkList)malloc(sizeof(LNode));
		if(!r)	return ERROR;
		r->data = chars[i] - '0';
		r->next = p->next;
		p->next = r;
		//p = r;
	}
	return OK;



}



int ListLength_L(LinkList L){

    LinkList p;

    int i=0;             

    p=L->next;        //p指向第一个结点

    while(p){         //遍历单链表,统计结点数

        i++;

        p=p->next;

    } 

    return i;                             

}// ListLength_L



Status  InversePrint(LinkList p){

   //逆序打印不带头结点的单链表的元素    

   if(!p) return OK;
   
   //printf("%d",p->data);

   InversePrint(p->next);

   printf("%d",p->data);

   return OK;

}// 



int main()

{

    int len;

    char str[MAXINTSIZE+1];

    LinkList L;

    scanf("%s", str);
    
    L = (LinkList)malloc(sizeof(LNode));

    CreateList(&L, str);

    len=ListLength_L(L);

    printf("the length of the integer is %d\n", len);

    InversePrint(L->next);

    printf("\n");

    return 0;

}


```



#### 7. 2023春 期中考试 第六题 综合题（二） (7+6=13分)

```c
#include<stdio.h>

#include<stdlib.h>



#define ERROR 0

#define OK 1



typedef int Status;



typedef struct Node

{

    int data;

    struct Node *next;

} LNode;

typedef LNode *LinkList;



Status InitList(LinkList *L)

{

    *L = (LinkList)malloc(sizeof(LNode));

    if (*L == NULL)

        return ERROR;

    (*L)->next = NULL;

    return OK;

}

// 单链表表示的大整数与整数相乘

//自己的代码
//int int_mult(LinkList *L, int base) 
//{
//	
//	int carry = 0;
//	LNode *p = (*L);
//	LNode *pre = NULL;
//	
//	while(p)
//	{
//		p->data = p->data * base + carry;
//		carry = p->data / 10;
//		p->data = p->data % 10;
//		pre = p;
//		p = p->next;
//	}
//	
//	if(!p && carry)
//	{
//		p = (LinkList)malloc(sizeof(LNode));
//		if(!p)	return ERROR;
//		p->data = carry;
//		p->next = NULL;
//		pre->next = p;
//	}
//	return OK;
//}

// 单链表表示的大整数与整数相乘

int int_mult(LinkList *L, int base) {
    int carry = 0;
    LinkList p = *L; // 从链表头开始遍历
    LinkList pre = NULL; // 记录当前节点的前一个节点，为后面进行尾插新节点提供前驱

    // 遍历链表
    while (p || carry != 0) {
        if (!p) {
            // 如果 p 为空，创建一个数据为 0 的新节点
            LNode *r = (LinkList)malloc(sizeof(LNode));
            if (r == NULL)
                return ERROR; // 如果内存分配失败，则返回错误
            r->data = 0;
            r->next = NULL;

            // 将新节点插入到链表末尾
            if (pre) {
                pre->next = r;
            } else {
                *L = r; // 如果链表为空，则将新节点设为链表头
            }
            p = r; // 更新 p 为新插入的节点
        }

        // 将当前数字乘以基数，并加上进位
        p->data = p->data * base + carry;
        carry = p->data / 10; // 更新下一轮迭代的进位
        p->data %= 10; // 更新当前数字

        pre = p; // 更新前一个节点为当前节点
        p = p->next; // 移动到链表中的下一个节点
    }
    
    return OK; // 如果乘法运算成功，则返回 OK
}



//统计计算结果中0-9出现个数    

void CountNum(LinkList L, int *num)

{

//★★★请补全代码
	LinkList p = L->next;
	while(p)
	{
		num[p->data]  ++;
		p = p->next;
	 } 

}



Status InversePrint(LinkList p){

   //逆序打印不带头结点的单链表的元素    

   if(!p) return OK;

   InversePrint(p->next);

   printf("%d",p->data);

   return OK;

}// 



int main()

{

    int a,n; /* a为底数(0<a<9)，n为指数 */

    int len=0;

    int num[10]; /* 用于统计计算结果中0-9出现次数 */

    LinkList p;

    LinkList L;

    InitList(&L);

    scanf("%d%d",&a,&n);

    int i;

    for(i=0; i<10; i++)

        num[i]=0;        

    /* 生成表头节点并放入1 */

    p=(LinkList)malloc(sizeof(LNode));

    if(p==NULL) return ERROR;

    p->data=1;

    p->next=NULL;

    L->next=p;

    /* 反复调用乘a操作n次 */

    for(i=0; i<n; i++)

        int_mult(&L, a);



    /* 打印计算结果 */

    InversePrint(L->next);

    printf("\n");

    /* 统计计算结果中0-9出现个数 */

    CountNum(L, num);

    for(i=0; i<10; i++){

        printf("the number of %d is: %d\n", i, num[i]);

        len+=num[i];

    }

    printf("the length of the result is %d\n", len);

    return 0;

}
```



### 2024期中考试

#### 1. 期中-顺序表基本操作

```c
//complement 未修改L.length 扣1分
#include <stdio.h>

#include <stdlib.h>

#define List_init_size 1000

typedef int Element;

typedef int Status;

#define OK 1

#define ERROR 0

#define TRUE 1

#define FALSE 0

 

typedef struct

{

    Element *elem;

    int length;

    int listsize;

} Sqlist;

 

//初始化顺序表Initialize sequence table

int Initlist(Sqlist *L)

{

    L->elem = (Element *)malloc(List_init_size * sizeof(Element));

    if (!L->elem) return ERROR;

    L->length = 0;

    L->listsize = List_init_size;

    return OK;

}

 

void Createlist(Sqlist *L, int m)

{

    int i;

    for (i = 0; i < m; i++)

    {

       scanf("%d", &L->elem[i]);

    }

    L->length = m;

}

 

int Listinsert(Sqlist *L, int k, int e)

{

    //将元素e插入到第k个元素之前Insert element e before the kth element

    if (k < 1 || k > L->length + 1)return ERROR;

    int j;

    int pos = k;

 

    for (j = L->length - 1; j >= pos - 1; j--)

    {

       L->elem[j + 1] = L->elem[j];

    }

    L->elem[pos - 1] = e;

    L->length++;

    return OK;

 

}

 

//取顺序表的第i个元素Get the i-th element of the sequencial list

Status GetElem(Sqlist L,int i, int *e)

{

   if(i<1 || i>L.length)

      return ERROR;

    *e=L.elem[i-1];

    return OK;

}

 

//判断在顺序表中是否存在某元素（存在返回值TRUE；不存在返回值FALSE）

//Determine whether an element exists in the sequencial list (return value TRUE exists; return value FALSE does not exist)

Status isPresent(Sqlist L, int e){

 

//★★★请补全代码Please complete the code
	int i = 0;
	for(;i < L.length;i ++)
	{
		if(L.elem[i] == e)	return TRUE;
	} 
	return FALSE;
   

}

 
//complement 未修改L.length
void ComplemSet (Sqlist L1, Sqlist L2, Sqlist *L3)

{

//★★★请补全代码Please complete the code
	int i = 0,k = 1;
	for(;i < L1.length && i < L2.length;i ++)
	{
		if(!isPresent(L2,L1.elem[i]))
		{
			Listinsert(L3,k,L1.elem[i]);
			k++;
		}
	}

}

 

void Display(Sqlist L)

{

//★★★请补全代码Please complete the code
	int i = 0;
	for(;i < L.length;i ++)
	{
		printf("%d ",L.elem[i]);
	}
	printf("\n");
}

 

int main()

{

    int m, n;

    Sqlist A, B, C;

    printf("Please enter the number of elements in List A and List B in sequence: \n");

    scanf("%d%d", &m, &n);

    Initlist(&A);

    Initlist(&B);

    Initlist(&C);

    printf("Please enter the elements in List A in sequence: \n");

    Createlist(&A, m);

    printf("Please enter the elements in List B in sequence: \n");

    Createlist(&B, n);

    ComplemSet (A, B, &C);

    printf("The elements of List C are: \n");

    Display(C);

    return 0;

}
```



#### 2. 期中-单链表基本操作

```c
//第一问代码有瑕疵， 扣1分
//第二问逻辑轻度复杂， 扣1分
//第三问效率低， 扣1分
#include <stdio.h>

#include "stdio.h"

#include "malloc.h"

#include "stdlib.h"

 

#define ERROR -1

#define OK 1

typedef struct Lnode

{

       int data;

      struct Lnode *next;

}LNode,*LinkList;

 

int Initlist(LinkList *L)

{

     (*L)=(LinkList)malloc(sizeof(LNode));

     if(L==NULL)

     {

                printf("Memory failure \n");

              return ERROR;

     }

     (*L)->next=NULL;

 

       LinkList r;

       r=*L;

       int x;

       int i;

       for(i=0; ; i++)

       {

              scanf("%d",&x);

              if(x==-1)

              break;

              LNode *p=(LinkList)malloc(sizeof(LNode));

              if(!p)

              {

                     printf("Initialization failure ");

                  return ERROR;

              }

              p->data=x;

              p->next= NULL;

              r->next=p;

              r=p;

       }

      return OK;

}

 

void ListPrint(LinkList L)

{

       LNode *p;

       for(p=L->next;p!=NULL;p=p->next){

              printf("%d ",p->data);

       }

      

}

//第一问代码有瑕疵，
int ListLength(LinkList L)

{

       //★★★请补全代码
       LNode *p = L->next;
       int count = 0;	//count 作计数器
	   while(p)
	   {
	   		count ++;
	   		p = p->next;
		} 
		return count;

}



void MoveMin(LinkList *L)

{

//★★★请补全代码
	//在遍历链表寻找最小值时就维护好最小值所在结点及其前驱 
	// 如此便不需要记录最小值data， 不需要后续再遍历一次 
	LNode *min_p = (*L)->next;
	LNode *min_pre = (*L);//记录最小值所在节点的前驱结点，以便删除操作
	LNode *pre = (*L);
	LNode *p = (*L)->next;
    
	while(p)
	{
		if(p->data < min_p->data)//这里比较大小就是记录最小值结点的data
		{
			min_pre = pre;//找到链表的最小值
			min_p = p;
		}
		pre = p;
		p = p->next;
	}
	
	if(min_p != (*L)->next)
	{
		min_pre->next = min_p->next;
		min_p->next = (*L)->next;
		(*L)->next = min_p; 
	}
	
	
//	int i = 0;
//	for(;i < ListLength(*L);i ++)
//	{
//        if(min_p->data == min)
//		{//检索最小值所在节点，并进行移动
//			min_pre->next = min_p->next;//去除原链表中最小值所在节点
//			min_p->next =  r->next;//将最小值结点插入到首元结点
//			r->next = min_p;
//			return ;
//		}
//        min_pre = min_pre->next;
//		min_p = min_p->next;
//	}

}

int SumToNewlist(LinkList *L)

{

//★★★请补全代码
	int sum = 0;
	LNode *p = (*L)->next;
    LNode *tail = NULL;
	while(p)
	{
		sum += p->data;//求和
        if (p->next == NULL) {
            tail = p; // Keep track of the last node
        }
		p = p->next;
	}
    //创建sum节点
	LNode *r ;
	r = (LNode*)malloc(sizeof(LNode));
	r->data = sum;
	r->next = NULL;
    
    //插到尾节点
//	LNode *q = (*L);
//	while(q->next)
//	{
//		q = q->next;
//	}
	tail->next = r;
    
	return 1;
}

 

int main()

{

       int length;

       LinkList L;

       Initlist(&L);

        printf("The original linked list is：");

       ListPrint(L);

       printf("\nThe length of list is：");

       length=ListLength(L);

       printf("%d ",length);

       MoveMin(&L);

       printf("\nAfter moving the minimum, the linked list is: ");

       ListPrint(L);

       printf("\nAfter inserting the sum, the new list is: ");

       SumToNewlist(&L);

       ListPrint(L);

       return 0;

}
```



#### 3. 期中-顺序栈基本操作及应用

```c
//满分	无评语
#include "stdio.h"

#include "stdlib.h"

#define OK 1

#define ERROR 0

#define TRUE 1

#define FALSE 0

#define MAXSIZE  20   //堆栈的最大容量

typedef int Status;

typedef char ElemType;

 

//顺序栈的结构定义

typedef struct

{

         ElemType data[MAXSIZE]; //存放堆栈元素的数组

         int top;                 //top指向栈顶元素，top=-1，表示空栈

} SqStack;

 

//初始化一个空栈

void InitStack(SqStack *S)

{

         S->top = -1;

}

Status Push(SqStack *S, ElemType e)

{

//★★★请补全代码
	if((S->top + 1) > MAXSIZE) return ERROR;
	S->top ++;
	S->data[S->top] = e;


 

 

return OK;

}

 

Status Pop(SqStack *S, ElemType *e)

{

//★★★请补全代码
		if(S->top == -1)	return ERROR;
		*e = S->data[S->top];
		S->top--;
         return OK;

}

 

//如果是空栈，返回1，否则返回0

Status StackEmpty(SqStack S)

{

         return S.top == -1;

}

 

char GetTop(SqStack S, ElemType *e)

{

//★★★请补全代码
	if(S.top == -1)	return ERROR;
	*e = S.data[S.top];
	return *e;
 

    
}

 

int main()

{

         char a[21], b[21];// 增加1以适应gets函数的'\0'结尾

         char temp;

         SqStack Stack;

         InitStack(&Stack);

         printf("Please enter a string with a length no longer than 20:\n");

         gets(a);

        int i = 0;
        char e;
        for(;a[i] != '\0';i ++)
        {
        	if(StackEmpty(Stack) || GetTop(Stack,&e) != a[i])
        	{

        		Push(&Stack,a[i]);
			}
			else 
			{
		   		if(a[i] == a[i + 1])	continue;
				Pop(&Stack,&e);
			}
		}
		int j = 0;
		while(StackEmpty(Stack) == 0)
		{
			Pop(&Stack,&b[j++]);
		}
		printf("The resulting string is: ");
		for(j = j - 1;j >= 0;j --)
		{
			printf("%c",b[j]);
		}

//★★★请补全代码

 

         return 0;

}
```



#### 4. 期中-删除链队列中的重复元素

```c
//第一问：未考虑只有一个元素的情况， 扣0.5分
//第二问：直接操作队列的底层数据， 扣1分
#include <stdio.h>

#include <stdlib.h>

typedef int Status;

#define OK 1

#define ERROR 0

#define OVERFLOW -2



//链队列的存储结构

typedef struct QNode {

     int data;

     struct QNode *next;

} QNode, *QueuePtr;



typedef struct {

     QueuePtr front; //队头指针

     QueuePtr rear; //队尾指针

     int QLength; //队长 

} LinkQueue;



//链队列的初始化

Status InitQueue(LinkQueue *Q) {

     Q->front = Q->rear = (QueuePtr) malloc(sizeof(QNode));

     Q->front->next = NULL;

     Q->QLength = 0; 

     return OK;

}



//插入元素e为链队列Q的新的队尾元素

Status EnQueue(LinkQueue *Q, int e) {

     QueuePtr p;

     p = (QueuePtr) malloc(sizeof(QNode));

     p->data = e;

     p->next = NULL;

     Q->rear->next = p;

     Q->rear = p;

     Q->QLength++;

     return OK;

}

//删除链队列Q的队头元素，用e返回其值
Status DeQueue(LinkQueue *Q, int *e) { 
    // 当队列为空时，头指针应该与尾指针相等
    if (Q->QLength == 0 || Q->front == Q->rear)
        return ERROR;
    
    QueuePtr p = Q->front->next;
    *e = p->data;  
    Q->front->next = p->next;
    if (Q->rear == p) // 如果出队的是最后一个元素，则将尾指针指向头结点
        Q->rear = Q->front;
    free(p);
    Q->QLength--;
    return OK;
}



//返回链队列Q的队头元素，不修改队头指针

int GetHead(LinkQueue Q) 
{
     if ((Q.front != Q.rear) && (Q.QLength != 0))
          return Q.front->next->data;
    return ERROR;
}

//第二问：直接操作队列的底层数据
int main() {

    //请补全代码
    LinkQueue Q;
    InitQueue(&Q);
    
    int n,i;
    scanf("%d",&n);
    int arr[n];
    for(i = 0;i < n;i ++)
    {
    	scanf("%d",&arr[i]); 
    	EnQueue(&Q,arr[i]);
	}
	//if(n == 1)	printf("%d",arr[i]);
	for(i = 0;i < n;i ++)
	{
		int temp;
		DeQueue(&Q,&temp);
		if(Q.rear->data != temp)	EnQueue(&Q,temp);
	}
		
	QueuePtr p = Q.front->next;
	while(p)
	{
		printf("%d ",p->data);
		p = p->next;
	}
    return 0;
}
```



#### 5. 期中-串的堆分配基本操作

```c
//串赋值函数未正确分配正确空间， 扣2分
//插入函数释放后未分配空间， 扣2分
#include <stdio.h>
#include <stdlib.h>


typedef struct{
   char *ch;       //若串非空,则按串长分配存储区,
                   //否则ch为NULL
   int  length;    //串长度
}HString;

typedef int Status;
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0

Status InitString(HString *T) {
	(*T).length=0;
	(*T).ch=NULL;
	return OK;
}


Status ClearString(HString *S){
//将S清为空串
	if((*S).ch) {
		free((*S).ch); 
	}
	(*S).ch = NULL;
	(*S).length=0;
	return OK;
}//ClearString

//串赋值函数未正确分配正确空间
Status StrAssign(HString *T,char *chars){

//*************补全代码*************
	int i = 0;
	T->ch = (char*)malloc(100 *sizeof(char));
//    int len = 0;
//	for(; chars[len] != '\0'; len ++){}	 
//	T->ch = (char*)malloc(len *sizeof(char));
	for(;chars[i] != '\0';i ++)
	{
		(*T).ch[i] = chars[i];
	} 
	(*T).length = i;
	return OK;

}//StrAssign    


int StrLength(HString S){
//返回S的元素个数,称为串的长度
	return S.length;
}//StrLength

int StrCompare(HString S,HString T){
//若S=T,返回值=0;
	
	//*****补全代码********
	int i = 0;
	for(;i < S.length && i < T.length;i++)
	{
		if(S.ch[i] != T.ch[i])	return S.ch[i] - T.ch[i];
	}
	return S.length - T.length;
	

}//StrCompare    

//插入函数释放后未分配空间，
Status StrInsert(HString *S,int pos,HString T){

 //*********补全代码***********
 	int i = 0;
 	if(pos > S->length + 1 || pos < 1)		return ERROR;
 	
 	for(i = S->length;i >= pos;i --)
 	{//将S->ch中第pos位及以后的总计S->length - pos + 1个字符往后移T->length个长度
 		S->ch[i + T.length - 1] = S->ch[i - 1];
	}
	for(i = 0;i < T.length ;i ++)
	{//将S->ch中第pos位及以后总计T->length个字符replace成T->ch中的字符
		S->ch[i + pos - 1] = T.ch[i];
	}
	S->length += T.length; //更新S->length
    S->ch[S->length] = '\0';  // 确保字符串以NULL结尾
	return OK;
    
}//StringInsert    


void StrTravel(HString S)
{
	int i;
	for(i=0;i<S.length;i++)
	{
		printf("%c",S.ch[i]);
	}
	printf("\n");
}

int main()
{
	HString S1,S2,S3;
	InitString(&S1);//初始化串1
	InitString(&S2);//初始化串2
	InitString(&S3);//初始化串3
	char str1[100],str2[100],str3[100];
	scanf("%s",str1);
	scanf("%s",str2);
	scanf("%s",str3);
	StrAssign(&S1,str1);//串1赋值
	StrAssign(&S2,str2);//串2赋值
	StrAssign(&S3,str3);//串3赋值
	int pos;
	scanf("%d",&pos);

	StrTravel(S1);
	StrTravel(S2);
	StrTravel(S3);
	if(StrInsert(&S1,pos,S2)==OK)//串插入
	{
		StrTravel(S1);//串打印输出
	}
	else
	{
		printf("insert fail\n");
	}
	int cmp = StrCompare(S1,S3);
	if(cmp == 0)
		printf("equal\n");
	else
		printf("not equal\n");
	ClearString(&S1);
	ClearString(&S2);
	ClearString(&S3);
	return 0;
}

```



#### 6. 期中-逆波兰表达式求值

```c
//过于繁琐， 扣1分
#include<stdio.h>
#include<malloc.h>

#define OK 1
#define ERROR 0

typedef int SElemType;

typedef int Status;

typedef struct Lnode{
	SElemType data;
	struct Lnode *next;
	
}LNode,*LinkList;

typedef struct{
	LinkList Head;
	int length;
	
}LinkStack;

Status InitLinkStack(LinkStack *S)
{
	S->Head = (LinkList)malloc(sizeof(LNode));
	if(!S->Head)
		return ERROR;
	
	S->Head->next = NULL;
	S->length = 0;
	
	return OK;
} 


Status StackEmpty(LinkStack S)
{

	return (S.Head->next == NULL);
	
}

Status Push(LinkStack *S, SElemType e)
{
	LinkList p;
	
	p = (LinkList)malloc(sizeof(LNode));
	if(!p)
		return ERROR;
	
	p->data = e;
	p->next = S->Head->next;
	S->Head->next = p;
	S->length++;
	
	return OK;
	
}

Status GetTop(LinkStack S, SElemType *e)
{
	if(!S.Head->next )
		return ERROR;
	
	*e = S.Head->next->data;
	
	return OK;
	
}

Status Pop(LinkStack *S, SElemType *e)
{
	
	LinkList p;
	
	p = S->Head->next;
	
	if(!p)
		return ERROR;

	*e = p->data;
	
	S->Head->next = p->next;
	free(p);
	
	S->length--;
	
	return OK;
	
}

int StackLength(LinkStack S)
{
	return S.length;
	
}

/* 四则运算函数定义：
  * 输入参数：操作数n1,n2,运算符op,运算结果指针out；
  * 处理规则及返回值：计算n1 op n2的结果，并将结果赋给*out；
  *                如果出现除零，返回ERROR，否则返回OK；*/
 Status Operate(int n1,char op,int n2,int *out){
     switch (op) {
         case '+':
             *out = n1 + n2;
             return OK;
         case '-':
             *out = n1 - n2;
             return OK;
         case '*':
             *out = n1 * n2;
             return OK;
         case '/':
             if(n2 == 0)
                 return ERROR;
             else{
                 *out = n1 / n2;
                 return OK;
             }
     }
 }
 
 /* 逆波兰表达式计算函数定义：
  * 输入参数：表达式字符串指针s,运算结果指针res；
  * 处理规则及返回值：计算表达式*s的值，并将结果赋给*out；
  *               如果出现逆波兰表达式错误，返回ERROR，否则返回OK；*/
Status calculate_RP(char *s, int *res){

  //=============================
  //请补充完整
  //=============================
	  int i = 0,n1,n2;
	  LinkStack S;
	  InitLinkStack(&S);
	  for(;s[i] != '\0';i ++)
	  {
	  	if (s[i] >= '0' && s[i] <= '9') 
        {//两位及以上的数字字符（数字中间没有空格）转化为10进制数
            int num = 0;
            while (s[i] >= '0' && s[i] <= '9') 
            {
                num = num * 10 + (s[i] - '0');
                i++;
            }
            Push(&S,num);
        }
		else if(s[i] != ' ')//细节：输入进栈的时候，是有空格号的，这个不要忘了
		{
			if(Pop(&S,&n1) == ERROR)	return ERROR;
			if(Pop(&S,&n2) == ERROR)	return ERROR;
			if(Operate(n2,s[i],n1,res) == ERROR)	return ERROR;
			Push(&S,*res);
		}	
	   } 
	   if(S.length != 1)	return ERROR;
	return OK;
}

int main() {
    int result = 0;
    char notation[100];
    gets(notation);
    //puts(notation);
    //计算逆波兰表达式的值
    if(calculate_RP(notation,&result)){
        printf("%d\n",result);
    }
    else{
        printf("Wrong notation!\n");
    }

    return 0;
}

```



#### 7. 期中-2024年春晚扑克牌游戏模拟

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define OK 1
#define ERROR 0
#define OVERFLOW -1
typedef int Status;

// 定义扑克牌结构

typedef struct {
    char suit[10];   //花色： "Hearts", "Diamonds", "Clubs", "Spades"
    char face[10];   //面值： "Ace", "2", "3", "4", "5", "6", "7", "8", "9", "10", "Jack", "Queen", "King" 
} Card, QElemType, SElemType;


typedef struct Lnode{
	SElemType data;
	struct Lnode *next;
	
}LNode,*LinkList;

typedef struct{
	LinkList Head;
	int length;
	
}LinkStack;

Status InitLinkStack(LinkStack *S)
{
	S->Head = (LinkList)malloc(sizeof(LNode));
	if(!S->Head)
		return ERROR;
	
	S->Head->next = NULL;
	S->length = 0;
	
	return OK;
} 


Status StackEmpty(LinkStack S)
{
	return (S.Head->next == NULL);
	
}

Status Push(LinkStack *S, SElemType e)
{
	LinkList p;
	
	p = (LinkList)malloc(sizeof(LNode));
	if(!p)
		return ERROR;
	
	p->data = e;
	p->next = S->Head->next;
	S->Head->next = p;
	S->length++;
	
	return OK;
	
}

Status GetTop(LinkStack S, SElemType *e)
{
	if(!S.Head->next )
		return ERROR;
	
	*e = S.Head->next->data;
	
	return OK;
	
}

Status Pop(LinkStack *S, SElemType *e)
{
	
	LinkList p;
	
	p = S->Head->next;
	
	if(!p)
		return ERROR;

	*e = p->data;
	
	S->Head->next = p->next;
	free(p);
	
	S->length--;
	
	return OK;
	
}

int StackLength(LinkStack S)
{
	return S.length;
	
}


#define MAXQSIZE  10   //最大队列长度
typedef struct {
   QElemType *base;   //初始化的动态分配存储空间
   int  front;                    //头指针   
   int  rear;                     //尾指针
}SqQueue;  


char suits[4][10] = {"Hearts", "Diamonds", "Clubs", "Spades"};
char faces[13][10] = {"Ace", "2", "3", "4", "5", "6", "7", "8", "9", "10", "Jack", "Queen", "King"};

Status InitQueue (SqQueue *Q){
   //构造一个空队列Q
   Q->base=(QElemType *) malloc(MAXQSIZE *sizeof(QElemType)); 
   if(!Q->base) return ERROR;
   Q->front=Q->rear=0;
   return OK;
}//InitQueue

Status QueueEmpty (SqQueue Q){
    return (Q.front==Q.rear);                             
}// QueueEmpty

Status EnQueue(SqQueue *Q,QElemType e){
    if((Q->rear+1)%MAXQSIZE==Q->front)  return ERROR;//队列满
    Q->base[Q->rear]=e;
    Q->rear=(Q->rear+1)%MAXQSIZE;
     return OK;
}//EnQueue

Status DeQueue (SqQueue *Q,QElemType *e){
   if(Q->front==Q->rear) return ERROR;
   *e=Q->base[Q->front];
   Q->front=(Q->front+1)%MAXQSIZE;
   return OK;
}//DeQueue

Status QueueTraverse(SqQueue Q,void(*vi)(QElemType))
{ /* 从队头到队尾依次对队列Q中每个元素调用函数vi().一旦vi失败,则操作失败 */
   int i;
   i=Q.front;
   while(i!=Q.rear)
   {
     vi(*(Q.base+i));
     i=(i+1)%MAXQSIZE;
   }
   printf("\n");
   return OK;
}

/* prepare card */
void prepare_card(LinkStack *S, char suit, int face)
{
  
//***补全代码****  
	if(face > 13 || face < 1 || suit != 'H' || suit != 'D' || suit != 'C' || suit != 'S' )
	{
		printf("Illegal suit input");
		exit(-1);
		 }	 
	
  
  
}
/* expand cards */
void expand_card(SqQueue *Q)
{

//***补全代码****


}
/* shuffle cards */
void shuffle_card(SqQueue *Q, int num){

    int i;
    QElemType e;
    for(i=0; i<num; i++){
        DeQueue(Q, &e);
        EnQueue(Q, e);
    }

}

/* insert first k cards into bottom after pos  */
void insert_card(SqQueue *Q, int k, int pos)
{

//***补全代码****


}


// print card
void printCard(Card card) {
    if(card.face[1]=='0')
        printf("[%c-%c%c]", card.suit[0], card.face[0], card.face[1]);
    else
        printf("[%c-%c]", card.suit[0], card.face[0]);
}

int main() {
    int i;
    char suit;  /* 存储扑克花色的首字母  */
    int face;  /* 存储扑克牌的分值, 分值为1~13 */
    int pos; /* 存储第3步插入那张牌后面 */
    int name; /* 名字字数 */
    int gender;  /* 存储扔掉牌数量：男生1 或女生 2 */
    Card card, secret;

    SqQueue Q; /* 存储扑克牌堆 */
    LinkStack S;
    InitQueue(&Q);
    InitLinkStack(&S);
/* 1. 拿出4张扑克牌并随意打乱顺序； */
/* 根据输入的数字和花色抽取4张牌，完成第1步 */
    // printf("Please input 4 card suit and face (example: H-3):\n");
    for(i=0; i<4; i++) {
        /* 顺序输入4章扑克牌的花色和分值和，花色在后;分值在前 */
        scanf("%c-%d", &suit, &face);
        getchar();
        prepare_card(&S, suit, face);
    }

    for(i=0; i<4; i++){
        Pop(&S, &card);
        EnQueue(&Q, card);
    }
    printf("After 1-step process:\n");
    QueueTraverse(Q, printCard);
/* 2. 撕开扑克牌重叠放在一起； */    
    expand_card(&Q);
    printf("After 2-step process:\n");
    QueueTraverse(Q, printCard);

/* 3.根据名字字数循环扑克n次；*/
    // printf("Please input the length of your name: ");
    scanf("%d", &name);
    shuffle_card(&Q, name);
    printf("After 3-step process:\n");
    QueueTraverse(Q, printCard);
/* 4. 将最上面的3张扑克牌随机插入下面的扑克牌中间； */
    // printf("Please input the 1-st insert position(3<k<n): ");
    scanf("%d", &pos);
    insert_card(&Q, 3, pos);
    printf("After 4-step process:\n");
    QueueTraverse(Q, printCard);
/* 5.将最上面的扑克牌最为谜底保存起来； */ 
    DeQueue(&Q, &secret);
    printf("After 5-step process:\n");
    QueueTraverse(Q, printCard);
/* 6.将最上面的3张扑克牌随机插入下面的扑克牌中间； */    
    // printf("Please input the 2nd insert position(3<k<n): ");
    scanf("%d", &pos);
    insert_card(&Q, 3, pos);
    printf("After 6-step process:\n");
    QueueTraverse(Q, printCard);
/* 7. 根据男生或者女生，将最上面的扑克牌扔出去1张或者2张； */
    // printf("Please input your gender(male:1, fename:2): ");
    scanf("%d", &gender);
    DeQueue(&Q, &card);
    if(gender==2)
        DeQueue(&Q, &card);
    printf("After 7-step process:\n");
    QueueTraverse(Q, printCard);
/* 8. “见证奇迹的时刻”，将扑克牌循环7次 */
    shuffle_card(&Q, 7);
    printf("After 8-step process:\n");
    QueueTraverse(Q, printCard);
/* 9. “好运留下来，烦恼丢出去”，循环一次丢弃一次 */
    while((Q.rear-Q.front+MAXQSIZE)%MAXQSIZE != 1){
        shuffle_card(&Q, 1);
        DeQueue(&Q, &card);
        // QueueTraverse(Q, printCard);
    }

    DeQueue(&Q, &card);
    printf("Final 9-step process:\n");
    printCard(card);
    printf("\n");
    printf("Secrete card:\n");
    printCard(secret);
    printf("\n");
    return 0;
}


```



### 2024期末复习题

#### 1. 2023-04班-期末复习题-递归练习-求和

```c
#include <stdio.h>
//===============================
// Calculate the sum of array in recursive way
//===============================
int GetSum_R(int a[], int n)
{
	if(n == 0)	return 0;
	return a[n - 1] + GetSum_R(a, n - 1); 
}
int main()
{
	int A[] = {1,2,3,4,5,6,7,8,9,10};
	int sum;
	
	sum = GetSum_R(A, sizeof(A)/sizeof(int));
	
	printf("the sum of array A: %d\n", sum);
	return 0;
}


```



#### 2. 2023-期末复习-递归-求最大值

```c
#include <stdio.h>
//===========================================
// Get the Max Data in A[] in recursive manner
//============================================
int GetMax_R(int A[], int n)
{
	if(n <= 0)	return 0; 
	else if(n == 1 || A[n - 1] > GetMax_R(A, n - 1))	return A[n - 1];
	else return GetMax_R(A, n - 1);
}

int main()
{
	int A[] = { 1,8,6,-4,3,9,10,12,56,45,23 };
	int max;
	
	max = GetMax_R(A, sizeof(A)/sizeof(A[0]));
	
	printf("the max of array A is : %d\n", max);
	
	return 0;

}
```



#### 3. 2023-期末复习-顺序表-真题（2）

```c
#include <stdio.h>
#include <stdlib.h>
#define List_init_size 1000
typedef int Element;
typedef int Status;
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0

typedef struct
{
    Element *elem; 
    int length;
    int listsize;
}Sqlist;

//初始化初始化顺序表
int Initlist(Sqlist *L)
{
    L->elem=(Element *)malloc(List_init_size*sizeof(Element));
    if(!L->elem) return ERROR;
    L->length=0;
	L->listsize=List_init_size;
    return OK;
}


//创建长度为m的顺序表
void Createlist(Sqlist *L, int n)//输入函数
{
    int i;
    for(i=0; i<n; i++)
    {
        scanf("%d",&L->elem[i]);
    }
    L->length=n;
}

//将元素e插入到第k个元素之前
Status Listinsert(Sqlist *L, int k, int e)
{
    if(k<1||k>L->length+1) return ERROR; //判断插入位置的合法性
    int j;
    int pos=k;

    for(j=L->length-1;j>=pos-1;j--)
    {//从最后一个位置开始移位，将需要插入的位置空出
        L->elem[j+1]=L->elem[j];
    }
    L->elem[pos-1]=e;
    L->length++;//每插入一个元素，顺序表长度加一，勿忘
    return OK;
}


//打印顺序表的元素
void Display(Sqlist *L)
{
//★★★请补全代码
	int  i;
	for(i = 0; i < L->length ;i ++)
	{
		printf("%d ", L->elem[i]);
	}

}

//判断在顺序表中是否存在某元素（存在返回值TRUE；不存在返回值FALSE）
Status isPresent(Sqlist L, int e)
{

//★★★请补全代码
	int i;
	for(i = 0; i < L.length; i ++)
	{
		if(L.elem[i] == e)	return 1;
	 } 
	 return 0;

}

//取顺序表的第i个元素
Status GetElem(Sqlist L,int i,Element *e)
{
  if(i<1 || i>=L.length)
      return ERROR;
    *e=L.elem[i-1];
    return OK;
}


//求L1与L2的交集，将结果放入L3
void InterSection(Sqlist *L1, Sqlist *L2, Sqlist *L3)
{
//★★★请补全代码
	int len1 = 0;
	int len2 = 0;
	int len3 = 0;
	for(; len1 < L1->length && len2 < L2->length ; )
	{
		if(L1->elem[len1] == L2->elem[len2])
		{
			Listinsert(L3, ++len3, L1->elem[len1]);
			len1 ++; len2++;
		}
		else if(L1->elem[len1] > L2->elem[len2])	len2 ++;
		else if(L1->elem[len1] < L2->elem[len2])	len1 ++;
	}
//	L3->length = len3;
}


int main()
{
    int m,n;
    Sqlist A,B,C;
    printf("请依次输入表A和表B中的元素个数\n");
    scanf("%d %d",&m,&n);
    Initlist(&A);
    Initlist(&B);
    Initlist(&C);
    printf("请依次输入表A中的元素\n");
    Createlist(&A,m);
    printf("请依次输入表B中的元素\n");
    Createlist(&B,n);
    InterSection(&A,&B,&C);
    printf("表A和表B的交集为\n");
    Display(&C);
    return 0;

}
```



#### 4. 2023-04班-期末复习题-顺序表-定长

```c
//编写FindElement函数

#include <stdio.h>


//============================================================
//
// Find an element is an array.
// the total number to elements is stored in A[0]
//
// If the element is found, return i( 1<i<n ), otherwise return 0
//============================================================


int FindElement(int A[], int n, int x)
{
	int i = 0;
	for(i = 1; i <= n ;i ++)
	{
		if(A[i] == x)	return i;
	 } 
	 return 0;
}

int main()
{
	int A[] = {9, 1, 3, 5, 8, 9, 5, 7, 10, 12 }; //A[0] stores the total number of elements
	int e;
	int RetVal;
	
	
	scanf("%d", &e);
	RetVal=FindElement(A, A[0], e);
	
	if(RetVal)
		printf("The position of the element is %d\n", RetVal);
	else
		printf("The element doesn't exist in the array!\n");
		
	return 0;
}
```



#### 5. 2023-期末复习-单链表-真题1

```c
#include "stdio.h"
#include "malloc.h"
#include "stdlib.h"

#define ERROR -1
#define OK 1

typedef struct Lnode
{
	int data;
	struct Lnode *next;
}LNode,*LinkList;

/***************链表初始化**********************/
int Initlist(LinkList *L)
{
    (*L)=(LinkList)malloc(sizeof(LNode));
    if(L==NULL)
    {
  		printf("内存创建失败\n");
   		return ERROR;
    }
    (*L)->next=NULL;
    //根据键盘值构造链表
	LinkList r;
	r=*L;
	int x;
	int i;
	for(i=0; ; i++)
	{
		scanf("%d",&x);
		if(x==-1)
			break;
		LNode *p=(LinkList)malloc(sizeof(LNode));
		if(!p)
		{
			printf("初始化失败");
		    return ERROR;
		}
		p->data=x;
		p->next= NULL;
		r->next=p;
		r=p;
	}
	return OK;
}
/******************打印单链表*****************/
void ListPrint(LinkList L)
{
//★★★请补全代码
	LinkList p = L->next;
	while(p)
	{
		printf("%d ",p->data);
		p = p->next;
	}
	printf("\n");

}
/****************求单链表的长度******************/
int ListLength(LinkList L)
{
//★★★请补全代码
	int total = 0;
	LinkList p = L->next;
	while(p)
	{
		total ++;
		p = p->next;
	}
	return total;

}

/*********元素交换*********************/
int Exchange(LinkList *L)
{
//★★★请补全代码
	int ex = (ListLength(*L) + 1) / 2;
	int i = 1;//因为后面p直接是首元结点，故此处用i = 1
	LinkList p = (*L)->next;
	LinkList r = (*L)->next;
	LinkList p_pre = *L;
	while(p && i < ex)
	{
		p_pre = p;
		p = p->next;
		i ++;
	}
	LinkList temp = (*L)->next->next;//要记录下这个结点位置，在后面先转移r的时候链表断了，不能再寻找到第二个结点位置
	r->next = p->next;
	p_pre->next = r;
	
	p->next = temp;
	(*L)->next = p;
	return 1;

}

/************主函数******************/
int main()
{
	int length;
	LinkList L;
	Initlist(&L);
	ListPrint(L);
	length=ListLength(L);
	printf("%d\n",length);
	Exchange(&L);
	ListPrint(L);
	return 0;
}
```



#### 6. 2023-期末复习题-单链表-求长度和最大值

```c
//编写ListLength_L和GetMax函数

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0
typedef int ElemType;
typedef int Status;

// definition of node structure of singly linked list
typedef struct L_node
{
ElemType data;          // data field
struct L_node *next;    // pointer field
}LNode, *LinkList;

//===========================================
// Create a singly linked list L with head node, and with n elements
//===========================================
Status CreateList_L(LinkList *L, int n)
{
	LinkList head,p, q;
	int i;
	
	p = (LinkList)malloc(sizeof(LNode)); //create an empty list
	if (!p) return ERROR;
	p->next = NULL;
	head = p;
	for (i = 0; i < n; i++)
	{
		q = (LinkList)malloc(sizeof(LNode));    //make a new node
		if (!q) return ERROR;
		scanf("%d", &q->data);                    //enter element data from keyboard
		
		q->next = NULL;
		p->next = q;
		p = q;
	}
	*L=head;
	return OK;
}

//======================================
//Print all elements of the linked list
//=======================================
void LinkedListPrint(LinkList L)
{
	LinkList p = L->next;
	while(p)
	{
		printf("%d ",p->data);
		p=p->next;
	}
}

//=========================================
// Get the length of the list
//=========================================
int ListLength_L(LinkList L)
{
	LinkList p = L->next;
	int total = 0;
	while(p)
	{
		p = p->next;
		total ++;
	 } 
	 return total;
}

//=========================================
//Find the maximum node and return the value
//the pointer of the Maxnode is returned by p.
//=========================================
int GetMax(LinkList L, LinkList *pMax)
{
	LinkList p = L->next->next;
	*pMax = L->next;
	while(p)
	{
		if(p->data > (*pMax)->data)	*pMax = p;
		p = p->next;
	}
	return (*pMax)->data;
}

int main()
{

	LinkList LA;
	int len;
	
	// Create a singly linked list with elements of 21, 18, 30, 75, 42, 56
	
	CreateList_L(&LA, 6);
	
	// print out the linked list
	LinkedListPrint(LA);
	
	// get the length
	len = ListLength_L(LA);
	printf("the length of the list is %d\n", len);
	
	//get the maxmum value
	int maxVal;
	LinkList pMaxNode; // pointer of the Maxnode;
	
	maxVal = GetMax(LA, &pMaxNode);
	printf("the maximum value is %d\n", maxVal);

	return 0;
}


```



#### 7. 2023-期末复习-栈-真题（3）

```c
#include "stdio.h"
#include "stdlib.h"
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE  100  //堆栈的最大容量
typedef int Status;
typedef int ElemType;

//顺序栈的结构定义
typedef struct
{
    ElemType data[MAXSIZE]; //存放堆栈元素的数组
    int top;                //top指向栈顶元素，top=-1，表示空栈
}SqStack;

//初始化一个空栈
void InitStack(SqStack *S)
{
    S->top=-1;
}
Status Push(SqStack *S, ElemType e)
{
    if(S->top == MAXSIZE -1)
    {
        return ERROR;
    }
    S->top++;
    S->data[S->top]=e;
    return OK;
}

Status Pop(SqStack *S, ElemType *e)
{
//★★★请补全代码
	if(S->top == -1)	return ERROR;
	*e = S->data[S->top--];
	return OK;

}

//如果是空栈，返回1，否则返回0
Status StackEmpty(SqStack S)
{
//★★★请补全代码
	return S.top == -1 ? 1 : 0;
	

}


int main()
{
    SqStack Stack;
    ElemType temp;
    InitStack(&Stack);
	printf("请输入一个要入栈的元素(-1表示结束):\n");
	scanf("%d",&temp);
	while(temp!=-1)
	{
		Push(&Stack,temp);
		scanf("%d",&temp);
	}

	printf("对栈内元素依次进行出栈操作:\n");

    while (!StackEmpty(Stack))
    {
        if (OK==Pop(&Stack, &temp))
        {
            printf("%d ",temp);
        }
    }
    return 0; 
}
```



#### 8. 2023-04班-期末复习题-顺序栈-基本操作-第一种定义方式

```c
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include<string.h>

#define TRUE  1
#define FALSE  0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
typedef char SElemType;

#define STACK_INIT_SIZE  100        //Initial size for memory allocation
#define STACKINCREMENT  10          //incremental size

typedef struct SqStack
{
	SElemType  *base;    //base pointer
	SElemType  *top;      //top pointer
	int        stacksize;    //current size
}SqStack;

//==================================================
// Initialize a stack
//====================================================
Status InitStack(SqStack *S)
{
	S->base = (SElemType *)malloc(STACK_INIT_SIZE*sizeof(SElemType));
	if (!S->base) return ERROR;
	S->top = S->base;
	S->stacksize = STACK_INIT_SIZE;
	return OK;
}

//=================================
//Get the element at the top end
//==================================
Status GetTop(SqStack S, SElemType *e)
{
	if(S.top == S.base)	return ERROR;
	*e = *S.top;
	return OK; 
}

//==================================
//delete the element at the top end
//=====================================
Status Pop(SqStack *S, SElemType *e)
{
	if(S->base == S->top)	return ERROR;
	*e = *(S->top);
	S->top--;
	return OK;
}
//==================================
//Insert an element
//=================================
Status Push(SqStack *S, SElemType e)
{
	if(S->top - S->base >= S->stacksize)	return ERROR;
	*(++S->top) = e;
	return OK;
}

void main()
{
	char str[1024];
	int i;
	char e;
	SqStack S;
	InitStack(&S);
	printf("please input a string inlcuding (  )  [  ]  {  }\n");
	scanf("%s", str);
	   
	printf("the input string is %s\n", str);
	
	for (i = 0; str[i] != '\0'; i++)
	{
		Push(&S, str[i]);
		GetTop(S,&e);
		printf("the top element of the stack is %c\n",e);
	}
	
	for (i = 0; str[i] != '\0'; i++)
	{
		Pop(&S,&e);
		printf("the element of the stack pop is %c\n",e);
	}

}
```



#### 9. 2023-04班-期末复习题-链栈操作-带头结点

```c
// LZHead.cpp : Defines the entry point for the console application.
//

#include<stdio.h>
#include<stdlib.h>
typedef struct Stack
{
	int data;
	struct Stack* next;
}ListStack;

//init_Stack
ListStack* init_Stack(ListStack *head)
{
	ListStack*p = (ListStack*)malloc(sizeof(ListStack));
	p->data = -1;
	p->next = NULL;
	return p;
}

//push_Stack
ListStack* push_Stack(ListStack *head, int x)
{
	
 	ListStack *r = init_Stack(head);
	r->data = x;
	r->next = head->next;
	head->next = r;
	return head;		
}

//pop_Stack
int pop_Stack(ListStack *head, int *d)
{
	if(!head->next)	return 0;
	
	ListStack *r = (*head).next ;	
	*d = r->data;
	head->next = r->next;
	free(r);
	return 1;
}

int stack_Top(ListStack *head, int *num)
{
	if(!head->next)	return 0;
	*num = head->next->data;
	return 1;
}

int count_stack(ListStack *head)
{
    int total = 0;
    ListStack *p = head->next;
    while (p != NULL)
    {
        total++;
        p = p->next;
    }
    return total;
}
//text 
int main()
{
	struct Stack *head;
	int n, num = -1, length, i;
	head = NULL;
	head = init_Stack(head);//初始化 
	/*入栈*/
	head = push_Stack(head, 35);
	head = push_Stack(head, 45);
	head = push_Stack(head, 55);
	head = push_Stack(head, 65);
	head = push_Stack(head, 75);
	head = push_Stack(head, 85);
	stack_Top(head, &n);
	    printf("栈顶元素为：%d\n",n);
	length = count_stack(head);
	for (i = 0; i < length; i++)
	{
		pop_Stack(head, &num);
		printf("出栈元素为：%d\n",num);
	}
	return 0;
}
```



#### 10. 2023-期末复习-链栈-真题（4）

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 100

typedef int Status;
typedef int SElemType;


//定义链栈结构
typedef struct StackNode
{
	SElemType data;
	struct StackNode *next;
}StackNode,*LinkStack;

//初始化链栈
Status InitStack(LinkStack *S)
{
	LinkStack Head=(LinkStack)malloc(sizeof(StackNode));
	if(!Head)	return ERROR; 
	Head->next=NULL;
	(*S)=Head;
	return OK;
}

//判断链栈是否为空，是则返回TRUE，不是则返回FALSE
Status StackEmpty(LinkStack S)
{
	if (NULL==S->next)
		return TRUE;
	else
		return FALSE;
}

//将元素e入栈
Status Push(LinkStack *S, SElemType e)
{   
	StackNode *top=(*S)->next;
	StackNode *temp;
	temp = (LinkStack)malloc(sizeof(StackNode));
	temp->data = e;
	temp->next=(*S)->next;
	(*S)->next=temp;
	return OK;
}

//弹出栈顶元素，赋值给e
Status GetTop(LinkStack S, SElemType *e)
{
	if (StackEmpty(S)==TRUE)
		return ERROR;
	*e = S->next->data;
	return OK;
}

//出栈，出栈元素赋值给e
Status Pop(LinkStack *S, SElemType *e)
{
	StackNode *top=(*S)->next;
	if (StackEmpty(*S)==TRUE)
		return ERROR;
	*e = top->data;
	(*S)->next = top->next;
	free(top);
	return OK;
}

int main()
{
	LinkStack S;
//	int n=0;  //通过整数n统计相同数的个数，若相同，则每次进栈后n+1
	InitStack(&S);  //初始化栈
	
	//★★★请补全代码
	
	while(1)
	{
		int a = 0;
		scanf("%d", &a);
		if(a == -1)	break;
		Push(&S, a);
	 }
	 int e = -1, e_pre = -1;
	 while(!StackEmpty(S)) 
	 {
	 	Pop(&S, &e);
	 	GetTop(S, &e_pre);
	 	if(e != e_pre || StackEmpty(S))	
	 	{
	 		printf("%d ", e);
		}
		else
		{
			while(!StackEmpty(S) && e == e_pre)
			{
				Pop(&S, &e);
				if(!StackEmpty(S))	GetTop(S, &e);
			}
//			if(e != e_pre) Push(&S, e);
		}
	 }
	
	return 0;

}
```



#### 11. 2023-04班-期末复习题-链队-基本操作

```c
#include "malloc.h"
#include "stdio.h"
#include "stdlib.h"


typedef int QElement;

//结点类型定义
typedef struct Node
{
    int value;
    struct Node *next;
}QueueNode;

typedef struct Queue
{
    QueueNode *front;//设置队头
    QueueNode *rear;//设置队尾
}Queue;

void InitQueue(Queue *q)
{
    q->front = (QueueNode*)malloc(sizeof(Queue));
    if (NULL == q->front)
    {
        printf("malloc free failed!\n ");
        return;
    }
    q->rear = q->front;
    q->front->next= NULL;//使用带有头节点指针的链队列
}

void EnterQueue(Queue *q, QElement x)
{
	QueueNode *temp = (QueueNode*)malloc(sizeof(QueueNode));
	if(!temp)	
	{
        printf("malloc free failed!\n ");
        return;
    }
	temp->value = x;
	q->rear->next = temp;
	q->rear = q->rear->next; 
}

void DeQueue(Queue *q,QElement *x)
{
	if(q->front == q->rear)	return ;
	*x = q->front->next->value;
	QueueNode* temp = (QueueNode*)malloc(sizeof(QueueNode));
	if(!temp)	
	{
        printf("malloc free failed!\n ");
        return;
    }
	temp = q->front;
	q->front = temp->next;
	free(temp); 
}

void GetQueueHead(Queue *q,QElement *x)
{
	if(q->front == q->rear)	return ;
	*x = q->front->next->value;
}

/*
这里队列头指针的意思是：
假设这队里有1 2 3
q->rear 指向 3， q->rear->next 指向 NULL
q->front 指向 NULL，q->front->next 指向的是 1。 因为q->front包含了头指针。再不出对的情况下，头指针不会变还是指向NULL
故出队时候的取元素是：	*x = q->front->next->value;
*/

int main(void)
{
    Queue q;
	int QueueHead;
	int DequeValue;
    InitQueue(&q);
    EnterQueue(&q, 1);
	EnterQueue(&q, 2);
	EnterQueue(&q, 3);
	GetQueueHead(&q,&QueueHead);
	printf("队头元素为：%d\n",QueueHead);
	DeQueue(&q,&DequeValue);
	printf("出队元素为：%d\n",DequeValue);

    return 0;
}
```



#### 12. 2023-期末复习-循环队列-真题（5）

```c

#include<stdio.h>
#include<stdlib.h>

#define OK    1
#define ERROR 0
#define TRUE  1
#define FALSE 0
#define MAXSIZE 6

typedef  int  Elemtype;
typedef  int  Status;

typedef  struct {
	Elemtype *base;
	int front;
	int rear;
}SqQueue;

/*
这队就没有头指针了，所以Q->front 和 Q->rear 起初都是指向0，在0~Q->rear（包括端点）都有数据存储
*/

void InitQueue(SqQueue *Q)
{
	Q->base=(Elemtype*)malloc(sizeof(Elemtype)*MAXSIZE);
	if(Q->base==NULL)
		return ;
	Q->front=Q->rear=0;
}

Status EnQueue(SqQueue *Q,Elemtype e)
{
//学生添加的程序
	if(Q->rear - Q->front == MAXSIZE + 1)
		return ERROR;
	Q->base[Q->rear ++] = e; 
	return OK;
}

Status DeQueue(SqQueue *Q,Elemtype *e)
{
//学生添加的程序
	if(Q->rear - Q->front == 0)
		return ERROR;
	*e = Q->base[Q->front ++];
	return OK;
}

Status QueueEmpty(SqQueue *Q)
{
	if(Q->rear==Q->front)
	{
		return TRUE;
	}
	return FALSE;
}

Status QueueLength(SqQueue *Q)
{
	return (Q->rear-Q->front+MAXSIZE)%MAXSIZE;
}

Status GetHead(SqQueue *Q,Elemtype *e)
{
	if(Q->rear==Q->front)
	{
		return ERROR;
	}
	*e=Q->base[Q->front];
	return OK;
}

void ClearQueue(SqQueue *Q)
{
	Q->front=Q->rear=0;
}

void DestoryQueue(SqQueue *Q)
{
	if(Q->base)
	{
		free(Q->base);
	}
	Q->base=0;
	Q->front=Q->rear=0;
}

void QueueTraverse(SqQueue *Q,void(*visit)(Elemtype))
{
	int i=Q->front;
	while(i!=Q->rear)
	{
		visit(Q->base[i]);
		i=(i+1)%MAXSIZE;
	}
	printf("\n");
}

void Print(Elemtype e)
{
	printf("%d ",e);
}

int main()
{
	int i,k;
	Elemtype d,e;
	SqQueue Q;
	InitQueue(&Q);
	printf("请输入%d个队列元素:\n",MAXSIZE-1);
	for(i=1;i<MAXSIZE;i++)
	{
		scanf("%d",&d);
		EnQueue(&Q,d);
	}
	printf("队列元素为:");
	QueueTraverse(&Q,Print);
	printf("队列长度为%d\n",QueueLength(&Q));
	
	k=QueueLength(&Q);
	for(i=0;i<k;i++)
	{
		DeQueue(&Q,&e);
		printf("删除的队列的元素是：%d\n",e);
	}
	return 0;
}
```



#### 13. 2023-期末复习-图的遍历-广度优先搜索遍历连通图-邻接矩阵法

```c
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */


#include "stdio.h"    

#include "stdlib.h"   


#include "math.h"  

#include "time.h"


#define OK 1

#define ERROR 0

#define TRUE 1

#define FALSE 0


typedef int Status;/* Status是函数的类型,其值是函数结果状态代码，如OK等 */

typedef int Boolean; /* Boolean是布尔类型,其值是TRUE或FALSE */


typedef char VertexType; /* 顶点类型 */

typedef int EdgeType; /* 边上的权值类型 */


#define MAXSIZE 9 /* 存储空间初始分配量 */

#define MAXEDGE 15

#define MAXVEX 9


typedef struct

{

	VertexType vexs[MAXVEX]; /* 顶点表 */
	
	EdgeType arc[MAXVEX][MAXVEX];/* 邻接矩阵，可看作边表 */
	
	int numVertexes, numEdges; /* 图中当前的顶点数和边数 */

}MGraph;


/* 用到的队列结构与函数********************************** */


/* 循环队列的顺序存储结构 */

typedef struct

{

	int data[MAXSIZE];
	
	int front;    	/* 头指针 */
	
	int rear;/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */

}Queue;


/* 初始化一个空队列Q */

Status InitQueue(Queue* Q)

{

	Q->front = 0;

	Q->rear = 0;

	return  OK;

}


/* 若队列Q为空队列,则返回TRUE,否则返回FALSE */

Status QueueEmpty(Queue Q)

{

	if (Q.front == Q.rear) /* 队列空的标志 */
	
		return TRUE;
	
	else
	
		return FALSE;

}


/* 若队列未满，则插入元素e为Q新的队尾元素 */

Status EnQueue(Queue* Q, char e)

{

	if ((Q->rear + 1) % MAXSIZE == Q->front)/* 队列满的判断 */

		return ERROR;

	Q->data[Q->rear] = e;/* 将元素e赋值给队尾 */

	Q->rear = (Q->rear + 1) % MAXSIZE;/* rear指针向后移一位置， */

/* 若到最后则转到数组头部 */

	return  OK;

}


/* 若队列不空，则删除Q中队头元素，用e返回其值 */

Status DeQueue(Queue* Q, char* e)

{

	if (Q->front == Q->rear)/* 队列空的判断 */
	
		return ERROR;
	
	*e = Q->data[Q->front];/* 将队头元素赋值给e */
	
	Q->front = (Q->front + 1) % MAXSIZE;/* front指针向后移一位置， */
	
	/* 若到最后则转到数组头部 */
	
	return  OK;

}

/* ****************************************************** */



void CreateMGraph(MGraph* G)

{

	int i, j;


	G->numEdges = 15;

	G->numVertexes = 9;


/* 读入顶点信息，建立顶点表 */

	G->vexs[0] = 'A';

	G->vexs[1] = 'B';

	G->vexs[2] = 'C';

	G->vexs[3] = 'D';

	G->vexs[4] = 'E';

	G->vexs[5] = 'F';

	G->vexs[6] = 'G';

	G->vexs[7] = 'H';

	G->vexs[8] = 'I';



	for (i = 0; i < G->numVertexes; i++)/* 初始化图 */
	
	{
	
		for (j = 0; j < G->numVertexes; j++)
		
		{
		
			G->arc[i][j] = 0;
		
		}
	
	}


	G->arc[0][1] = 1;

	G->arc[0][5] = 1;


	G->arc[1][2] = 1;

	G->arc[1][8] = 1;

	G->arc[1][6] = 1;


	G->arc[2][3] = 1;

	G->arc[2][8] = 1;


	G->arc[3][4] = 1;

	G->arc[3][7] = 1;

	G->arc[3][6] = 1;

	G->arc[3][8] = 1;

	G->arc[4][5] = 1;

	G->arc[4][7] = 1;

	G->arc[5][6] = 1;

	G->arc[6][7] = 1;

	for (i = 0; i < G->numVertexes; i++)	
	{	
		for (j = i; j < G->numVertexes; j++)		
		{		
			G->arc[j][i] = G->arc[i][j];		
		}	
	}
}

/*
1.这里没说从哪个顶点开始进行广度搜索，就从第一个节点进行
2，要建立一个visit数组记录每个节点的访问情况
3.如果该结点没有进行过访问，就开始对这个节点进行访问，并将该节点的visit储存的状态置为真。
4.然后要依次遍历与该节点相连的节点，先将自己进行入队，接下来进行循环
5.出队，遍历至第一个到与之相连的且没有访问过的节点，对它进行访问，然后将其visit状态置为真，将其入队。
*/


/* PRESET CODE END - NEVER TOUCH CODE ABOVE */

void BFSTraverse(MGraph G)
{
   /*请补充代码*/
   int i, j;
   Queue Q;
   InitQueue(&Q);
   int visit[MAXVEX] ;
   for(i = 0 ;i < MAXVEX; i ++)
   {
   		visit[i] = FALSE; 
	}
	
	for(i = 0; i < G.numVertexes ;i ++)
	{
		if(!visit[i]) 
		{
			printf("%c ",G.vexs[i]);	
			visit[i] = TRUE;
			EnQueue(&Q, i);
			while(!QueueEmpty(Q))
			{
				char j;
				DeQueue(&Q, &j);	
				int k = 0;
				for(; k < G.numVertexes; k ++)
				{
					if(G.arc[j][k] != 0 && visit[k] != TRUE)
					{
						printf("%c ", G.vexs[k]);
						visit[k] = TRUE;
						EnQueue(&Q, k); 
					}
				}
			}	
		}	
	}   
}
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */


int main(void)

{

	MGraph G;

	CreateMGraph(&G);

	printf("广度遍历：");

	BFSTraverse(G);

	printf("\n");

	return 0;

}


/* PRESET CODE END - NEVER TOUCH CODE ABOVE */


```



#### 14. 2023级-04班-期末复习题-图的遍历-深度优先遍历连通图-邻接矩阵法

```c
//编写DFSTraverse函数

/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */


#include "stdio.h"    

#include "stdlib.h"   


#include "math.h"  

#include "time.h"


#define OK 1

#define ERROR 0

#define TRUE 1

#define FALSE 0


typedef int Status;	/* Status是函数的类型,其值是函数结果状态代码，如OK等 */

typedef int Boolean; /* Boolean是布尔类型,其值是TRUE或FALSE */


typedef char VertexType; /* 顶点类型 */

typedef int EdgeType; /* 边上的权值 */


#define MAXSIZE 9 /* 存储空间初始分配量 */

#define MAXEDGE 15

#define MAXVEX 9


typedef struct

{

	VertexType vexs[MAXVEX]; /* 顶点表 */

	EdgeType arc[MAXVEX][MAXVEX];/* 邻接矩阵，可看作边表 */

	int numVertexes, numEdges; /* 图中当前的顶点数和边数 */

}MGraph;


void CreateMGraph(MGraph* G)

{

	int i, j;


	G->numEdges = 15;

	G->numVertexes = 9;


	/* 读入顶点信息，建立顶点表 */

	G->vexs[0] = 'A';

	G->vexs[1] = 'B';

	G->vexs[2] = 'C';

	G->vexs[3] = 'D';

	G->vexs[4] = 'E';

	G->vexs[5] = 'F';

	G->vexs[6] = 'G';

	G->vexs[7] = 'H';

	G->vexs[8] = 'I';



	for (i = 0; i < G->numVertexes; i++)/* 初始化图 */

	{

		for (j = 0; j < G->numVertexes; j++)

		{

			G->arc[i][j] = 0;

		}

	}


	G->arc[0][1] = 1;

	G->arc[0][5] = 1;


	G->arc[1][2] = 1;

	G->arc[1][8] = 1;

	G->arc[1][6] = 1;


	G->arc[2][3] = 1;

	G->arc[2][8] = 1;


	G->arc[3][4] = 1;

	G->arc[3][7] = 1;

	G->arc[3][6] = 1;

	G->arc[3][8] = 1;


	G->arc[4][5] = 1;

	G->arc[4][7] = 1;


	G->arc[5][6] = 1;


	G->arc[6][7] = 1;



	for (i = 0; i < G->numVertexes; i++)

	{

		for (j = i; j < G->numVertexes; j++)

		{

			G->arc[j][i] = G->arc[i][j];

		}

	}


}


/* PRESET CODE END - NEVER TOUCH CODE ABOVE */

void DFSTraverse(MGraph G)
{
   /*请补充代码*/
   int i = 0;
   int visit[G.numVertexes + 1];
   for(i = 0; i < G.numVertexes; i++)
   {
   		visit[i] = FALSE;
	} 
	int stack[MAXVEX];
	int top = -1;
	for(i = 0 ;i < G.numVertexes ;i ++)
	{
		if(visit[i] == FALSE)
		{			
			stack[++top] = i;
			while(top != -1)
			{
				int temp = stack[top--];
				if(visit[temp] == FALSE)
				{
					printf("%c ",G.vexs[temp]);
					visit[temp] = TRUE;
					int k = 0;
					for(k = G.numVertexes - 1; k >= 0 ; k --)
					{
						if(G.arc[temp][k] != 0 && visit[k] == FALSE)
						{
							stack[++top] = k;
						}
					}
				}
			}
		}
	 } 
}
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */


int main(void)

{

	MGraph G;

	CreateMGraph(&G);

	printf("深度遍历：");

	DFSTraverse(G);

	printf("\n");

	return 0;

}


/* PRESET CODE END - NEVER TOUCH CODE ABOVE */
```



#### 15. 2023-期末复习-图的广度优先搜索-邻接表法

```c
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */


#include "stdio.h"

#include "stdlib.h"


#define OK 1

#define ERROR 0

#define TRUE 1

#define FALSE 0



#define MAXSIZE 8 /* 存储空间初始分配量 */

#define MAXEDGE 9 /* 存储空间初始分配量 */


#define MAXVEX 8


typedef int Status;/* Status是函数的类型,其值是函数结果状态代码，如OK等 */


typedef struct EdgeNode//边表节点

{

    int adjvex;//存储该顶点对应的下标

    struct EdgeNode *next;//指向该顶点的下一个邻接点

}EdgeNode;


typedef struct VertexNode//顶点表结点

{

    char data;//顶点

    EdgeNode *firstedge;//边表头指针

}VertexNode;


typedef struct//图的邻接表存储结构

{

    VertexNode adjList[MAXVEX];//有4个VertexNode这种类型的顶点，定义一个数组adjList[4]，每个元素是VertexNode类型

    int numVertexes,numEdges;//图中顶点数和边数，这里是4,5

}GraphAdjList;


void CreateALGraph(GraphAdjList *p)//无向图的邻接表创建

{

int k;

int i;

int j;

    GraphAdjList *Gp=(GraphAdjList *)malloc(sizeof(GraphAdjList));

    EdgeNode *pe;

	printf("请输入顶点数和边数:\n");

	scanf("%d %d",&(Gp->numVertexes),&(Gp->numEdges));

	printf("请输入顶点数的数据:\n");

	getchar();

    for (k = 0; k < Gp->numVertexes; k++)

{

		scanf("%c",&(Gp->adjList[k].data));

		getchar();

Gp->adjList[k].firstedge = NULL;//将边表头指针指向NULL，即置为0

    }

	printf("请输入边的数据:\n");

for (k = 0; k <  Gp->numEdges; k++)//建立边表

{

		scanf("%d %d",&i,&j);

		getchar();

        pe = (EdgeNode *)malloc(sizeof(EdgeNode));

        pe->adjvex = j;// 邻接序号为j

        pe->next = Gp->adjList[i].firstedge;//将pe的指针指向当前顶点指向的结点

        Gp->adjList[i].firstedge = pe;//将当前顶点的指针指向pe


        pe = (EdgeNode *)malloc(sizeof(EdgeNode));

        pe->adjvex = i;

        pe->next = Gp->adjList[j].firstedge;

        Gp->adjList[j].firstedge = pe;//无序图重复上面步骤

    }

*p=*Gp;

}


/* 用到的队列结构与函数********************************** */


/* 循环队列的顺序存储结构 */

typedef struct

{

	int data[MAXSIZE];
	
	int front;    	/* 头指针 */
	
	int rear;/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */

}Queue;


/* 初始化一个空队列Q */

Status InitQueue(Queue* Q)

{

	Q->front = 0;

	Q->rear = 0;

	return  OK;

}


/* 若队列Q为空队列,则返回TRUE,否则返回FALSE */

Status QueueEmpty(Queue Q)

{

	if (Q.front == Q.rear) /* 队列空的标志 */
	
		return TRUE;
	
	else
		
		return FALSE;
	
}


/* 若队列未满，则插入元素e为Q新的队尾元素 */

Status EnQueue(Queue* Q, char e)

{

	if ((Q->rear + 1) % MAXSIZE == Q->front)/* 队列满的判断 */
	
		return ERROR;

	Q->data[Q->rear] = e;/* 将元素e赋值给队尾 */

	Q->rear = (Q->rear + 1) % MAXSIZE;/* rear指针向后移一位置， */

/* 若到最后则转到数组头部 */
	
	return  OK;

}


/* 若队列不空，则删除Q中队头元素，用e返回其值 */

Status DeQueue(Queue* Q, int* e)

{

	if (Q->front == Q->rear)/* 队列空的判断 */
		
		return ERROR;
	
	*e = Q->data[Q->front];/* 将队头元素赋值给e */
	
	Q->front = (Q->front + 1) % MAXSIZE;/* front指针向后移一位置， */
	
	/* 若到最后则转到数组头部 */
	
	return  OK;

}

/* ****************************************************** */


/* PRESET CODE END - NEVER TOUCH CODE ABOVE */

/*
先打印再入队，这样就少了一次条件判断，而且那个条件判断不好加，会影响后面的循环。所以就采用这种方式
*/

void BFSTraverse(GraphAdjList G)
{
   /*请补充代码*/
   int i , j ;
   int visit[MAXVEX] ;
   for(i = 0; i < MAXVEX; i++)
   {
   		visit[i] = FALSE;
   }
   Queue Q;
   InitQueue(&Q);
   for(i = 0; i < G.numVertexes; i ++)
   {
   		if(visit[i] == FALSE)
   		{
   			printf("%c ",G.adjList[j].data);
			visit[j] = TRUE;
   			EnQueue(&Q, i);
			while(!QueueEmpty(Q))
			{
				int j;
				DeQueue(&Q, &j);
				EdgeNode *p = G.adjList[j].firstedge;
                while (p)
                {
                    if (!visit[p->adjvex])
                    {
                        visit[p->adjvex] = TRUE;
                        printf("%c ", G.adjList[p->adjvex].data);
                        EnQueue(&Q, p->adjvex);
                    }
                    p = p->next;
                }
							
			}	
		}
   }
   
}
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */


int main(void)

{

    GraphAdjList p;

    CreateALGraph(&p);

    BFSTraverse(p);//输出的遍历顺序是ADCB

	printf("\n");

    return 0;

}


/* PRESET CODE END - NEVER TOUCH CODE ABOVE */


```



#### 16. 2023级-04班-期末复习题-图的深度优先搜索-邻接表法

```c
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */



#include "stdio.h"

#include "stdlib.h"



typedef struct EdgeNode//边表节点

{

   int adjvex;//存储该顶点对应的下标

   struct EdgeNode *next;//指向该顶点的下一个邻接点

}EdgeNode;



typedef struct VertexNode//顶点表结点

{

   char data;//顶点

   EdgeNode *firstedge;//边表头指针

}VertexNode;



typedef struct//图的邻接表存储结构

{

   VertexNode adjList[4];//有4个VertexNode这种类型的顶点，定义一个数组adjList[4]，每个元素是VertexNode类型

   int numVertexes,numEdges;//图中顶点数和边数，这里是4,5

}GraphAdjList;



void CreateALGraph(GraphAdjList *p)//无向图的邻接表创建

{

int k;

int i;

int j;

   GraphAdjList *Gp=(GraphAdjList *)malloc(sizeof(GraphAdjList));

   EdgeNode *pe;

printf("请输入顶点数和边数:\n");

scanf("%d %d",&(Gp->numVertexes),&(Gp->numEdges));

printf("请输入顶点数的数据:\n");

getchar();

   for (k = 0; k < Gp->numVertexes; k++)

{

scanf("%c",&(Gp->adjList[k].data));

getchar();

Gp->adjList[k].firstedge = NULL;//将边表头指针指向NULL，即置为0

   }

printf("请输入边的数据:\n");

for (k = 0; k <  Gp->numEdges; k++)//建立边表

{

scanf("%d %d",&i,&j);

getchar();

       pe = (EdgeNode *)malloc(sizeof(EdgeNode));

       pe->adjvex = j;// 邻接序号为j

       pe->next = Gp->adjList[i].firstedge;//将pe的指针指向当前顶点指向的结点

       Gp->adjList[i].firstedge = pe;//将当前顶点的指针指向pe



       pe = (EdgeNode *)malloc(sizeof(EdgeNode));

       pe->adjvex = i;

       pe->next = Gp->adjList[j].firstedge;

       Gp->adjList[j].firstedge = pe;//无序图重复上面步骤

   }

*p=*Gp;

}



/* PRESET CODE END - NEVER TOUCH CODE ABOVE */

void DFSTraverse(GraphAdjList G)
{
   /*请补充代码*/
   int stack[G.numVertexes];
   int top = -1;
   int visit[G.numVertexes];
   int i;
   for(i = 0 ;i <G.numVertexes ;i ++)
   {
   		visit[i] = 0;
   }
   for(i = 0; i < G.numVertexes ;i ++)	
   {
   		if(visit[i] == 0){
   			printf("%c ", G.adjList[i].data);
   			visit[i] = 1;
   			stack[++top] = i;
   			while(top != -1){
   				int u = stack[top --];
   				EdgeNode *p = G.adjList[u].firstedge;
				if(visit[p->adjvex] == 0){
					printf("%c ", G.adjList[p->adjvex].data);
					visit[p->adjvex] = 1;
					stack[++top] = p->adjvex;
				   }
			   }
		   }
	} 
   
   
}
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */



int main(void)

{

   GraphAdjList p;

   CreateALGraph(&p);

   DFSTraverse(p);//输出的遍历顺序是ADCB
	
	printf("\n");

   return 0;

}



/* PRESET CODE END - NEVER TOUCH CODE ABOVE */
```



#### 17. 2023-期末复习-图的连通性判断和连通分量计算

```c
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */


#include "stdio.h"    

#include "stdlib.h"   


#include "math.h"  

#include "time.h"


#define OK 1

#define ERROR 0

#define TRUE 1

#define FALSE 0


typedef int Status;/* Status是函数的类型,其值是函数结果状态代码，如OK等 */

typedef int Boolean; /* Boolean是布尔类型,其值是TRUE或FALSE */


typedef char VertexType; /* 顶点类型 */

typedef int EdgeType; /* 边上的权值 */


#define MAXSIZE 9 /* 存储空间初始分配量 */

#define MAXEDGE 4

#define MAXVEX 6


typedef struct

{

VertexType vexs[MAXVEX]; /* 顶点表 */

EdgeType arc[MAXVEX][MAXVEX];/* 邻接矩阵，可看作边表 */

int numVertexes, numEdges; /* 图中当前的顶点数和边数 */

}MGraph;


int count =0;//连通分量的个数，全局变量


void CreateMGraph(MGraph* G)

{

int i, j;


	G->numEdges = 4;

	G->numVertexes = 6;


/* 读入顶点信息，建立顶点表 */

	G->vexs[0] = 'A';

	G->vexs[1] = 'B';

	G->vexs[2] = 'C';

	G->vexs[3] = 'D';

	G->vexs[4] = 'E';

	G->vexs[5] = 'F';



for (i = 0; i < G->numVertexes; i++)/* 初始化图 */

{

for (j = 0; j < G->numVertexes; j++)

{

			G->arc[i][j] = 0;

}

}


	G->arc[0][1] = 1;

	G->arc[0][5] = 1;

	G->arc[1][2] = 1;

	G->arc[3][4] = 1;



for (i = 0; i < G->numVertexes; i++)

{

for (j = i; j < G->numVertexes; j++)

{

			G->arc[j][i] = G->arc[i][j];

}

}


}


/* PRESET CODE END - NEVER TOUCH CODE ABOVE */

int DFSTraverse(MGraph G)
{
   /*请补充代码*/
	int i;
	int stack[G.numVertexes];
	int top = -1;
	int visit[G.numVertexes];
	for(i = 0;i < G.numVertexes ;i ++)
	{
		visit[i] = 0;
	}
	for(i = 0;i < G.numVertexes;i ++)
	{
		if(visit[i] == 0)
		{
			visit[i] = 1;
			stack[++top] = i;
			while(top != -1){
				int u = stack[top --];
				int k = 0;
				for(k = 0;k < G.numVertexes;k ++)
				{
					if(G.arc[u][k] != 0 && visit[k] == 0)
					{
						visit[k] = 1;
						stack[++top] = k;
					}
				}
			}  
			count++;
		}
	}
	return count > 1 ? 0 : 1 ;
}
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */


int main(void)

{

MGraph G;

int connect;

CreateMGraph(&G);

	connect=DFSTraverse(G);

if(connect)

{

		printf("该无向图全连通:\n");

}

else

{

		printf("该无向图不是全连通,其连通分量个数为：%d\n",count);

}

return 0;

}


/* PRESET CODE END - NEVER TOUCH CODE ABOVE */
```



#### 18. 2023级-04班-期末复习题-判断图的顶点连通性

```c
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */

#include "stdio.h"

#include "stdlib.h"

#include "string.h"

#define TRUE 1

int visited[4];

typedef struct EdgeNode//边表节点

{

   int adjvex;//存储该顶点对应的下标

   struct EdgeNode *next;//指向该顶点的下一个邻接点

}EdgeNode;

typedef struct VertexNode//顶点表结点

{

   char data;//顶点

   EdgeNode *firstedge;//边表头指针

}VertexNode;

typedef struct//图的邻接表存储结构

{

   VertexNode adjList[4];//有4个VertexNode这种类型的顶点，定义一个数组adjList[4]，每个元素是VertexNode类型

   int numVertexes,numEdges;//图中顶点数和边数，这里是4,5

}GraphAdjList;

void CreateALGraph(GraphAdjList *p)//无向图的邻接表创建

{

int k;

int i;

int j;

   GraphAdjList *Gp=(GraphAdjList *)malloc(sizeof(GraphAdjList));

   EdgeNode *pe;

printf("请输入顶点数和边数:\n");

scanf("%d %d",&(Gp->numVertexes),&(Gp->numEdges));

printf("请输入顶点数的数据:\n");

getchar();

   for (k = 0; k < Gp->numVertexes; k++)

{

scanf("%c",&(Gp->adjList[k].data));

getchar();

Gp->adjList[k].firstedge = NULL;//将边表头指针指向NULL，即置为0

visited[k]=0;

}

printf("请输入边的数据:\n");

for (k = 0; k <  Gp->numEdges; k++)//建立边表

{

scanf("%d %d",&i,&j);

getchar();

       pe = (EdgeNode *)malloc(sizeof(EdgeNode));

       pe->adjvex = j;// 邻接序号为j

       pe->next = Gp->adjList[i].firstedge;//将pe的指针指向当前顶点指向的结点

       Gp->adjList[i].firstedge = pe;//将当前顶点的指针指向pe

       pe = (EdgeNode *)malloc(sizeof(EdgeNode));

       pe->adjvex = i;

       pe->next = Gp->adjList[j].firstedge;

       Gp->adjList[j].firstedge = pe;//无序图重复上面步骤

   }

*p=*Gp;

}

int LocateVex(GraphAdjList G,char u)

{ // 初始条件: 图G存在,u和G中顶点有相同特征

  // 操作结果: 若G中存在顶点u,则返回该顶点在图中位置;否则返回-1

  int i;

  for(i=0;i < G.numVertexes;i ++)
  {
  		if(G.adjList[i].data == u)	return i;
  }

    return -1;

}

int NextAdjVex(GraphAdjList G,int v,int w)

{ // 初始条件: 图G存在,v是G中某个顶点,w是v的邻接顶点

  // 操作结果: 返回v的(相对于w的)下一个邻接顶点的序号。

  // 若w是v的最后一个邻接点,则返回-1

  EdgeNode *p;

  p=G.adjList[v].firstedge;

  while(p&&p->adjvex!=w)  

  {

  p=p->next;

  }

  if(!p||!p->next)  //没找到w或w是最后一个邻接点

    return -1;

  else   //p->adjvex==w

    return p->next->adjvex;

}

/* PRESET CODE END - NEVER TOUCH CODE ABOVE */

//补充函数代码

void isConnected(GraphAdjList G, int v1, int v2, int *flag)
{
	if(v1 == v2)	
	{
		*flag = TRUE;
		return ;
	}
	EdgeNode *p;
	p=G.adjList[v1].firstedge;
	while(p)
	{
		int res = NextAdjVex(G, p->adjvex, v2);
		if(res == -1)
			p = p->next;
		else
		{
			*flag = 1;
			return;
		}
	}	
}



/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */

int main(void)

{

   GraphAdjList p;

char u1;

char u2;

int v1;

int v2;

int flag=0;

   CreateALGraph(&p);

printf("输入两个顶点:\n");

scanf("%c %c",&u1,&u2);

v1=LocateVex(p,u1);

v2=LocateVex(p,u2);

isConnected(p,v1,v2,&flag);

if(flag)

{

printf("顶点相通\n");

}

else

{

printf("顶点不相通\n");

}

   return 0;

}

/* PRESET CODE END - NEVER TOUCH CODE ABOVE */
```



#### 19. 2023级-04班-期末复习题-图的回路判断

```C
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */



#include "stdio.h"    

#include "stdlib.h"  



#include "math.h"  

#include "time.h"



#define OK 1

#define ERROR 0

#define TRUE 1

#define FALSE 0



typedef int Status; /* Status是函数的类型,其值是函数结果状态代码，如OK等 */

typedef char VertexType; /* 顶点类型 */

typedef int EdgeType; /* 边上的权值 */


#define MAXSIZE 9 /* 存储空间初始分配量 */

#define MAXEDGE 6

#define MAXVEX 6

int visited[MAXVEX]; /* 访问标志的数组 */ 
int parent[MAXVEX]; /*父链接结点*/


typedef struct

{

VertexType vexs[MAXVEX]; /* 顶点表 */

EdgeType arc[MAXVEX][MAXVEX];/* 邻接矩阵，可看作边表 */

int numVertexes, numEdges; /* 图中当前的顶点数和边数 */

}MGraph;



int count =0;//连通分量的个数，全局变量



void CreateMGraph(MGraph* G)

{

int i, j;



G->numEdges = MAXEDGE;

G->numVertexes = MAXVEX;



/* 读入顶点信息，建立顶点表 */

G->vexs[0] = 'A';

G->vexs[1] = 'B';

G->vexs[2] = 'C';

G->vexs[3] = 'D';

G->vexs[4] = 'E';

G->vexs[5] = 'F';





for (i = 0; i < G->numVertexes; i++)/* 初始化图 */

{

for (j = 0; j < G->numVertexes; j++)

{

G->arc[i][j] = 0;

}

}



G->arc[0][1] = 1;

G->arc[0][4] = 1;

G->arc[0][5] = 1;

G->arc[1][2] = 1;

G->arc[2][3] = 1;

G->arc[3][4] = 1;





for (i = 0; i < G->numVertexes; i++)

{

for (j = i; j < G->numVertexes; j++)

{

G->arc[j][i] = G->arc[i][j];

}

}



}



int LocateVex(MGraph G, VertexType e)

{

// 初始条件:图G存在,u和G中顶点有相同特征

// 操作结果:若G中存在顶点u,则返回该顶点在图中位置;否则返回-1

//补充函数
	
	int i = 0;
	for(;i < G.numVertexes;i ++)
	{
		if(G.vexs[i] == e)	return i;
	 } 
	 return -1;

}


Status FindCycle(MGraph G, int v0) {
    int i, u, v;

    for (i = 0; i < G.numVertexes; i++) 
    {
        visited[i] = 0; // Initialize all vertices as not visited
        parent[i] = -1; // Initialize parent array
    }

    for (u = 0; u < G.numVertexes; u++) 
    {
        if (!visited[u]) 
        { // Don't recur for already visited vertices
            int stack[MAXVEX], top = -1;
            stack[++top] = u; // Push the current source node

            while (top != -1) 
            {
                v = stack[top--]; // Pop a vertex from stack
                visited[v] = 1; // Mark the node as visited

                for (i = 0; i < G.numVertexes; i++) 
                {
                    if (G.arc[v][i]) 
                    { // If there is an edge
                        if (!visited[i]) 
                        { // If the adjacent node is not visited
                            stack[++top] = i; // Push the adjacent node onto the stack
                            parent[i] = v; // Mark the parent of the adjacent node
                        } 
                        else if (i != parent[v]) 
                        { // If an adjacent is visited and not parent of current vertex
                            return TRUE; // Cycle detected
                        }
                    }
                }
            }
        }
    }
    return FALSE; // If no cycle is detected
}


/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */



int main(void)

{

MGraph G;

int flag=0;

int i;

CreateMGraph(&G);

for(i=0;i< MAXVEX ;i++)

{

visited[i]=0;

parent[i]=-1;

}

flag=FindCycle(G,0);

if(!flag)

{

printf("图没有回路\n");

}

else

{

printf("图有回路\n");

}

return 0;

}



/* PRESET CODE END - NEVER TOUCH CODE ABOVE */
```



#### 20. 2023级-04班-期末复习题-查找操作-折半二分法-非递归

```c
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */

#include "stdio.h"

#include "stdlib.h"

typedef struct{

   int  Age[16];  // 数据元素存储空间基址

   int  length;   // 表长度

}SSTable;

/* PRESET CODE END - NEVER TOUCH CODE ABOVE */



//补充函数

int Search (SSTable ST, int key)
{
    //学生增加的程序~
    int left = 0, right = ST.length;
	while(left <= right)
	{
		int mid = (left + right) / 2;
		printf("%d",ST.Age[mid + 1]);
		if(ST.Age[mid + 1] > key)	right = mid - 1;
		else if(ST.Age[mid + 1] == key)	
			return mid + 1;
		else left = mid + 1;
	 } 
	 return 0;
}



/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */

int main()

{

	SSTable ST;
	
	ST.length=15;
	
	ST.Age[0]=ST.length;

   int a[15]={5,10,11,15,17,19,21,25,36,38,50,51,55,57,68};
	
	int i, val, ret;

   for(i=0; i<15; i++)

	{
	
		ST.Age[i+1]=a[i];
	
        printf("%d", ST.Age[i+1]);
	
	}

   printf("\n请输人所要查找的元素：");

   scanf("%d",&val);
	
	printf("\n");

   ret = Search(ST,val);

   if(0 == ret)

       printf("\n查找失败\n");

   else

       printf("\n查找成功\n");

return 0;

}

/* PRESET CODE END - NEVER TOUCH CODE ABOVE */
```



#### 21. 2023---期末复习-查找操作-折半查找-递归

```c
#include<stdio.h>
int BinSearch(int arr[],int key,int low, int high)                          //折半查找法（二分法）
{
	if(low > high)	//递归终止条件不要忘！！！！！！
		return -1;
	
	int mid = (low + high) / 2;
	if(arr[mid] == key)	
		return mid;
		
	else if(arr[mid] > key)	
		return BinSearch(arr, key, low, mid - 1);
	else
		return BinSearch(arr, key, low + 1, high);
		
//	else if(arr[mid] > key)	
//		return BinSearch(arr, key, low, mid - 1) > 0 ? BinSearch(arr, key, low, mid - 1) : -1;
//	else
//		return BinSearch(arr, key, low + 1, high) > 0 ? BinSearch(arr, key, low + 1, high) : -1; -1;

}
int main()
{
	int arr[]={1,2,3,4,5,6,7,8,9,10,11};                   
	printf("%d\n",BinSearch(arr,7,1,(sizeof(arr)/sizeof(arr[0]))));
	return 0;
}
```



#### 22. 2023级-04班-期末复习题--二叉排序树的查找

```c
#include <stdio.h>
#include <stdlib.h>

// Define the structure for a tree node
typedef struct Node {
    int data;
    struct Node *left, *right;
} Node;

// Function to create a new node
Node* createNode(int data) {
    Node *newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a node into the BST
Node* insertNode(Node* root, int data) {
    if (root == NULL) {  // If the tree is empty, create a new node
        return createNode(data);
    }
    if (data < root->data) {  // If the data is less, insert in the left subtree
        root->left = insertNode(root->left, data);
    } else if (data > root->data) {  // If the data is more, insert in the right subtree
        root->right = insertNode(root->right, data);
    }
    return root;  // Return the unchanged root pointer
}

// Function to search for a node in the BST
int searchNode(Node* root, int key) {
    if (root == NULL) {
        return 0;  // Return 0 if the node is not found
    }
    if (root->data == key) {
        return 1;  // Return 1 if the node is found
    }
    if (key < root->data) {
        return searchNode(root->left, key);  // Search in the left subtree
    } else {
        return searchNode(root->right, key);  // Search in the right subtree
    }
}

// Main function
int main() {
    int n, i, key;
    Node *root = NULL;

    printf("输入二叉树的结点个数:\n");
    scanf("%d", &n);  // Input the number of nodes

    printf("输入各个结点:\n");
    for (i = 0; i < n; i++) {
        int value;
        scanf("%d", &value);  // Input the node values
        root = insertNode(root, value);  // Insert each value into the BST
    }

    printf("输入查找结点:\n");
    scanf("%d", &key);  // Input the key to be searched

    if (searchNode(root, key)) {
        printf("查找成功\n");
    } else {
        printf("查找失败\n");
    }

    return 0;
}

```



#### 23. 2023-期末复习--哈希表的查找

```c
/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */


#include <stdio.h>

#include <stdlib.h>

#define TRUE 1

#define FALSE 0

#define MAXSIZE 100 /* 存储空间初始分配量 */

typedef int Status;/* Status是函数的类型,其值是函数结果状态代码，如TRUE等 */

#define HASHSIZE 12 // 定义哈希表长为数组的长度

#define NULLKEY -32768 // 空关键字


typedef struct

{

int *elem; // 数据元素存储基址，动态分配数组

int count; //  当前数据元素个数

}HashTable;


int m = 0; // 哈希表表长，全局变量


Status initHashTable(HashTable *hash)

{

int i;

	m = HASHSIZE;

	hash->count = m;

	hash->elem = (int *)malloc(m*sizeof(int));

	for (i = 0; i < m; i ++)
		hash->elem[i] = NULLKEY;
	
	return TRUE;

}

// 构造哈希函数

int hashFun(int key)

{

return key % m; // 构造方法为除留余数法

}

// 插入关键字进哈希表

void insertHash(HashTable *hash, int key)

{

int addr = hashFun(key); // 求哈希地址

while (hash->elem[addr] != NULLKEY) // 如果不为空，则冲突

{

		addr = (addr + 1) % m; // 开放定址法的线性探测

}

	hash->elem[addr] = key; // 直到有空位后插入关键字

}


/* PRESET CODE END - NEVER TOUCH CODE ABOVE */


Status searchHash(HashTable hash, int key, int *addr)
{
	*addr = hashFun(key);
	while(hash.elem[*addr] != key && hash.elem[*addr] !=NULLKEY && (*addr + 1) != hashFun(key))
	{
		*addr = (*addr + 1) % m;
	}
	if(hash.elem[*addr] == key)
		return 1;
	return 0;
}



/* PRESET CODE BEGIN - NEVER TOUCH CODE BELOW */


int main()

{

int arr[HASHSIZE] = {12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48, 34}; // 要插入关键字

int key; // 关键字

int addr; // 哈希地址

int i;

int result;

HashTable hash;

// 初始化哈希表

	initHashTable(&hash);

// 插入关键字到哈希表

for (i= 0; i< m; i++)

{

		insertHash(&hash, arr[i]);

}

// 遍历查找关键字（都会成功）

	printf("输入要查找的key值:\n");

	scanf("%d",&key);
	
//	printf("%d",key); 

	result=searchHash(hash, key, &addr);

if (result)

		printf("查找 %d 的哈希地址为：%d\n", key, addr);

else

		printf("查找 %d 失败\n", key);

return 0;

}


/* PRESET CODE END - NEVER TOUCH CODE ABOVE */
```



#### 24. 2023-04班-期末复习题-排序-插入排序

```c
#include <stdio.h>

void MyInsertSort(int A[], int n)

{

//添加程序
	int i, j;
	for(i = 1; i < n;i ++)
	{
		if(A[i] > A[i + 1])
		{
			A[0] = A[i + 1];
			for(j = i;j > 0;j --)
			{
				if(A[j] > A[0])
					A[j + 1] = A[j];
				else
					break;				
			}
			A[j + 1] = A[0];
		}
	}

}

int main()

{

int A[20];

int n;

int i;

scanf("%d",&n);

for(i=1;i<=n;i++)

{

scanf("%d",&A[i]);

}

// 4 8 3 9 6 5 12 1 10 7



MyInsertSort(A,n);

printf("插入排序后:\n");

for (i = 1; i<=n; i++)

{

printf("%d ", A[i]);

}

printf("\n");

return 1;

}
```



#### 25. 2023-04班-期末复习题-排序-简单选择

```c
#include <stdio.h>



int SelectMinKey(int A[], int i,int n) //A 为带排列的数组，i为待排的数，n为数组的长度

{ 

    //学生添加程序// 返回在A[i..n]中key最小的记录的序号
	int min = A[i], min_n = i;
	for(;i < n;i ++)
	{
		if(A[i] < min)
		{
			min = A[i];
			min_n = i;
		}
	}
	return min_n;

}



void SelectSort(int A[], int n)

{ 

   // 对A作简单选择排序。

   int i,j;

   int temp;

    for(i=0;i<n;i++)

    {

     //  选择第i小的记录，并交换到位

j=SelectMinKey(A, i, n); // 在A[i..n]中选择key最小的记录

if(i!=j) 

{

temp=A[i];

A[i]=A[j];

A[j]=temp; // 与第i个记录交换

}

}

}







int main()

{

int A[20];

int n;

int i;

scanf("%d",&n);

for(i=0;i<n;i++)

{

scanf("%d",&A[i]);

}

SelectSort(A,n);

printf("选择排序后:\n");

for (i = 0; i<n; i++)

{

printf("%d ", A[i]);

}

printf("\n");

return 1;

}



```



#### 26. 2023-复习-排序-快速排序

```c
#include <stdio.h>

int PartitionScore(int A[], int low, int high)

{

    //★★★请补全代码
	int temp = A[low];
	while(low < high) {
		while(low < high && A[high] >= temp)	high--;
		A[low] = A[high];
		while(low < high && A[low] <= temp)	low++;
		A[high] = A[low];		
	}   
	A[low] = temp;
	return low; 


}



void QSort(int A[], int low, int high)

{

     //请补全代码
     if(low < high)
     {
     	int pivotloc = PartitionScore(A, low, high);
     	QSort(A, low, pivotloc - 1);
     	QSort(A, pivotloc + 1, high);
	 }

}



int main()

{

int A[20];

int n;

int i;

scanf("%d",&n);

for(i=0;i<n;i++)

{

scanf("%d",&A[i]);

}

QSort(A,0,n-1);

printf("快速排序后:\n");

for (i = 0; i<n; i++)

{

printf("%d ", A[i]);

}

printf("\n");

return 1;

}
```



#### 27. 2023-04班-期末复习题-排序-冒泡排序

```c
//编写冒泡排序BubbleSort函数

#include <stdio.h>

void BubbleSort(int A[], int n)

{

	//请补全代码
	int i,j;
	for(i = 0;i < n; i ++)
	{
		for(j = 0;j < n - i - 1;j ++)
		{
			if(A[j] > A[j + 1])
			{
				int temp = A[j];
				A[j] = A[j + 1];
				A[j + 1] = temp;
			}
		}
	}
}

int main()

{

	int A[] = { 4, 8, 3, 9, 6, 5, 12, 1, 10, 7 };

	BubbleSort(A, sizeof(A)/sizeof(A[0]));

	printf("冒泡排序后:\n");
	
	int i;

	for (i = 0; i<sizeof(A) / sizeof(A[0]); i++)

	{

		printf("%d ", A[i]);

	}

	printf("\n");

	return 1;

}
```



### 2023期末真题

#### 1. 2023 期末 第一题 顺序表(8+7=15分）

```c
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0
#define MAXSIZE 100 //顺序表可能达到的最大长度

typedef int Status; //Status是函数返回值类型，其值是函数结果状态代码
typedef int ElemType; //ElemType为可定义的数据类型，此处设为int类型

typedef struct
{
    ElemType
        线性表当前长度
}SqList;

//顺序表的初始化（构造一个空的顺序表L） 
Status InitList_Sq(SqList *L)
{
    L->elem=(ElemType*)malloc(sizeof(ElemType)*MAXSIZE); //为顺序表分配一个大小为MAXSIZE的数组空间
    if(!L->elem)
        return ERROR; //存储分配失败
    L->length=0; //空表长度置为0
    return OK;
}

//创建长度为n的顺序表
Status CreateList_Sq(SqList *L, int n)
{
    if(n<=0||n>MAXSIZE)
        return ERROR;
    int i;
    for(i=0;i<n;i++)
    {
        scanf("%d", &L->elem[i]);
    }
    L->length=n;
    return OK;
}

//删除线性表L中所有在[a,b]范围内的数据元素，其中a,b均为整数，且a<b
//要求算法时间复杂度为O(n)且空间复杂度为O(1)
Status DeleteItem(SqList *L,int a,int b)
{
    //请补全代码
    if(a >= b)	
	{
		printf("SqList delete range error.");
		return ERROR;
	} 
	int i = 0, k = 0;

	for(i = 0;i < L->length;i ++)
	{
		if(L->elem[i] >b || L->elem[i] < a)
		{//直接覆盖原来线性表元素
			L->elem[k ++] = L->elem[i];
		}
	}
	L->length = k;
	return OK;
	 


}

//输出顺序表L中的全部元素 
void PrintList_Sq(SqList L)
{
    int i;
    for(i=0;i<L.length;i++)
    {
        printf("%d ", L.elem[i]);
    }
    printf("\n");
}


int main()
{
//请补全代码
	int n;
	scanf("%d",&n);
	if(n <= 0 || n > MAXSIZE)
	{
		printf("SqList length error.");
		return ERROR;
	}
	SqList L;
	InitList_Sq(&L);
	CreateList_Sq(&L, n);
	
	int a, b;
	scanf("%d %d",&a, &b);
	if(DeleteItem(&L, a, b) == OK)
		PrintList_Sq(L);
	
	return 0;
}
```



#### 2. 2023 期末第二题 单链表基本操作与应用（5+10=15分）

```c
#include <stdio.h>
#include <stdlib.h>

//函数结果状态代码
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE 0
//新建函数类型，表示函数运行结果
typedef int Status;

/*动态单链表的结构体定义*/ 
//定义结构体
typedef int ElemType;
typedef struct LNode
{
    ElemType data; //数据域
    struct LNode* next; //指针域
}LNode, *LinkList;

Status InitList(LinkList *L)
{
    int x,i;
    *L = (LinkList)malloc(sizeof(LNode));
    if(*L == NULL)
    {
        printf("memory malloc failure\n");
        return ERROR;
    }
    (*L)->next = NULL;
        //根据键盘值构造链表
    LinkList r;
    r = *L;
    for(i=0; ;i++)
    {
        scanf("%d",&x);
        if(x == -1)
            break;
        LinkList p = (LinkList)malloc(sizeof(LNode));
        if(!p) 
        {
            printf("initial failure\n");
            return ERROR;
        }
        p->data = x;
        p->next = NULL;
        r->next = p;
        r = p;
    }
    return OK;

}

Status DestoryList(LinkList *L)
{
    LinkList p;
    while(*L) //当L为空时循环结束
    {
        p = (*L)->next; //p指向下一个结点
        free(*L); //释放L
        *L = p;
    }
    return OK;
}

Status ListEmpty(LinkList L)
{
    return (L->next == NULL);
}

Status ClearList(LinkList L) 
{
    LinkList p, q;
    p = L->next; //p指向链表第一个结点
    while (p) //当p指向空时循环结束
    {
        q = p->next;
        free(p);
        p = q;
    }
    L->next = NULL; //头结点指针域为空
    return OK;
}

int ListLength(LinkList L)
{
   //补全代码
    int total = 0;
	LinkList p = L->next;
    while(p)
    {
    	total ++;
    	p = p->next;
	}
	return total;


}


Status ListTraverse(LinkList L)
{
    LinkList p = L->next;
    while (p) //当p为空时结束循环
    {
        printf("%d ",p->data); 
        p = p->next;
    }
    printf("\n");
    return OK;
}

Status ListOperate(LinkList *L)
{

 //补全代码
 	LinkList p = (*L);
	if(ListEmpty(*L))
	{
		LinkList r;
		r = (LinkList)malloc(sizeof(LNode));
		if(!r)	return ERROR;
		r->data = 0;
		LinkList s;
		s = (LinkList)malloc(sizeof(LNode));
		if(!s)	return ERROR;
		s->data = 0;
		p->next = r;
		r->next = s;
		s->next = NULL;
		return 0;
	}
	int max = p->next->data, min = p->next->data;
	while(p->next)
	{
		if(p->next->data > max)
		{
			max = p->next->data;
		}
		else if(p->next->data < min)
		{
			min = p->next->data;
		}
		p = p->next;
	 }
 	LinkList r;
	r = (LinkList)malloc(sizeof(LNode));
	if(!r)	return ERROR;
	r->data = min;
	r->next = p->next;
	p->next = r;
	
	LinkList s;
	s = (LinkList)malloc(sizeof(LNode));
	if(!s)	return ERROR;
	s->data = max;
	s->next = (*L)->next;
	(*L)->next = s;

	return 1; 
	 

}

int main()
{
    //初始化链表
    LinkList L;
    if (InitList(&L) == ERROR)
    {
        return 0;
    }
    ListTraverse(L);//对应第一行打印输出
    int len = ListLength(L);
    printf("%d\n",len);//对应第二行打印输出
    ListOperate(&L);
    ListTraverse(L);//对应第三行打印输出
    DestoryList(&L);
    return 0;
}
```



#### 3. 2023 期末-第三题 队列（5+10=15分）

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#define null 0
#define OK 1
#define ERROR 0
#define MAXSIZE 100
 
typedef struct{
    int *base;
    int front;
    int rear;
}SqQueue;
 
 
 
 //初始化循环队列
void InitQueue(SqQueue *Q){
     
    Q->base=(int *)malloc(MAXSIZE*sizeof(int));
    Q->front=0;
    Q->rear=0;
    
}
 
 
 //求队列长度
int QueueLength(SqQueue *Q)
{
 
    //★★★请补全代码
    return  (Q->rear - Q->front + MAXSIZE) % MAXSIZE;

 
}
 
 
int  EnQueue(SqQueue *Q,  int e) // 入队列
{
    if((Q->rear+1)%MAXSIZE==Q->front)
        return ERROR;
         
    Q->base[Q->rear]=e;
    Q->rear=(Q->rear+1)%MAXSIZE;
    return OK;
 
}
 
int DeQueue(SqQueue *Q,int *e) // 出队列
{
    if(Q->front==Q->rear)
        return ERROR;
    *e=Q->base[Q->front];
    Q->front=(Q->front+1)%MAXSIZE;
    return OK;

}

int GetHead(SqQueue *Q,int *e) // 取队头元素值
{
    if(Q->front==Q->rear)
        return ERROR;
    *e=Q->base[Q->front];
    return OK;
} 
 
int Baoshu(SqQueue *Q)
{
	while(QueueLength(Q) > 1)
	{
		int bianhao ;
		GetHead(Q, &bianhao);
			
	    int i;
	    for(i = 1;i < MAXSIZE;i ++)
	    {
	    	int e;
	
			DeQueue(Q, &e);
	
			if(i == bianhao)	
			{
				printf("%d ",e);
				Baoshu(Q);
                //不用递归也行，用
                //continue;
                //break;	//最快
                //因为递归到最后Q的长度为1，最后递归回去的时候就是遍历一下这个for循环罢了，用continue就少了些许步骤
			}
			
			else	
			{
				EnQueue(Q, e);
			}
		}
	}
	return Q->base[Q->front];	
	
}
 
int main()
{
    int n;
    int i;
    int j;
    SqQueue Q;
    InitQueue(&Q);
    scanf("%d",&n);
    for(i=1;i<=n;i++)
        EnQueue(&Q, i);
    j=Baoshu(&Q);
    printf("\n");
    printf("%d ",j);
    return 0;
}
```



#### 4. 2023 期末第四题 排序（7+8=15分）

```c
#include <stdio.h>
 
//冒泡排序
void bubbleSort(int arr[], int n) 
{
//★★★请补全代码
	int i, j;
	for(i = 0 ;i < n - 1; i ++)
	 {
	 	for(j = 0 ;j < n - i - 1;j ++)
	 	{
	 		if(arr[j] < arr[j + 1])
			 {
			 	int temp = arr[j];
			 	arr[j] = arr[j +1];
				 arr[j + 1] = temp; 
			  } 
		 }
	 }
    
}
 
//简单选择排序
void selectionSort(int arr[], int n) 
{
//★★★请补全代码
	int i ,j;
	for(i = 0; i < n;i ++)
	{
		int min = arr[i],min_n = i;
		for(j = i ; j < n;j ++)
		{
			if(arr[j] < min)
			{
				min = arr[j];
				min_n = j;
			}
		}
		if(min_n != i)
		{
			arr[min_n] = arr[i];
			arr[i] = min;
		}
	}
    
}

//打印数组 
void printfArray(int arr[], int n) {
    bubbleSort(arr, n);
    printf("Array by bubbleSort are: ");
    int i;
    for(i=0; i< n; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
    selectionSort(arr, n);
    printf("Array by selectionSort are: ");
    for(i=0; i< n;i++){
        printf("%d ", arr[i]);
    }       
    printf("\n");
       
}
 
 
int main() {
    int arr[100];
    int n, k, i;
    scanf("%d", &n);
 
    for (i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }
 
    printfArray(arr, n);
 
    return 0;
}
```



#### 5. 2023 期末第五题 二叉树遍历和应用（7+7+6=20分）

```c
#include <stdio.h>

#include <malloc.h>

#include <stdlib.h>

#define OVERFLOW 0

#define OK 1

typedef struct node         //二叉树结点类型的定义

{

       char data;

       struct node *lchild; //定义结点的左孩子指针

       struct node *rchild; //定义结点的右孩子指针

} BinTNode, *BTNode;

 

BinTNode *CreateBinTree()  //输入二叉树的先序遍历序列，创建二叉链表

{

       BinTNode *t;

       char ch;

       ch = getchar();

       if (ch == '0')             //如果读入0，创建空树

             t = NULL;

       else

       {

             t = (BinTNode *)malloc(sizeof(BinTNode)); //申请根结点*t空间

             if(!t) exit(OVERFLOW);

             t->data = ch;                                  //将结点数据ch放入跟结点的数据域

             t->lchild = CreateBinTree();                        //建左子树

             t->rchild = CreateBinTree();                        //建右子树

       }

       return t;

}

 



void preorder(BTNode t)   //对二叉树进行先序遍历。提示：打印采用 %3c

{

       if (t != NULL)

       {

             printf("%3c", t->data);  //打印节点数据

             preorder(t->lchild);   //先序遍历左子树

             preorder(t->rchild);   //先序遍历右子树

       }

}

 

void inorder(BTNode t) //对二叉树进行中序遍历。提示：打印采用 %3c

{

       //★★★请补全代码
    if(t)
	{
		inorder(t->lchild);
		printf("%3c",t->data);
		inorder(t->rchild);
	 } 

 
}
//二叉树的叶子结点数

int Leaf(BTNode t) 
{
       //★★★请补全代码
    if(!t)	return 0;
    
	else if(t->rchild == NULL && t->lchild == NULL)	return 1;
    
    else
		return Leaf(t->lchild) + Leaf(t->rchild);

}

 

//二叉树的最大值

int Max(BTNode t) 
{

       //★★★请补全代码
    if(!t)	return 0;
    int submax = Max(t->rchild) > Max(t->lchild) ? Max(t->rchild) : Max(t->lchild);
    return submax > t->data ? submax: t->data;

}

 

int main()

{

       BTNode t = NULL;

       //int TreeHeight;

       t = CreateBinTree();

       preorder(t);                             //调用二叉树先序遍历函数

       printf("\n");

       inorder(t);                              //调用二叉树中序遍历函数

       printf("\n");

       printf("%d\n", Leaf(t));

       printf("%c\n", Max(t));

 

}


```



#### 6.期末第六题 应用题-社交网络下谣言传播分析(一) （5+5=10分）

```c
#include <stdio.h>
#include <stdlib.h>
#define MAX_VERTEX_NUM 20  //最大顶点数

typedef struct ArcNode
{
    int adjvex;  //该边所连接的顶点的位置（即该顶点的数组下标）
    struct ArcNode *nextarc;  //指向下一条边的指针
    int info;  // 边的权值
} ArcNode;

typedef struct VNode
{
    int data;  //顶点信息
    ArcNode *firstarc;  //指向第一条依附该顶点的边的指针
} VNode, AdjList[MAX_VERTEX_NUM];

typedef struct ALGraph
{
    AdjList vertices;
    int vexnum, arcnum;  //图的当前顶点数和弧数
} ALGraph;

// 建立关系网的邻接表数据存储结构
void CreateUDN(ALGraph *G)
{
    // 请补全以下代码
    scanf("%d %d",&G->vexnum, &G->arcnum);
	int i;
	for(i = 1;i <= G->vexnum ;i ++)
	{
		G->vertices[i].data = i;
		G->vertices[i].firstarc = NULL;	
	}
		
	for(i = 0 ;i < G->arcnum ;i ++)
	{
		int v1, v2,weight;
		getchar();
		scanf("%d %d %d",&v1, &v2, &weight);
		
		ArcNode *p1;
		p1 = (ArcNode*)malloc(sizeof(ArcNode));
		if(!p1)	return ;
		p1->adjvex = v2;
		p1->info = weight;
		p1->nextarc = G->vertices[v1].firstarc;
		G->vertices[v1].firstarc = p1;
		
		ArcNode *p2;
		p2 = (ArcNode*)malloc(sizeof(ArcNode));
		if(!p2)	return;
		p2->adjvex = v1;
		p2->info = weight;
		p2->nextarc = G->vertices[v2].firstarc;
		G->vertices[v2].firstarc = p2;
	 } 

}

/* 统计顶点的边的权值之和 */
/* 输入参数为图和待统计的顶点编号 */
/* 函数返回值为该顶点的边权值之和  */
int VexCount(ALGraph G, int v)
{
    // 请补全以下代码
	ArcNode *p = G.vertices[v].firstarc;
	int sum = 0;
	while(p)
	{
		sum += p->info;
		p = p->nextarc;
	}
	return sum;
}

int main()
{
    ALGraph G;
    int choice;
    static int count = 0;
    CreateUDN(&G);

	int i;
    for(i=0; i<G.vexnum; i++)
    {
        printf("%d ", VexCount(G, i+1));
    }
    printf("\n");
    return 0;
}

```



#### 7.2023 期末第六题 应用题-社交网络下谣言传播分析(二) （5+5=10分）

```c
#include <stdio.h>
#include <stdlib.h>
#define MAX_VERTEX_NUM 20  //最大顶点数
#define TH 4  // 信任度阈值
#define OVERFLOW -1
#define ERROR 0
#define OK 1

typedef int Status;
typedef int QElemType;
// 邻接矩阵
typedef struct ArcCell
{
    unsigned int weight;  //权值
}AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];

// 无向网
typedef struct MGraph
{
    AdjMatrix arcs;  //邻接矩阵
    int vexnum, arcnum;  //顶点数，弧数
}MGraph;

// 链队列结点
typedef struct QNode
{
    int data;
    struct QNode *next;
}QNode, *QueuePtr;

typedef struct
{
   QueuePtr front,rear; /* 队头、队尾指针 */
}LinkQueue;

int visited[MAX_VERTEX_NUM]; // 顶点是否被访问过
int credit[MAX_VERTEX_NUM]; // 顶点的信用值
int times[MAX_VERTEX_NUM]; // 顶点收到谣言时间

Status InitQueue(LinkQueue *Q)
{ /* 构造一个空队列Q */
    (*Q).front=(*Q).rear=(QueuePtr)malloc(sizeof(QNode));
    if(!(*Q).front)
        exit(OVERFLOW);
    (*Q).front->next=NULL;
    return OK;
}

Status QueueEmpty(LinkQueue Q)
{ /* 若Q为空队列,则返回TRUE,否则返回FALSE */
    return(Q.front==Q.rear);
}

Status EnQueue(LinkQueue *Q,QElemType e)
{ /* 插入元素e为Q的新的队尾元素 */
    QueuePtr p=(QueuePtr)malloc(sizeof(QNode));
    if(!p) /* 存储分配失败 */
        exit(OVERFLOW);
    p->data=e;
    p->next=NULL;
    (*Q).rear->next=p;
    (*Q).rear=p;
    return OK;
}

Status DeQueue(LinkQueue *Q,QElemType *e)
{ /* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR */
    QueuePtr p;
    if((*Q).front==(*Q).rear)
        return ERROR;
    p=(*Q).front->next;
    *e=p->data;
    (*Q).front->next=p->next;
    if((*Q).rear==p)
        (*Q).rear=(*Q).front;
    free(p);
    return OK;
}

/* 建立社交网络 */
void CreateUDN(MGraph *G)
{
    scanf("%d %d",&G->vexnum, &G->arcnum);
    int i, j;
    //初始化邻接矩阵 
    for(i = 0; i < G->vexnum; i++)
    {
        for(j = 0; j < G->vexnum; j++)
        {
            G->arcs[i][j].weight = 0;
        }
    }
    
    for(i = 0; i < G->arcnum ;i ++)
    {
        int v1, v2, weight;
        getchar();
        scanf("%d %d %d",&v1, &v2, &weight);
        G->arcs[v1 - 1][v2 - 1].weight = weight;
        G->arcs[v2 - 1][v1 - 1].weight = weight;
    }
}

/* 广度优先搜索网络，计算谣言传播路径、信任度、传播时间 */
/* 参数：邻接矩阵图；传播谣言的顶点编号 */
void BFSGraph(MGraph G, int v)
{
    int i, j;
    LinkQueue Q; // 辅助队列
    InitQueue(&Q);
    for(i = 0; i < G.vexnum; i++)
    {
        visited[i] = 0;
        credit[i] = 0;
        times[i] = 0; 
    }
    visited[v] = 1;
    credit[v] = 0;
    times[v] = 1;
    printf("%d ", v + 1);
    EnQueue(&Q, v);

    while(!QueueEmpty(Q))
    {
        int u;
        DeQueue(&Q, &u);

        for(j = 1; j < G.vexnum; j++)
        {
            if(G.arcs[u][j].weight != 0 && !visited[j])
            {
                credit[j] += G.arcs[u][j].weight;
                
                if (credit[j] >= TH)
                {
                    visited[j] = 1;
                    times[j] = times[u] + 1;
                    EnQueue(&Q, j);
                    printf("%d ", j + 1);
                }
            }
        }
    }
}

int main()
{
    MGraph G;
    int i,j;
    /* 生成网络 */
    CreateUDN(&G);
    /* 输出邻接矩阵 */
    for(i=0; i< G.vexnum; i++){
        for(j=0; j< G.vexnum; j++)
            printf("%d ", G.arcs[i][j].weight);
        printf("\n");
    }
    /* 广度优先遍历遍历网络 */
    BFSGraph(G, 0);
	printf("\n");
    /* 输出各顶点的谣言信任度 */
    for(i = 0; i< G.vexnum; i++)
    {
        printf("%d ", credit[i]);
    }
    printf("\n");
    /* 输出各顶点的谣言传播时间 */
    for(i = 0; i< G.vexnum; i++)
    {
        printf("%d ", times[i]);
    }
    printf("\n");
    return 0;
}
```



### 2024期末考试

#### 1. 2024期末 顺序表及应用

```c
#include <stdio.h>
#include <stdlib.h>
#define List_init_size 10
#define OK 1
#define ERROR -1
 
 
typedef int Elem;
 
typedef struct
{
    int *elem;
    int length;
    int listsize;
}Sqlist;
 
int Initlist(Sqlist *L)
{
    L->elem=(Elem *)malloc(List_init_size*sizeof(Elem));
    if(!L->elem)return ERROR;
    L->length=0;
    L->listsize=List_init_size;
    return OK;
}
 
//创建具有m个元素的有序表 
int Createlist(Sqlist *L, int m)
{
    if(m>L->listsize ||m==0) 
        return ERROR;
    int i;
    
    for(i=0;i<m;i++)
    {
        scanf("%d",&L->elem[i]);
    }
    
    L->length=m;
    return OK;
}


/*
敬爱的宇宙无敌好老师！！！
调了好久，测试数据都对了！！！ 
扣小分能不能温柔点，可怜可怜孩子吧！！！
小分实在实在是扣不起了，调了那么久会心疼的！！！ 
我知道您一定是全世界最好的老师！！！ 
*/
 
//求有序表L1和L2的交集，存入表L3中。
void Intersection(Sqlist *L1, Sqlist *L2, Sqlist *L3)
{
    //★★★请补全代码
    int len1 = 0,len2 = 0, len3 = 0;
    //补充一点，因为是取交集，故L3的数组绝不会溢出，不会有扩容的需求 
    while(len1 < L1->length && len2 < L2->length)
    {
    	if(L1->elem[len1] == L2->elem[len2])
    	{
    		L3->elem[len3 ++]  = L1->elem[len1];//将交集并入L3中 
    		L3->length ++;//更新L3的长度
			 
    		len1 ++;
    		len2++;
		}
		else if(L1->elem[len1] < L2->elem[len2])
		{
			len1++;
		}
		else 
			len2 ++;
	}


}


//线性表L的前m个元素移到表尾，参数n为表L的长度
//如果m>n,返回ERROR；如果操作完成，返回OK  
int Move(Sqlist *L, int n, int m)
{
    //★★★请补全代码
    if(m >n)
    {//如果m大于表长则不执行该移动操作
    	return ERROR;
	}
	
	int i = 0;
	for(i = 0;i < m;i ++)
	{
		int temp = L->elem[i];
		L->elem[i] = L->elem[n + i - m];
		L->elem[n + i - m] = temp;
	}
    return OK;
}
 
 
 
void Display(Sqlist *L)
{
    int i;
    for(i=0;i<L->length;i++)
    {
        printf(i==(L->length-1)?"%d\n":"%d ",L->elem[i]);
    }
}
 
 
int main()
{
  int m,n,x;
     int i,j;
    Sqlist A,B,C;
    scanf("%d%d",&m,&n);
    Initlist(&A);
    Initlist(&B);
    Initlist(&C);
    i=Createlist(&A,m);
    if(i==-1)
    {
         printf("The number of elements is illegal!\n");
         exit(0);
    }
   
    j=Createlist(&B,n);
    if(j==-1)
    {
         printf("The number of elements is illegal!\n");
         return 0;
    }
    
    scanf("%d",&x);
    printf("Table A is: ");
    Display(&A);
    Intersection(&A,&B,&C);
    printf("\nThe intersection of Table A and Table B is: ");
    Display(&C);
    Move(&C,C.length,x);
    printf("\nThe Table C whose elements have been moved is: ");
    Display(&C);
    return 0;
}
```



#### 2. 2024期末 单链表应用

```c
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0
#define OVERFLOW -2
typedef int Status;
typedef int ElemType;

typedef struct LNode {
    ElemType data; //结点的数据域
    struct LNode *next; //结点的指针域
} LNode, *LinkList;


/*
敬爱的宇宙无敌好老师！！！
调了好久，测试数据都对了！！！ 
扣小分能不能温柔点，可怜可怜孩子吧！！！
小分实在实在是扣不起了，调了那么久会心疼的！！！ 
我知道您一定是全世界最好的老师！！！ 
*/


//前插法创建单链表——逆位序输入n个元素的值，建立带头结点的单链表L
Status CreateList_F(LinkList *L, int n) 
{ 
//请补全代码
    if(n<=0) 
    {
        return ERROR;
	}
        
    (*L) = (LinkList)malloc(sizeof(LNode));//初始化头结点，为头结点分配内存 
    if(!(*L))	
		return ERROR;
	(*L)->next = NULL;
	
    LinkList p = (*L);
    int i;
    for(i = 0;i < n;i ++)
    {
    	//创建新的链表结点 
    	LinkList r = (LinkList)malloc(sizeof(LNode));
		if(!r)	return ERROR;
    	scanf("%d",&r->data);
    	
    	//将新创建的结点以头插的方式与*L相连 
    	r->next = p->next;
    	p->next = r;
	}
    
    return OK;
}

//打印单链表
Status ListPrint(LinkList L)
{
//请补全代码
	if(!L)
		return ERROR; 
	LinkList p = L->next;
	while(p)
	{
		printf("%d ",p->data);
		p = p->next;
	}
	printf("\n");
	return OK;
}

//使用递归算法求单链表L数据元素之和
int ListSum(LinkList L)
{
//请补全代码
	if(!L || !L->next)
		return 0;
		
	return ListSum(L->next) + L->next->data;

}
 
int main()
{
//请补全代码
	int n;
	scanf("%d",&n);
	
	LinkList L;
	if(CreateList_F(&L, n) == OK)
	{
		printf("The linked list is: ");
		ListPrint(L);
	}
	else
	{
		printf("This is an empty List.\n");
	}
	
	
	printf("The sum of the linked list is: %d",ListSum(L));
	
	return 0;

}
```



#### 3. 2024期末 链栈及其应用

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 100
typedef int Status;
typedef char SElemType;
 
 
typedef struct StackNode{
    SElemType data;
    struct StackNode *next;
}LNode,*LinkList;
 
typedef struct{
    LinkList Head;
    int length;
          
}LinkStack;
 
Status InitStack(LinkStack *S)
{
   S->Head = (LinkList)malloc(sizeof(LNode));
   if(S->Head==NULL)
             return ERROR;
   S->Head->next = NULL;
   S->length = 0;
  
   return OK;
}
Status StackEmpty(LinkStack *S)
{
   if(S->length==0)
             return TRUE;
   else
             return FALSE;
}

/*
敬爱的宇宙无敌好老师！！！
调了好久，测试数据都对了！！！ 
扣小分能不能温柔点，可怜可怜孩子吧！！！
小分实在实在是扣不起了，调了那么久会心疼的！！！ 
我知道您一定是全世界最好的老师！！！ 
*/

//入栈操作
Status Push(LinkStack *S,SElemType e)
{   
     //请补全代码
     if(S->length >= MAXSIZE)//看到宏定义上有这个，想必这MAXSIZE有限制 
     	return ERROR;
     	
    //创建新的链表结点 
     LinkList p;
	 p = (LinkList)malloc(sizeof(LNode));
	 if(!p)
	 	return ERROR; 
	p->data = e;
	
	p->next = S->Head->next;
	S->Head->next = p;
	
	S->length ++;//更新栈的长度
	 
	return OK;	
}

//出栈操作
Status Pop(LinkStack *S,SElemType *e)
{
	if(S->length==0)
		return ERROR;
	LinkList p;
	p = S->Head->next; 
	*e=p->data;
	S->Head->next = p->next;
	free(p);
	S->length--;
	return OK;
}

//取栈顶元素
Status GetTop(LinkStack *S,SElemType *e)
{
	*e=S->Head->next->data;
	return OK;
}

// 判断两个字符 element_l 和 element_r 是否配对，如果是，返回TRUE，否则输出FALSE. 
Status match(char element_l, char element_r)
{
  //请补全代码
	if((element_l == '(' && element_r == ')' )
	|| (element_l == '{' && element_r == '}' )
	|| (element_l == '[' && element_r == ']'))
		return TRUE;

		
	return FALSE;
  
}

//使用链栈S，对字符串str中的字符进行括号匹配检查，如果全部配对，则打印Yes, 如果出现错误，则打印No, 并立即从函数返回。
void match_check(char str[], LinkStack *S)
{
   //请补全代码
   int i =0;
   for(;str[i] != '\0';i ++)
   {
   		if(str[i] == '(' || str[i] == '{' || str[i] == '[')
   			Push(S, str[i]);
   			
   		else if(str[i] == ')' || str[i] == '}' || str[i] == ']')
   		{
   			char temp;
   			if(StackEmpty(S))
   			{
   				printf("No");
   				return ;	
			}
   			GetTop(S, &temp);
   			if(match(temp, str[i]) == TRUE)
   				Pop(S, &temp);
   			else
   			{
   				printf("No");
   				return ;
			}
		}
   }
   
   if(StackEmpty(S))
   		printf("Yes");
   	else
   		printf("No");
}
 
 
int main(){
	LinkStack S;
	char str[MAXSIZE];
	InitStack(&S);
	scanf("%s", str);
	match_check(str,&S);
	return 0;
}
```



#### 4. 2024期末 二叉树的算法与应用

```c
#include<stdio.h> 
#include<stdlib.h>


//函数结果状态代码

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define OVERFLOW -1


typedef char ElemType;
typedef int Status;

//二叉树的二叉链表存储表示

typedef struct BiTNode{
    ElemType data;
    struct BiTNode *lchild,*rchild;//左右孩子指针 
}BiTNode,*BiTree; 

//数据元素类型为BiTree的队列

typedef struct QNode{
    BiTree Qdata;
    struct QNode *next;
}QNode,*QueuePtr;

typedef struct{
	QueuePtr front;
	QueuePtr rear;
}LinkQueue;

//构造一个空队列Q

Status InitQueue(LinkQueue *Q)
{
	(*Q).front=(QueuePtr)malloc(sizeof(QNode));
	if(!(*Q).front) exit(OVERFLOW);
	(*Q).front->next=NULL;
	(*Q).rear=(*Q).front;
	
	return OK;
}

//探空，前提Q存在

Status QueueEmpty(LinkQueue Q)
{

	if(Q.front==Q.rear)
	    return TRUE;
	else
	    return FALSE;
}

//插入元素e作为新的队尾元素，前提Q存在

Status EnQueue(LinkQueue *Q,BiTree e)
{

	QueuePtr p=(QueuePtr)malloc(sizeof(QNode));//开辟新结点
	
	if(!p) exit(OVERFLOW);
	
	p->Qdata=e;
	p->next=NULL;
	(*Q).rear->next=p;
	(*Q).rear=p;
	
	return OK;

}

//若队列不空，删除队头元素，用e返回其值，前提Q存在
Status DeQueue(LinkQueue *Q,BiTree *e)
{

	if((*Q).front==(*Q).rear)
	    return ERROR;
	
	QueuePtr p=(*Q).front->next;
	*e=p->Qdata;
	
	(*Q).front->next=p->next;
	if((*Q).rear==p)
	    (*Q).rear=(*Q).front;
	
	free(p);
	return OK;

}


//用先序遍历创建二叉树
Status CreateBiTree(BiTree *T)
{
	char ch = getchar();//读入一个字符
	if(ch == '.') //用.表示空节点
	{
	    *T = NULL;

	}

	else
	
	{
	
		*T = (BiTree)malloc(sizeof(BiTNode));
		
		if(!(*T))
		
			exit(OVERFLOW);
		
		(*T)->data = ch;
		
		CreateBiTree(&(*T)->lchild);
		
		CreateBiTree(&(*T)->rchild);
		
	}
	
	return OK;

}



//返回二叉树的深度
int BiTreeDepth(BiTree T)

{

      //请补齐代码
	if(!T)
		return 0;
	int height_left = BiTreeDepth(T->lchild);
	int height_right = BiTreeDepth(T->rchild);
	return (height_left > height_right ? height_left : height_right )+ 1;


}



//中序遍历二叉树
Status InOrderTraverse(BiTree T)
{

    //请补全代码
    if(T)
    {
    	InOrderTraverse(T->lchild);
    	printf("%c ",T->data);
    	InOrderTraverse(T->rchild);
	}
	return OK;

}


//层序遍历二叉树
Status LevelOrderTraverse(BiTree T)
{

	if(!T)
	    return ERROR;
	
	LinkQueue Q;
	InitQueue(&Q);
	
	BiTree p;
	
	EnQueue(&Q,T);
	
	while(QueueEmpty(Q)==FALSE)
	{
		DeQueue(&Q,&p);
		
		printf("%c ",p->data);
		
		if(p->lchild)
		    EnQueue(&Q,p->lchild);
		
		if(p->rchild)
		    EnQueue(&Q,p->rchild);
	
	}
	
	return OK;
}



//输出二叉树指定第n层的所有节点
Status LevelNodeOutput(BiTree T,int n)
{

    //补齐代码
    if(!T)
    	return ERROR;
    	
    if(n == 1)
	{
		printf("%c ",T->data);
		return OK;
	 } 
	LevelNodeOutput(T->lchild, n - 1);
	LevelNodeOutput(T->rchild, n - 1);

	return OK;
}



int main()
{

    BiTree T;

    printf("Create BiTree,please input\n");

    //ABC..DE.G..F...          可以拷贝至控制台

    //ABE.L...DHM..I..J..      可以拷贝至控制台

    CreateBiTree(&T);//按照先序遍历扩展序列创建二叉树

    int ceng;

    scanf("%d",&ceng);

    

    printf("\nInorder traversal ");//中序遍历二叉树

    InOrderTraverse(T);

    printf("\ndeepth of the BiTree  %d\n",BiTreeDepth(T));//打印树的深度
    

    printf("the node of the %d level is ",ceng);

    LevelNodeOutput(T,ceng);//输出指定层的节点

    return 0; 

}
```



#### 5. 2024期末 冒泡排序和快速排序

```c
//========================================
//【代码框架C语言版】
//=========================================
 
#include <stdio.h>


/*
敬爱的宇宙无敌好老师！！！
调了好久，测试数据都对了！！！ 
扣小分能不能温柔点，可怜可怜孩子吧！！！
小分实在实在是扣不起了，调了那么久会心疼的！！！ 
我知道您一定是全世界最好的老师！！！ 
*/

 
//冒泡排序
void BubbleSort(int arr[], int n)
{
    //★★★请补全代码
    int i, j;
    for(i = 0 ;i < n - 1;i ++)
    {
    	for(j = 0;j < n - i - 1;j ++)
    	{
    		if(arr[j] < arr[j + 1])
    		{
    			int temp = arr[j];
    			arr[j] = arr[j + 1];
    			arr[j + 1] = temp;
 			}
		}
	}
}
 
 
//划分函数，返回划分元素的位置 
int partition(int arr[], int low, int high)
{
    //★★★请补全代码
    int temp = arr[low];
    
    while(low < high)
    {
    	while((low < high) && (arr[high] >= temp)) high--;
    	arr[low] = arr[high];
    	while((low < high) && (arr[low] <= temp))	low++;
    	arr[high] = arr[low];
	}
    arr[low] = temp;
	return low;         
}    


void QuickSort(int arr[], int low, int high) 
{
	int ploc;
	if(low<high)
	{
		
		ploc=partition(arr,low,high);
		
		QuickSort(arr, low, ploc-1);
		QuickSort(arr, ploc+1, high);		
	}
} 
 

void printfArray(int arr[], int n)
{
		int i;
       if(n==0)
       {
              printf("The number of array elements is zero.\n");
              return;
       }
 
       BubbleSort(arr, n);
       printf("Array by BubbleSort are: ");
       for (i =0; i < n ;i++)
              printf("%d ", arr[i]);
       printf("\n");
      
       QuickSort(arr, 0, n-1);
       printf("Array by QuickSort are: ");
       for (i =0; i < n ;i++)
              printf("%d ", arr[i]);
       printf("\n");
}
 
 
int main()
{
       int n;
       scanf("%d", &n);
       int arr[n];
       int i;
       for (i = 0; i < n; i++)
       {
              scanf("%d", &arr[i]);
       }
       printfArray(arr, n);
       return 0;
}
 
```



#### 6. 2024期末 图的基本操作

```c
#include <stdio.h>

#define MVNum 100                    //最大顶点数
#define OK 1
#define ERROR 0
#define OVERFLOW -2
 
typedef int VerTexType;              //假设顶点的数据类型为整型 

//图的邻接矩阵存储表示
typedef struct{ 
	VerTexType vexs[MVNum];            //顶点表 
    int arcs[MVNum][MVNum];            //邻接矩阵 
    int vexnum,arcnum;                 //图的当前点数和边数 
}AMGraph;

//确定点v在G中的位置
int LocateVex(AMGraph G , VerTexType v){
	int i;
	for(i = 0; i < G.vexnum; ++i)
	    if(G.vexs[i] == v)
	        return i;
    return -1;
}


/*
敬爱的宇宙无敌好老师！！！
调了好久，测试数据都对了！！！ 
扣小分能不能温柔点，可怜可怜孩子吧！！！
小分实在实在是扣不起了，调了那么久会心疼的！！！ 
我知道您一定是全世界最好的老师！！！ 
*/


//采用邻接矩阵表示法，创建无向网G 
int CreateUDN(AMGraph *G)
{ 

 //★★★请补全代码
 	printf("Please input the total number of vertices and the total number of edges, separated by a space:\n");
 	scanf("%d %d", &G->vexnum, &G->arcnum);
 	int i = 0,j = 0;
 	getchar();
 	printf("Please input the names of the vertices, such as 1:\n");
 	for(i = 0;i < G->vexnum;i ++)
 	{
 		scanf("%d",&G->vexs[i]);
	 }
	 
	 //邻接矩阵的初始化 
	 for(i = 0;i < G->vexnum;i ++)
	 	for(j = 0;j < G->vexnum;j ++)
	 		G->arcs[i][j] = 0;
	
	printf("Please input the vertices to which the edge is attached, such as 1 2:\n");
	
 	for(i = 0;i < G->arcnum;i ++)
 	{
 		getchar();
 		int v1, v2;
 		scanf("%d %d", &v1, &v2);
 		
 		int a1 = LocateVex(*G, v1);
 		int a2 = LocateVex(*G, v2);
 		
 		G->arcs[a1][a2] = 1;
 		G->arcs[a2][a1] = 1;//无向图，重复操作 
 		
	 }

	return OK;
} 

//输出无向网G的邻接矩阵 
void OutputAdjMatrix(AMGraph G)
{ 
 //★★★请补全代码
	int i ,j;
	printf("\nThe adjacency matrix of the undirected network G is:\n");
	for(i = 0;i < G.vexnum;i ++)
	{
		for(j = 0;j < G.vexnum;j ++)
		{
			printf("%d  ",G.arcs[i][j]);
		}
		printf("\n");
	}
	printf("\n");
}

//输出无向网G的各顶点的度 
void OutputDegree(AMGraph G)
{ 
 //★★★请补全代码

	int total, i, j;
	for(i = 0;i < G.vexnum;i ++)
	{
		total = 0;//作每个顶点的度的计数器，每次循环都更新一遍 
		for(j = 0;j < G.vexnum;j ++)
		{
			if(G.arcs[i][j] != 0)//有相连即加1 
				total ++;
		}
		printf("The degree of vertex %d is %d\n", G.vexs[i], total);
	}


}

int main(){
    AMGraph G;
    CreateUDN(&G);
    OutputAdjMatrix(G);
    OutputDegree(G);
    return 0;
}
```





#### 7. 2024期末 综合题7.1 - 高效查找、插入与删除 - 有序链表数据插入

```c
#include<stdio.h>
#include<stdlib.h>
#define OK 1
#define ERROR 0
typedef int Status;

typedef struct Lnode
{
    int data;
    struct Lnode *next;
} LNode;
typedef struct Lnode *LinkList;

Status InitList(LinkList *L)
{
    *L = (LinkList)malloc(sizeof(LNode));
    if (!(*L))
        return 0;
    (*L)->next = NULL;
    return 1;
}

/* 将输入数据e按序插入到一个升序有序的链表L中 */
Status SortInsert(LinkList *L, int e)
{
    //★★★请补全代码
    LinkList r ;
    r = (LinkList)malloc(sizeof(LNode));
    if(!r)
    {
    	return ERROR;
	}
	r->data = e;
	
	LinkList p = (*L);
	if(p->next)
	{
		while(p->next && p->next->data < e)
		{
			p = p->next;
		}
	}
	
	r->next = p->next;
	p->next = r;
	
	return OK;   
}

Status Display(LinkList L)
{
    LNode *p = L->next;
    while (p)
    {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
    return OK;
}

int main()
{
    LinkList L;
    int elem;
    InitList(&L);
    scanf("%d", &elem);
    while(elem != -1)
    {
        SortInsert(&L, elem);
        scanf("%d", &elem);
    }
    Display(L);
    return 0;
}
```



#### 8. 2024期末 综合题7.2 - 高效查找、插入与删除 - 跳表数据查找与插入

```c
//========================================================
//     代码框架 C语言版
//========================================================

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#define MAX_LEVEL 4  /*跳表最大层数*/
typedef struct skip_list_node
{
	int key;    /*key是唯一的*/
	int value; 	/*存储的内容*/
	int level; 	/*当前节点最大层数*/
	/*指针数组,根据该节点层数的不同分配大小不同的数组
	 *next[0]表示该节点的第一层下一节点的地址
	 *next[1]表示该节点的第二层下一节点的地址
	 *next[n]表示该节点的第n层下一节点的地址
	 */
	struct skip_list_node *next[];
} skip_list_node;

typedef struct skip_list
{
	int level; /*跳表层数*/
	int num;   /*节点数目*/
	struct skip_list_node *head;
} skip_list;

/**
 * 生成表节点.
 * 
 * 返回：
 *  NULL:内存申请失败
 * !NULL:节点创建成功
 */
static skip_list_node* skip_list_node_creat(int level, int key, int value)
{
	struct skip_list_node *node = NULL;
	
	/* 节点空间大小 为节点数据大小+ level层索引所占用的大小 */
	node = (skip_list_node*)malloc(sizeof(skip_list_node) + level * sizeof(skip_list_node*));
	if (node == NULL)
		return NULL;
	
	/* 赋值 */
	node->key = key;
	node->value = value;
	node->level = level;
	int i;
    for(i=0; i<level; i++)
    {
    	 node->next[i] = NULL;
	}	
	return node;
}

/**
 * 跳表初始化.
 * 输入
 * level:跳表最大层数
 * 返回
 * -1 :创建失败
 *  0 :创建成功
 */
int skip_list_init(skip_list *L, int level)
{	
	L->level = level;
	L->num = 0;
    // L->head =(skip_list_node*)malloc(sizeof(skip_list_node)+(level)*sizeof(skip_list_node*));
    L->head = skip_list_node_creat(level, 0, 0);
	if (L->head == NULL)
	{
		return -1;
	}
	return 0;
}

/**
 * 插入跳表节点.
 * 输入：
 * list:跳表
 * key:
 * value:
 * 返回 -1:跳表为空
 *     -2:空间分配失败
 *     -3:key已经存在
 *      0:插入成功
 */
int skip_list_insert(struct skip_list *list, int level, int key, int value)
{
	struct skip_list_node **update = NULL; /*用来更新每层指针，存放插入位置的前驱各层节点*/ 
	struct skip_list_node *cur = NULL;
	struct skip_list_node *prev = NULL;
	struct skip_list_node *insert = NULL;
	int i = 0;
	
	if (list == NULL || level <0 || level > MAX_LEVEL)
		return -1;
	
	/*申请update空间用于保存每层的但插入位置前驱节点*/
	update = (skip_list_node **)malloc(list->head->level * sizeof(struct skip_list_node *));
	if (update == NULL)
		return -2;
	
	/*逐层查询,查找插入位置的前驱各层节点索引
	 *update[0] 存放第一层的插入位置前驱节点，update[0]->next[0]表示插入位置的前驱节点的下一节点(update[0]->next[0])的第一层索引值
	 *update[1] 存放第二层的插入位置前驱节点，update[1]->next[1]表示插入位置的前驱节点的下一节点(update[1]->next[0])的第二层索引值
	 *update[n] 存放第一层的插入位置前驱节点，update[n]->next[n]表示插入位置的前驱节点的下一节点(update[n]->next[0])的第n层索引值
	 */
	prev = list->head; /*从第一个节点开始的最上层开始找*/
	i = list->level - 1;
	for(; i>=0; i--)
	{
		/* 各层每个节点的下一个节点不为空 && 下个节点的key小于要插入的key */
		while ( ((cur = prev->next[i]) != NULL) && (cur->key < key) )
		{
			prev = cur; /* 向后移动 */
		}
		update[i] = prev; /* 各层要插入节点的前驱节点 */
	}
	
	/* 当前key已经存在,返回错误 */
	if ((cur != NULL) && (cur->key == key))
	{
		return -3;
	}
	
	/*创建当前节点*/
	insert = skip_list_node_creat(level, key, value);
	/*根据最大索引层数,更新插入节点的前驱节点,前面已经更新到了[0] - [(list->level-1)]*/
	if (level > list->level)
	{
		for (i=list->level; i<level; i++)
		{
			update[i] = list->head;/*这部分为多新增的索引层,所以前驱节点默认为头结点*/
		}
		list->level = level;/*更新跳表的最大索引层数*/
	}
	
	/*逐层更新节点的指针*/
	for (i=0; i<level; i++)
	{
		insert->next[i] = update[i]->next[i];
		update[i]->next[i] = insert;
	}
	
	/*节点数目加1*/
	list->num++;
	
	return 0;
}

/**
 * 查询当前key是否在跳表中,存在返回查询的value数值.
 * 
 * list:跳表
 * key: 查询的key
 * value:查询的数据
 * 返回值 -1:跳表为空 或 跳表节点数量为0
 *         -3:key不存在
 *          0:查找成功
 */
int skip_list_search(skip_list *list, int key, int *value)
{
/*
敬爱的宇宙无敌超级好老师！！！
调了好久，测试数据都对了！！！ 
扣小分可以温柔点吗，可怜可怜孩子吧！！！
小分实在实在是扣不起了，调了那么久会心疼的！！！ 
我知道您一定是全世界最好的老师！！！ 
*/
	
	//★★★请补全代码

	struct skip_list_node *cur = NULL;
	struct skip_list_node *prev = NULL;

	int i = 0;
	
	if (list == NULL || list->num == 0)
		return -1;//表为空 或 跳表节点数量为0
	
	prev = list->head; /*从第一个节点开始的最上层开始找*/
	i = list->level - 1;
	for(; i>=0; i--)
	{
		/* 各层每个节点的下一个节点不为空 && 下个节点的key小于要插入的key */
		while ( ((cur = prev->next[i]) != NULL) && (cur->key < key) )
		{
			prev = cur; /* 向后移动 */
		}
	}
	 if (cur->key == key)
	{//如果找到key，则将cur->value赋值给*value
	//并返回0 ，表示查找成功 
		*value = cur->value;
		return 0;
	}
	
	//如果最终没有找到，则返回-3 
	return -3;
}

/* 打印level层所有元素 */
void display(skip_list *list, int level)
{
    skip_list_node *cur;
    if (list == NULL && list->num == 0)
        return;
    if (level<0 || level > list->level)
        return;
    cur = list->head->next[level];
    while(cur)
    {
        printf("%d:%d\n", cur->key, cur->value);
        cur = cur->next[level];
    }
}

int main()
{
    skip_list list;
    int key;
    int value;
    int level;
    int i;
    
    skip_list_init(&list, MAX_LEVEL);
    scanf("%d%d%d", &level, &key, &value);
    while(level>0 || level>MAX_LEVEL)
    {
        skip_list_insert(&list, level, key, value);
        scanf("%d%d%d", &level, &key, &value);
    }
    printf("the number of nodes is %d\n", list.num);
    for(i=0; i<MAX_LEVEL; i++)
    {
        printf("the node of level %d\n", i);
        display(&list, i);
    }
    scanf("%d", &key);
    int res = skip_list_search(&list, key, &value);
    if(res == -1)
        printf("skip list is empty\n");
    else if(res == -3)
        printf("key not found\n");
    else
        printf("key found %d:%d\n", key, value);

    return 0;
}
```

