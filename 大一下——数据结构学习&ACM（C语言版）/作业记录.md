### 作业1——C语言复习

#### 1. ACM2024-第一章-C语言回顾-结构体2

#### 2. ACM2024-第一章-C语言回顾-结构体2

#### 3. ACM2024-第一章-C语言回顾-结构体1

#### 4. ACM2024-第一章-C语言回顾-数组最大值

#### 5. ACM2024-第一章-C语言回顾-数组1



### 作业2——顺序表



#### 1. ACM2023-第二章-线性表-交叉合并两个顺序表- LJD



```c
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0
#define MAXSIZE 20

typedef int Status;
typedef int ElemType;

typedef struct {
    ElemType data[MAXSIZE];
    int length;
} SqList;

// 遍历顺序表并打印元素
void TraverseList(SqList L) 
{
    for (int i = 0; i < L.length; i++) 
    {
        printf("%d ", L.data[i]);
    }
    printf("\n");
}

// 获取顺序表的长度
int GetListLength(SqList L) 
{
    return L.length;
}

// 获取指定位置的元素值
Status GetElemAt(SqList L, int i, ElemType *e) 
{
    if (i < 1 || i > L.length)
        return ERROR;
    *e = L.data[i - 1];
    return OK;
}

// 在指定位置插入元素
Status InsertIntoList(SqList *L, int i, ElemType e) 
{
    if (L->length >= MAXSIZE || i < 0 || i > L->length)
        return ERROR;
    for (int k = L->length - 1; k >= i; k--) 
    {
        L->data[k + 1] = L->data[k];
    }
    L->data[i] = e;
    L->length++;
    return OK;
}

// 将两个顺序表的元素交错到第三个顺序表中
void InterleaveLists(SqList *L3, SqList L1, SqList L2) 
{
    int i = 1;
    int e;
    while (i <= L1.length || i <= L2.length) 
    {
        int tag = i;//作为判断标志	是否已经插了L1	矫正i 的值
        if (i <= L1.length) 
        {
            GetElemAt(L1, i, &e);
            InsertIntoList(L3, L3->length, e);
            i++;
        }
        if (i - 1 <= L2.length) 
        {
            if (tag != i) i--;
            GetElemAt(L2, i, &e);
            InsertIntoList(L3, L3->length, e);
            i++;
        }
    }
}

int main() 
{
    SqList L1, L2, L3;
    Status i;
    int j, k, l;

    // 输入并创建第一个顺序表
    scanf("%d", &k);
    L1.length = 0;
    if (k > 0)
        for (j = 1; j <= k; j++) 
        {
            scanf("%d", &l);
            i = InsertIntoList(&L1, 0, l);
        }

    // 打印第一个顺序表及其长度
    TraverseList(L1);
    printf("%d \n", GetListLength(L1));

    // 输入并创建第二个顺序表
    scanf("%d", &k);
    L2.length = 0;
    if (k > 0)
        for (j = 1; j <= k; j++) 
        {
            scanf("%d", &l);
            i = InsertIntoList(&L2, 0, l);
        }

    // 打印第二个顺序表及其长度
    TraverseList(L2);
    printf("%d \n", GetListLength(L2));

    // 将两个顺序表的元素交错到第三个顺序表中
    L3.length = 0;
    InterleaveLists(&L3, L1, L2);

    // 打印交错后的顺序表及其长度
    TraverseList(L3);
    printf("%d \n", GetListLength(L3));

    return OK;
}

```



#### 2. ACM2023-第二章-线性表-顺序表的各种操作练习- LJD



```c
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE 0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
typedef int ElemType;

#define INIT_SIZE 100       // 初始分配空间的大小
#define LISTINCREMENT 10    // 分配增量

typedef struct {
    ElemType *elem;         // 存储空间的起始地址
    int length;             // 线性表中数据元素个数，即表长
    int listsize;           // 线性表所申请的存储空间的大小
} SqList;

// 创建一个空的线性表
SqList CreateList_Sq(SqList L)
{
    L.elem = (ElemType*)malloc(100 * sizeof(ElemType));  // 申请空间
    L.length = 0;         // 表长为0
    L.listsize = 100;     // 申请的空间为初始大小
    return L;
}

// 在线性表的第i个位置前插入元素e
void InsertList_Sq(SqList *L, int i, ElemType e)
{
    int *newbase, *q, *p;
    if ((i < 1) || (i > L->length + 1)) 
    {
        printf("i值不合法!\n");
        exit(ERROR);
    }
    // 当前空间已满，增加分配空间
    if (L->length >= L->listsize) 
    {   
        newbase = (ElemType*)realloc(L->elem, (L->listsize + LISTINCREMENT) * sizeof(ElemType));
        if (!newbase) exit(ERROR);
        L->elem = newbase;
        L->listsize = L->listsize + LISTINCREMENT;
    }
    //检查完错误	开始插值
    int j;
    for (j = L->length - 1; j >= i - 1; j--) 
    {
        L->elem[j + 1] = L->elem[j]; // 将元素后移
    }
    L->elem[i - 1] = e;
    L->length++;//插完后	莫忘更新线性表的长度
    return OK;
}

// 删除线性表中的第i个元素
void DeleteList_Sq(SqList *L, int i)
{
    int j;
    if ((i < 1) || (i > L->length)) {
        printf("i值不合法!\n");
        exit(ERROR);
    }
    for (j = i; j < L->length; j++) {
        L->elem[j - 1] = L->elem[j];
    }
    L->length--;
}

// 遍历顺序线性表并输出
void Print_Sq(SqList L)
{
    int i;
    for (i = 0; i < L.length; i++) {
        printf("%3d ", L.elem[i]);
    }
}

// 判两个元素是否相等
int equal(ElemType e1, ElemType e2)
{
    if (e1 == e2) return 1;
    else return 0;
}

// 查找元素在顺序表中的位置
int LocateElem_Sq(SqList L, ElemType e, int (* compare)(ElemType e1, ElemType e2))
{
    int i = 0;
    for (; i < L.length; i++) {
        if (compare(L.elem[i], e)) return i + 1;
    }
    return ERROR;
}

void Getelem(SqList L, int i, ElemType *e)
{
    if (i < 1 || i > L.length) return;
    *e = L.elem[i - 1];
    return;
}

int main()
{
    int i;
    ElemType e;
    SqList Lq;
    Lq = CreateList_Sq(Lq);
    InsertList_Sq(&Lq, 1, 21);
    InsertList_Sq(&Lq, 2, 18);
    InsertList_Sq(&Lq, 3, 30);
    InsertList_Sq(&Lq, 4, 75);
    InsertList_Sq(&Lq, 5, 42);
    InsertList_Sq(&Lq, 6, 56);
    printf("初始顺序表为\n");
    Print_Sq(Lq);
    InsertList_Sq(&Lq, 3, 67);
    printf("\n插入67后顺序表为\n");
    Print_Sq(Lq);
    DeleteList_Sq(&Lq, 6);
    printf("\n删除第6个元素后顺序表为\n");
    Print_Sq(Lq);
    if ((i = LocateElem_Sq(Lq, 75, equal)))
        printf("\n存在元素75且位置为%d\n", i);
    else
        printf("\n不存在元素75\n");
    free(Lq.elem);
    return 1;
}

```



#### 3. ACM2023-第二章-顺序表练习题 -合并两有序表 - LJD



```c
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE 0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10
typedef int ElemType;

typedef struct {
    ElemType *elem;
    int length;
    int listsize;
} SqList;

// Create an empty list
Status InitList_Sq(SqList *L)
{
    //学生添加
    L->elem = (int*)malloc(INIT_SIZE*sizeof(int));
    if (!L->elem) return OVERFLOW;
    L->length = 0;
    L->listsize = INIT_SIZE; 
}

// Create an array based list with n elements
Status CreateList_Sq(SqList *L, int a[], int n)
{
    //学生添加
    int j = 0;
    for(; j < n; j++)
    {
        L->elem[j] = a[j];
    }
    L->length = n;
}

// Get Element
Status GetElem(SqList L, int i, int *e)
{
    //学生添加
    if(i < 1 || i > L.length) return ERROR;
    *e = L.elem[i - 1];
    return OK;
}

// Insert
Status ListInsert(SqList *L, int i, int e)
{
    //学生添加
    if(i < 1 || i > L->length + 1) return ERROR;
    if(L->length == L->listsize) return ERROR;
    int j = L->length - 1;
    for(; j >= i - 1; j--)
    {
        L->elem[j + 1] = L->elem[j];
    }
    L->elem[i - 1] = e;
    L->length++;
    return OK;
}

// Merge two sequential lists 
Status MergeList_Sq(SqList L1, SqList L2, SqList *L3)
{  
    //学生添加
    int i = 0, j = 0, k = 0;
    
    
    while(i < L1.length && j < L2.length)
    {
        if(L1.elem[i] <= L2.elem[j])
        {
            L3->elem[k++] = L1.elem[i++];
        }
        else
        {
            L3->elem[k++] = L2.elem[j++];
        }
    }
    while(i < L1.length)
    {
        L3->elem[k++] = L1.elem[i++];
    }
    while(j < L2.length)
    {
        L3->elem[k++] = L2.elem[j++];
    }
    L3->length = k;
    
    
    //上面的三个while循环逻辑更加清晰	
    //下面一个看着很复杂
    //while (L3->length < L1.length + L2.length)
    //{
    //	if (len1 < L1.length && (L1.elem[len1] <= L2.elem[len2] || len2 >= L2.length))
    //	{
    //		L3->elem[len3++] = L1.elem[len1++];
    //		L3->length++;
    //	}
    //	else if (len2 < L2.length && (L2.elem[len2] < L1.elem[len1] || len1 >= L1.length))
    //	{
    //		L3->elem[len3++] = L2.elem[len2++];
    //		L3->length++;
    //	}
    //}
    
}

// Print out all elements
void PrintList_Sq(SqList L)
{ 
    //学生添加
    int j = 0;
    for(; j < L.length; j++)
    {
        printf("%d ", L.elem[j]);
    }
}

int main()
{
    int n1, n2, i, j;
    int a[20], b[20];
    SqList L1, L2, L3;

    scanf("%d", &n1);
    for(i = 0; i < n1; i++)
    {
        scanf("%d", &a[i]);
    }
    scanf("%d", &n2);
    for(i = 0; i < n2; i++)
    {
        scanf("%d", &b[i]);
    }

    InitList_Sq(&L1);
    InitList_Sq(&L2);
    InitList_Sq(&L3);

    CreateList_Sq(&L1, a, n1);
    CreateList_Sq(&L2, b, n2);

    MergeList_Sq(L1, L2, &L3);

    PrintList_Sq(L3);

    return 0;
}

```



#### 4. ACM2023-第二章-顺序表练习题 -删除顺序表指定位置n后的m个元素 - LJD



```C
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE  0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10  
typedef int ElemType;

typedef struct
{
    ElemType *elem;
    int length;
    int listsize;
}SqList;

// Initialize an empty list
Status InitList_Sq(SqList *L)
{
 //学生添加
 	L->elem = (int*)malloc(INIT_SIZE * sizeof(int));
    if (!L->elem) return OVERFLOW;
 	L->length = 0;
 	L->listsize = INIT_SIZE;
}
//Create an array based list with n elements
Status CreateList_Sq(SqList *L, int a[], int n)
{
 //学生添加
	int i = 0;
	for(;i < n;i ++)
	{
		L->elem[i] = a[i]; 
	}
	L->length = n;
    return OK;
}

// Delete the ith elements of sequential list L
Status DeleteList_Sq(SqList *L, int m,int k)
{    
 //学生添加
       if (m < 0 || m > L->length || k < 0)
        return ERROR;
 	int i = 0; 	
 	for(;m < L->length - k;m ++)
 	{
 		L->elem[m] = L->elem[m + k];
	 }
	 L->length -=k;
}

//print out all elements
void PrintList_Sq(SqList L)
{ 
 //学生添加
	 int i = 0;
	 for(;i < L.length;i ++)
	 {
	 	printf("%d ",L.elem[i]); 
	 }
}

int main()
{ 
	int n;
	scanf("%d",&n);
	int i,arr[n];
	for(i = 0;i < n;i ++)
	{
		scanf("%d",&arr[i]);
	 }
    
	 SqList sq;
	 InitList_Sq(&sq);	 
	 CreateList_Sq(&sq,arr,n);
	 
	 int m,k; 
	 scanf("%d%d",&m,&k);
	 
	 DeleteList_Sq(&sq,m,k);
	 
	 PrintList_Sq(sq);	 
	 return 0;
}

```



#### 5. ACM2023-第二章-顺序表练习题 -就地逆置顺序表 - LJD



```c
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE  0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10  
typedef int ElemType;

typedef struct {
    ElemType *elem;
    int length;
    int listsize;
} SqList;

// Create an empty list
Status InitList_Sq(SqList *L)
{
    //学生添加
    L->elem = (int*)malloc(INIT_SIZE * sizeof(int));
    L->length = 0;
    L->listsize = INIT_SIZE;
}

// Create an array based list with n elements
Status CreateList_Sq(SqList *L, int a[], int n)
{
    //学生添加
    int i = 0;
    for(; i < n; i++)
    {
        L->elem[i] = a[i];
    }
    L->length = n;
}

// Reverse the elements of sequential list L
void swap(int *a, int *b)
{
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;	
}

Status ReverseList_Sq(SqList *L)
{    
    //学生添加
    int i = 0;
    for(; i < L->length / 2; i++)
    {
        swap(&L->elem[i], &L->elem[L->length - i - 1]); 
    }
    return OK;
}

// print out all elements
void PrintList_Sq(SqList L)
{ 
    //学生添加
    int i = 0;
    for(; i < L.length; i++)
    {
        printf("%d ", L.elem[i]);
    }
}

int main()
{ 
    //学生添加
    int n;
    scanf("%d", &n);
    int arr[n];
    int i = 0;
    for(; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }
    SqList sq;
    InitList_Sq(&sq);
    CreateList_Sq(&sq, arr, n);
    ReverseList_Sq(&sq);
    PrintList_Sq(sq);
    return 0;
}

```



#### 6. ACM2023-第二章-顺序表练习题 -顺序表排序 - LJD



```C
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE 0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10  
typedef int ElemType;

typedef struct{
    ElemType *elem;
    int length;
    int listsize;
} SqList;

// Create an empty list
Status InitList_Sq(SqList *L)
{
    //学生添加
    L->elem = (int*)malloc(INIT_SIZE*sizeof(int));
    L->length = 0;
    L->listsize = INIT_SIZE;
}

// Create an array based list with n elements
Status CreateList_Sq(SqList *L, int a[], int n)
{
    //学生添加
    int i = 0;
    for(; i < n; i++)
    {
        L->elem[i] = a[i];
    }
    L->length = n;
}

// Sort the elements of sequential list L into ascending order
Status SortList_Sq(SqList *L)
{    
    //学生添加
    int i = 0, j = 0;
    for(; i < L->length - 1; i++)
    {
        for(j = 0; j < L->length - i - 1; j++)
        {
            if(L->elem[j] > L->elem[j + 1])
            {
                int temp = L->elem[j];
                L->elem[j] = L->elem[j + 1];
                L->elem[j + 1] = temp;
            }
        }
    }
}

// Print out all elements
void PrintList_Sq(SqList L)
{ 
    //学生添加
    int i = 0;
    for(; i < L.length; i++)
    {
        printf("%d ", L.elem[i]);
    }
}

int main()
{ 
    //学生添加
    int n;
    scanf("%d", &n);
    int i = 0, arr[n];
    for(; i < n; i++)
    {
        scanf("%d", &arr[i]);
    } 
    SqList sq;
    InitList_Sq(&sq);
    CreateList_Sq(&sq, arr, n);
    SortList_Sq(&sq);
    PrintList_Sq(sq);
    return 0;
}

```



#### 7. ACM2023-第二章-顺序表练习题 -在顺序表的指定位置插入指定元素 -LJD

```c
#include <stdio.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10  
typedef int ElemType;

typedef struct {
    ElemType *elem;
    int length;
    int listsize;
} SqList;

// 创建一个空的顺序表
Status InitList_Sq(SqList *L) 
{
    L->elem = (int *)malloc(INIT_SIZE * sizeof(int));
    if (!L->elem) 
    {
        printf("Memory allocation failed.\n");
        return OVERFLOW;
    }
    L->length = 0;
    L->listsize = INIT_SIZE;
    return OK;
}

// 创建一个带有 n 个元素的数组列表
Status CreateList_Sq(SqList *L, int a[], int n) 
{
    if (n > INIT_SIZE) 
    {
        printf("The number of elements exceeds the initial size.\n");
        return ERROR;
    }
    int i;
    for (i = 0; i < n; i++) 
    {
        InsertList_Sq(L, i + 1, a[i]);
    }
    return OK;
}

// 在顺序表 L 的特定位置插入元素
Status InsertList_Sq(SqList *L, int i, ElemType e) 
{    
    if (i < 1 || i > L->length + 1) 
    {
        printf("Invalid position.\n");
        return ERROR;
    }
    if (L->length >= L->listsize) 
    {
        printf("The list is full. No more space to insert.\n");
        return OVERFLOW; // 检查是否需要扩展顺序表的空间
    }
    int j;
    for (j = L->length - 1; j >= i - 1; j--) 
    {
        L->elem[j + 1] = L->elem[j]; // 将元素后移
    }
    L->elem[i - 1] = e;
    L->length++;
    return OK;
}

// 打印所有元素
void PrintList_Sq(SqList L) 
{
    int i;
    for (i = 0; i < L.length; i++) 
    {
        printf("%d ", L.elem[i]); 
    }
    printf("\n");
}

int main() 
{
    int n, e, k;
   // printf("Enter the number of elements: ");
    scanf("%d", &n);
    if (n <= 0) 
    {
       // printf("Invalid number of elements.\n");
        return ERROR;
    }
    int i, arr[n];
    //printf("Enter the elements: ");
    for (i = 0; i < n; i++) 
    {
        scanf("%d", &arr[i]);
    }
    SqList sq;
    if (InitList_Sq(&sq) != OK) 
    {
        return ERROR;
    }
    if (CreateList_Sq(&sq, arr, n) != OK) 
    {
        return ERROR;
    }
    //printf("Enter the element and the position to insert: ");
    scanf("%d%d", &e, &k);
    if (InsertList_Sq(&sq, k, e) != OK) 
    {
        return ERROR;
    }
    //printf("The list after insertion: ");
    PrintList_Sq(sq);
    return 0;
}

```

### 作业3——链表



#### 单链表学习代码：

```c
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0

typedef int ElemType;
typedef int Status;

typedef struct LNode
{
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// Initialize a linked list
Status InitList(LinkList *L)
{
    *L = (LinkList)malloc(sizeof(LNode));
    if (!(*L)) return ERROR;
    (*L)->next = NULL;
    return OK;
}

// Get the value at a given position
Status GetElem(LinkList L, int i, ElemType *e)
{
    LNode *p = L->next;
    int j = 1;
    while (p && j < i)
    {
        p = p->next;
        ++j;
    }
    if (!p || j > i) return ERROR;
    *e = p->data;
    return OK;
}

// Locate the element with a given value
LinkList LocateElem(LinkList L, ElemType e)
{
    LinkList p = L->next;
    while (p && p->data != e)
    {
        p = p->next;
    }
    return p;
}

// Insert an element at a given position
Status ListInsert(LinkList *L, int i, ElemType e)
{
    LinkList p = *L;
    int j = 0;
    while (p && j < i - 1)
    {
        p = p->next;
        ++j;
    }
    if (!p || j > i - 1) return ERROR;
    LinkList s = (LinkList)malloc(sizeof(LNode));
    if (!s) return ERROR;
    s->data = e;
    s->next = p->next;
    p->next = s;
    return OK;
}

// Delete the element at a given position
Status ListDelete(LinkList L, int i)
{
    LinkList p = L;
    int j = 0;
    while (p->next && j < i - 1)//循环终止后  p指向的第 i - 1个位置的结点
    {
        p = p->next;
        ++j;
    }
    if (!(p->next) || j > i - 1) return ERROR;//前者便是的是此链表最大长度小于 i，没有第i 个结点
    LinkList q = p->next;
    p->next = q->next;//不能直接使用p->next->next，会造成p->next的内存地址无法找到，内存泄漏
    free(q);
    return OK;
}

// Display the elements in the linked list
void DisplayList(LinkList L)
{
    LinkList p = L->next;
    while (p)
    {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}


/*逆序创建链表通常是为了更高效地插入元素。在逆序创建链表时，我们可以直接将新元素插入链表的头部，而不需要遍历整个链表找到尾部再插入。这样做的好处是，每次插入操作的时间复杂度为O(1)，而不是O(n)，因为不需要遍历链表。

如果采用正序创建链表，每次插入元素都需要遍历到链表的尾部，时间复杂度为O(n)，这在插入大量元素时会导致性能下降。*/

// Create a linked list with elements in reverse order
Status InverseCreateList(LinkList L, ElemType a[], int n)
{
    LNode *r = L;
    int i = 0;
    for(; i < n; i++)
    {
        LNode *p ;
        p = (LNode*)malloc(sizeof(LNode));
        p->data = a[n - i - 1]; // Insert elements in reverse order
        p->next = NULL;
        r->next = p; // Insert p into the linked list
        r = p; // Update r to point to p
    }
    return OK;
}

Status CreateList_L(LinkList L, ElemType a[ ], int n)
{
    LNode *r = L;
    int i = 0;
    for(;i < n;i ++)
    {
        LNode *p ;
        p = (LNode*)malloc(sizeof(LNode));//初始化指针，为其分配内存空间，防止出现内存泄漏和未定义行为
        p->data = a[i];//正序时：a[i]   逆序时：a[n - i - 1]
        p->next = NULL;
        r->next = p;//将p插入链表中
        r = p;//更新r的结点，变成指向p的结点
    }
    return OK;
}


//利用头插法对单链表进逆序
void reverse_List(LinkList L)
{
    LNode* p, * q, * r;
    q = L->next;
    p = L->next->next;
    while (p)
    {
        r = p->next;
        p->next = L->next;
        L->next = p;
        //p = p->next;之所以不能这样做，是因为p->next在之前被改了
        //这也是为什么需要额外的一个r来记录p->next
        p = r;
    }
    q->next = NULL;
}

int main()
{
    LinkList L;
    if (InitList(&L) == OK)
    {
        printf("List initialized successfully.\n");

        // Example usage
        ListInsert(&L, 1, 10);
        ListInsert(&L, 2, 20);
        ListInsert(&L, 3, 30);
        printf("Inserted elements: ");
        DisplayList(L);

        ElemType e;
        if (GetElem(L, 2, &e) == OK)
            printf("Element at position 2: %d\n", e);

        LinkList found = LocateElem(L, 20);
        if (found)
            printf("Element 20 found.\n");

        if (ListDelete(L, 2) == OK)
        {
            printf("Deleted element at position 2.\n");
            printf("Current list: ");
            DisplayList(L);
        }

        // Create a linked list with elements in reverse order
        ElemType arr[] = {1, 2, 3, 4, 5};
        if (InverseCreateList(L, arr, 5) == OK)
        {
            printf("Linked list created in reverse order: ");
            DisplayList(L);
        }
    }
    else
    {
        printf("Failed to initialize list.\n");
    }

    return 0;
}

```



#### 1.两个递增有序链表求交集

```c
#include <stdio.h>  
#include <stdlib.h>  

#define ERROR 0
#define OK 1

typedef int ElemType;  
typedef int Status; 

// definition of node structure of singly linked list
typedef struct LNode
{  
    ElemType data;           // data field
    struct LNode *next;      // pointer field
} LNode, *LinkList;

//===========================================
// Initialize a singly linked list L with head node
//===========================================
Status InitList_L(LinkList *L)//在初始化链表时，需要修改链表的头指针，所以需要传入的参数是指针的指针的类型
{
    *L = (LinkList)malloc(sizeof(LNode));
    if (!(*L)) return ERROR;
    (*L)->next = NULL;
    return OK;
}

//===========================================
// Create a singly linked list L with head node, and with n elements
//===========================================
Status CreateList_L(LinkList L, ElemType a[], int n)
{
    LNode *r = L;
    int i = 0;
    for (; i < n; i ++)
    {
        LNode *p = (LNode*)malloc(sizeof(LNode));
        if (!p) return ERROR;
        p->data = a[i];
        p->next = NULL;
        r->next = p;
        r = p;
    }
    return OK; 
}

//======================================
// Insert an element in a list
//=======================================
Status ListInsert_L(LinkList L,int i,ElemType e)
{
	LinkList r = L;
	int j = 0;
	while(r && j < i - 1)
	{
		r = r->next;
		++j;
	}
	if(!r || j > i - 1) return ERROR;
	LinkList s = (LNode*) malloc(sizeof(LNode));
	if(!s) return ERROR;
	s->data = e;
	s->next = r->next;
	r->next = s;
	r = s;
	return OK;
}

//===========================================
// 求两个递增链表La和Lb的交集，得到一个新的链表Lc
//===========================================
Status ListIntersection_L(LinkList La, LinkList Lb, LinkList Lc)
{
    int len_c = 0;
    LNode *ra = La->next;
    LNode *rb = Lb->next;
    LNode *rc = Lc; // 指向 Lc 的头结点
    while (ra && rb)
    {
        if (ra->data > rb->data) rb = rb->next;
        else if (ra->data < rb->data) ra = ra->next;
        else
        {
            ListInsert_L(Lc,++len_c,rb->data);
            //如果不用上面的插入函数，就直接插，
//			LNode *s ;
//			s = (LNode*)malloc(sizeof(LNode));
//			s->data = ra->data;
//			s->next = NULL;
//			rc->next = s;
//			rc = s;
            ra = ra->next;
            rb = rb->next;
        }
    }
    return OK;
}

//===========================================
// Print the elements in a list
//===========================================
void LinkedListPrint(LinkList L)
{
    if (L->next == NULL)//鲁棒性问题，
    {
        return;
    }
    LinkList p = L->next;
    while(p)
    {
        printf("%d ",p->data);
        p = p->next;
    }
    printf("\n");
}

int main()  
{  
    int n, m;
    LinkList La, Lb, Lc;
    //初始化指针，修改了链表的头指针，故要传入指针的指针的类型
    InitList_L(&La);
    InitList_L(&Lb);
    InitList_L(&Lc);
    
    scanf("%d", &n);
    int a[n];
    for (int i = 0; i < n; i++)
        scanf("%d", &a[i]);
    CreateList_L(La, a, n);
    
    scanf("%d", &m);
    int b[m];
    for (int i = 0; i < m; i++)
        scanf("%d", &b[i]);
    CreateList_L(Lb, b, m);

    ListIntersection_L(La, Lb, Lc);

    LinkedListPrint(Lc);
    
    return 0;
}

```



#### 2.将链表的最小值移动到链表的头部

```c
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

#define ERROR 0
#define OK 1

typedef int ElemType;
typedef int Status;

// Definition of a node structure for a singly linked list
typedef struct L_node 
{
    ElemType data;           // Data field
    struct L_node *next;     // Pointer field
} LNode, *LinkedList;

//===========================================
// Initialize a singly linked list L with a head node
//===========================================
Status InitList_L(LinkedList *L)
{
    *L = (LNode*)malloc(sizeof(LNode));
    if (!(*L))     return ERROR;
    (*L)->next = NULL;
    return OK;
}

//===========================================
// Create a singly linked list L with a head node, and with n elements
//===========================================
Status CreateList_L(LinkedList *L, ElemType a[], int n)
{
    if (n <= 0)    return ERROR;
    LNode *r = *L;  // r points to the head node
    int j = 0;
    for (; j < n; j++)
    {
        LNode *p = (LNode*)malloc(sizeof(LNode));  // Create a new node
        if (!p)   return ERROR; 
        p->data = a[j];  // Assign data to the new node
        p->next = NULL;  // Set next pointer to NULL

        r->next = p;     // Link the new node to the list
        r = p;           // Move r to the newly added node
    }
    return OK;
}

//===========================================
// Find the minimum value in an array
//===========================================
int find_Min(int arr[], int n)
{
    int min = arr[0], i = 1;
    for (; i < n; i++)
    {
        if (arr[i] < min)     min = arr[i];
    }
    return min;
}

//===========================================
// Move the node containing the minimum value to the head of the linked list
//===========================================
void MoveMinNode_L(LinkedList L, ElemType minval)
{
    // 如果链表为空或者输入无效，无需操作
    if (!L || !L->next)   return;
        
    // 用于跟踪最小值节点前面的节点
    LNode *prev = NULL;

    // 遍历链表的指针
    LNode *cur = L->next;

    // 寻找包含最小值的节点
    while (cur && cur->data != minval)
    {
        prev = cur;
        cur = cur->next;
    }

    // 如果找不到最小值或者最小值已经在链表头部，无需移动
    if (!cur || cur == L->next)    return;

    // 将包含最小值的节点从当前位置分离出来
    prev->next = cur->next;

    // 将分离的节点插入到链表头部
    cur->next = L->next;
    L->next = cur;
}


//void MoveMinNode_L(LinkedList L, ElemType minval)
//
//{
//	if(!L->next) return;
//	LNode* r = L;
//	while(r && r->next->data != minval)	r = r->next;//找到minval的前一个结点 
	//类似于进行一个删除操作 
//	LNode* p = r->next;
//	r->next = p->next;
// 	free(p);
	//类似进行一个插入操作 
// 	LNode *s = L;
//	LNode*q;
//	q = (LNode*)malloc(sizeof(LNode));
//	q->data = minval;
//	q->next = s->next;
//	s->next = q;
//}


//===========================================
// Print the elements in a linked list
//===========================================
void LinkedListPrint(LinkedList L)
{
    LNode *p = L->next;
    while (p)
    {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}

int main()
{
    int n;
    scanf("%d", &n);

    int arr[n];
    int i; 
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    int min = find_Min(arr, n);
    //printf("Minimum value: %d\n", min);
    printf("%d\n",min);

    LinkedList L;
    if (InitList_L(&L) == ERROR)
    {
        printf("Error: Failed to initialize the list.\n");
        return 1;
    }

    if (CreateList_L(&L, arr, n) == ERROR)
    {
        printf("Error: Failed to create the list.\n");
        return 1;
    }

    MoveMinNode_L(L, min);
    //printf("List after moving the minimum value to the head: ");
    LinkedListPrint(L);

    return 0;
}

```



#### 3. 单链表基本操作与应用



```c
#include <stdio.h>
#include <stdlib.h>

// 定义函数执行结果状态代码
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE 0

// 定义新的函数运行结果类型
typedef int Status;

// 动态单链表的结点结构体定义
typedef int ElemType;
typedef struct LNode 
{
    ElemType data;          // 数据域
    struct LNode* next;     // 指针域
} LNode, *LinkList;

// 初始化链表
Status InitList(LinkList *L) 
{
    int x, i;
    // 创建头结点
    *L = (LinkList)malloc(sizeof(LNode));
    if (*L == NULL) 
    {
        printf("内存分配失败\n");
        return ERROR;
    }
    (*L)->next = NULL;

    // 根据键盘输入构建链表
    LinkList r = *L;
    for (i = 0;; i++) 
    {
        scanf("%d", &x);
        if (x == -1)
            break;
        LinkList p = (LinkList)malloc(sizeof(LNode));
        if (!p) 
        {
            printf("初始化失败\n");
            return ERROR;
        }
        p->data = x;
        p->next = NULL;
        r->next = p;
        r = p;
    }
    return OK;
}

// 销毁链表
Status DestroyList(LinkList *L) 
{
    LinkList p;
    while (*L) 
    {
        p = (*L)->next; // p指向下一个结点
        free(*L);       // 释放L
        *L = p;
    }
    return OK;
}

// 判断链表是否为空
Status ListEmpty(LinkList L) 
{
    return (L->next == NULL);
}

// 清空链表
Status ClearList(LinkList L) 
{
    LinkList p, q;
    p = L->next; // p指向链表第一个结点
    while (p)    // 当p指向空时循环结束
    {
        q = p->next;
        free(p);
        p = q;
    }
    L->next = NULL; // 头结点指针域为空
    return OK;
}

// 获取链表的长度
int ListLength(LinkList L) 
{
    LNode *p = L;
    int len = 0;
    while (p->next) 
    {
        len++;
        p = p->next;
    }
    return len;
}

// 删除链表中的第i个元素，并将删除的元素值存储到e中
Status ListDelete(LinkList L, int i, ElemType* e) 
{
    LinkList p = L;
    int j = 0; // 计数器
    // 当第i个结点为空，或者j = i-1时结束循环，此时p指向第i-1个结点
    while (p->next && j < i - 1) 
    {
        p = p->next;
        j++;
    }

    if (!(p->next) || j > i - 1)    return ERROR;

    LinkList q = p->next;   // q保存删除结点地址
    p->next = p->next->next; // 删除
    *e = q->data;           // e存放删除节点的数据
    free(q);                // 释放
    return OK;
}

// 遍历输出链表
Status ListTraverse(LinkList L) 
{
    LinkList p = L->next;
    while (p) // 当p为空时结束循环
    {
        printf("%d ", p->data); // 每一个数据都进行visit函数操作，例如visit可以是打印函数
        p = p->next;
    }
    printf("\n");
    return OK;
}

// 在第i个位置插入元素e
Status ListInsert(LinkList L, int i, ElemType e) 
{
    LinkList p = L;
    int j = 0;
    while (p && j < i - 1) 
    {
        p = p->next;
        ++j;
    }
    if (!p || j > i - 1)   return ERROR;
    LNode *r = (LNode*)malloc(sizeof(LNode));
    if (!r)      return ERROR;
    r->data = e;
    r->next = p->next;
    p->next = r;
    return OK;
}

// 对链表进行操作
Status ListOperate(LinkList L) 
{
    if (ListEmpty(L)) 
    {
        printf("0 0\n");
        return OK;
    }

    int max = L->next->data, min = L->next->data;
    LNode *p = L->next;
    while (p) 
    {
        if (max < p->data)        max = p->data;
        if (min > p->data)		  min = p->data;
        p = p->next;
    }

    ListInsert(L, 1, max);
    ListInsert(L, ListLength(L) + 1, min);
    return OK;
}

int main() 
{
    // 初始化链表
    LinkList L;
    if (InitList(&L) == ERROR)       return 0;
    ListTraverse(L);    // 打印输出初始链表
    printf("%d\n", ListLength(L)); // 打印链表长度

    ListOperate(L);     // 对链表进行操作

    ListTraverse(L);    // 打印输出操作后的链表
    DestroyList(&L);    // 销毁链表

    return 0;
}

```



#### 4.使用链栈检验括号匹配

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 100

typedef int Status;
typedef char SElemType;

// 定义链表栈节点结构
typedef struct StackNode {
    SElemType data;
    struct StackNode *next;
} StackNode, *LinkStack;

// 函数声明
Status InitStack(LinkStack *S);
Status StackEmpty(LinkStack S);
Status Push(LinkStack *S, char ch);
Status Pop(LinkStack *S, char *ch);
Status GetTop(LinkStack S, char *e);
Status match(char element_l, char element_r);

// 初始化链表栈
Status InitStack(LinkStack *S) {
    (*S) = (LinkStack)malloc(sizeof(StackNode));
    if (!(*S))
        return ERROR;
    (*S)->next = NULL;
    return OK;
}

// 判断栈是否为空
Status StackEmpty(LinkStack S) {
    return S->next == NULL ? TRUE : FALSE;
}

// 元素入栈
Status Push(LinkStack *S, char ch) {
    LinkStack s = (LinkStack)malloc(sizeof(StackNode));
    if (!s)
        return ERROR;
    s->data = ch;
    s->next = (*S)->next;
    (*S)->next = s;
    return OK;
}

// 元素出栈
Status Pop(LinkStack *S, char *ch) {
    if (StackEmpty(*S))
        return ERROR;
    LinkStack p = (*S)->next;
    *ch = p->data;
    (*S)->next = p->next;
    free(p);
    return OK;
}

// 获取栈顶元素
Status GetTop(LinkStack S, char *e) {
    if (StackEmpty(S))
        return ERROR;
    *e = S->next->data;
    return OK;
}

// 检查两个括号是否匹配
Status match(char element_l, char element_r) {
    if (element_l == '(') {
        return (element_r == ')') ? TRUE : FALSE;
    } else if (element_l == '[') {
        return (element_r == ']') ? TRUE : FALSE;
    } else if (element_l == '{') {
        return (element_r == '}') ? TRUE : FALSE;
    } else {
        exit(0);
    }
}

int main() {
	//SetConsoleOutputCP(65001);
    LinkStack S;
    char e;
    int length = 0,i;
    char str[MAXSIZE];

    InitStack(&S);
    scanf("%s", str); // 输入一串括号
    length = strlen(str);

    for (i = 0; i < length; i++) {
        switch (str[i]) {
            case '(':
            case '[':
            case '{':
                Push(&S, str[i]);
                break;
            case ')':
            case ']':
            case '}':
                if (StackEmpty(S)) {
                    printf("右括号多余\n");
                    exit(0);
                } else {
                    GetTop(S, &e);
                    if (match(e, str[i])) {
                        Pop(&S, &e);
                    } else {
                        printf("左右括号不匹配\n");
                        exit(0);
                    }
                }
                break;
            default:
                exit(0);
        }
    }

    if (StackEmpty(S)) {
        printf("括号匹配\n");
    } else {
        printf("左括号多余\n");
    }

    return 0;
}


```



#### 5. 合并两个有序链表

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef int ElemType;
typedef int Status;

// Definition of node structure of singly linked list
typedef struct L_node
{
    ElemType data;           // data field 
    struct L_node *next;     // pointer field
} LNode, *LinkedList;

// Initialize a singly linked list L with head node
Status InitLinkList(LinkedList *L)
{
    (*L) = (LNode *) malloc(sizeof(LNode));
    if (!(*L))     return ERROR;
    (*L)->next = NULL;
    return OK;
}

// Create a singly linked list L with head node, and with n elements
Status CreateList_L(LinkedList L, int a[], int n)
{
    LNode *p = L;
    int i = 0;
    for (i = 0; i < n; i++)
    {
        LNode *r = (LNode *) malloc(sizeof(LNode));
        if (!r)
            return ERROR;
        r->data = a[i];
        r->next = NULL;
        p->next = r;
        p = r;
    }
    return OK;
}

// Merge two singly linked lists La and Lb into Lc
void Merge_L(LinkedList *La, LinkedList *Lb, LinkedList *Lc)
{
    LNode *a = (*La)->next;
    LNode *b = (*Lb)->next;
    LNode *c = (*Lc);
    LNode *c1;

    while (a && b)
    {
        c1 = (LNode *) malloc(sizeof(LNode));
        if (!c1)    return; // Allocation failed

        if (a->data <= b->data)
        {
            c1->data = a->data;
            a = a->next;
        } else
        {
            c1->data = b->data;
            b = b->next;
        }
        c1->next = NULL;
        c->next = c1;
        c = c1;
    }

    while (a)
    {
        c1 = (LNode *) malloc(sizeof(LNode));
        if (!c1)    return; // Allocation failed
        c1->data = a->data;
        c1->next = NULL;
        c->next = c1;
        c = c1;
        a = a->next;
    }

    while (b)
    {
        c1 = (LNode *) malloc(sizeof(LNode));
        if (!c1)   return;
		c1->data = b->data;
        c1->next = NULL;
        c->next = c1;
        c = c1;
        b = b->next;
    }
}

// Print the elements in a list
void LinkedListPrint(LinkedList L)
{
    LNode *p = L->next;
    while (p)
    {
        printf("%d ", p->data);
        p = p->next;
    }
}

int main()
{
    LNode *La, *Lb, *Lc;
    InitLinkList(&La);
    InitLinkList(&Lb);
    InitLinkList(&Lc);

    int n, m;
    scanf("%d", &n);
    int a[n];
    int i = 0;
    for (i = 0; i < n; i++)     scanf("%d", &a[i]);

    CreateList_L(La, a, n);

    scanf("%d", &m);
    int b[m];
    for (i = 0; i < m; i++)     scanf("%d", &b[i]);

    CreateList_L(Lb, b, m);

    Merge_L(&La, &Lb, &Lc);

    LinkedListPrint(Lc);

    return OK;
}  

```



#### 6.链表删除



```c
#include <stdio.h>   
#include <stdlib.h>   
#include <malloc.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef int ElemType;
typedef int Status;

// definition of node structure of singly linked list
typedef struct L_node
{
    ElemType data;           // data field 
    struct L_node* next;       // pointer field
}LNode, * LinkList;

//===========================================
// Initialize  a singly linked list L with head node
//===========================================

Status InitList_L(LinkList *L)

{
	(*L) = (LNode*)malloc(sizeof(LNode));
	(*L)->next = NULL;
	return OK;
}

//===========================================
// Create a singly linked list L with head node, and with n elements
//===========================================

Status CreateList_L(LinkList* L, ElemType a[], int n)
{
	LNode *p = *L;
	int j = 0;
	for(;j < n;j ++)
	{
		LNode*r ;
		r = (LNode*)malloc(sizeof(LNode));
		r->data = a[j];
		r->next = NULL;
		p->next = r;
		p = r;
	}
	return OK;
}

void Delete_List(LinkList L,int i)
{
	LNode*prev = L;
	int j = 0;
	while(prev && j < i - 1)
	{
		prev = prev->next;
		j ++;
	}
	if(!prev || j > i - 1) return ;
	LinkList r = prev->next;
	prev->next = r->next;
	free(r);
	return ;
}
//===========================================
//  删除位序为偶数的结点，并返回删除结点的总数
//===========================================

int Delete_L(LinkList *L,int len)
{
	int i = len / 2;
	int j = 2 * i;
	int count = 0;
	for(;j >1;j -=2)	
	{
		Delete_List(*L,j);
		count ++;
	}
	return count;
}
//======================================
// Print the elements in a list
//=======================================

void LinkedListPrint(LinkList L)

{
	LNode *p = L->next;
	while(p)
	{
		printf("%d ",p->data);
		p = p->next;
	}
	return;
}

int main()
{
	LNode *L;
	InitList_L(&L);
	int i = 0,n;
	scanf("%d",&n);
	int arr[n];
	for(;i < n;i ++) scanf("%d",&arr[i]);
	CreateList_L(&L,arr,n);
	int tot = Delete_L(&L,n);
	printf("%d\n",tot);
	LinkedListPrint(L);
	return OK;
}
```



#### 7.链表拼接

```c
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef int ElemType;
typedef int Status;

// definition of node structure of singly linked list
typedef struct L_node
{
    ElemType data;           // data field 
    struct L_node *next;       // pointer field
} LNode, *LinkedList;

//===========================================
// Initialize  a singly linked list L with head node
//===========================================
Status InitList_L(LinkedList *L)
{
    *L = (LNode *) malloc(sizeof(LNode));
    if (!(*L)) return ERROR;
    (*L)->next = NULL;
    return OK;
}

//===========================================
// Create a singly linked list L with head node, and with n elements
//===========================================

Status CreateList_L(LinkedList *L, int a[], int n)
{
    LNode *r = (*L);
    int i = 0;
    for (; i < n; i++)
    {
        LNode *p;
        p = (LNode *) malloc(sizeof(LNode));
        p->data = a[i];
        p->next = NULL;
        r->next = p;
        r = p;
    }
    return OK;
}

//===========================================
//  Merge two singly linked lists 
//===========================================

int Merge_L(LinkedList *ha, int len_a, LinkedList *hb, int len_b, LinkedList *hc)
{
    LNode *a = (*ha)->next;
    LNode *b = (*hb)->next;
    LNode *c = *hc;
    LNode *c1;
    c1 = (LNode *) malloc(sizeof(LNode));
    if (len_a > len_b)
    {
        while (b)
        {
            c1 = b;
            c->next = c1;
            c = c1;
            b = b->next;
        }
        while (a)
        {
            c1 = a;
            c->next = c1;
            c = c1;
            a = a->next;
        }
    } 
    else
    {
        while (a)
        {
            c1 = a;
            c->next = c1;
            c = c1;
            a = a->next;
        }
        while (b)
        {
            c1 = b;
            c->next = c1;
            c = c1;
            b = b->next;
        }
    }
}

//======================================
// Print the elements in a list
//=======================================

void LinkedListPrint(LinkedList L)
{
    LNode *p = L->next;
    while (p)
    {
        printf("%d ", p->data);
        p = p->next;
    }
}

int main()
{
    LNode *La;
    LNode *Lb;
    LNode *Lc;
    InitList_L(&La);
    InitList_L(&Lb);
    InitList_L(&Lc);
    int n, m, i = 0;
    scanf("%d", &n);
    int a[n];
    for (; i < n; i++) scanf("%d", &a[i]);
    CreateList_L(&La, a, n);
    scanf("%d", &m);
    int b[m];
    for (i = 0; i < m; i++) scanf("%d", &b[i]);
    CreateList_L(&Lb, b, m);
    Merge_L(&La, n, &Lb, m, &Lc);
    LinkedListPrint(Lc);
	return OK;
}  
```



#### 双向链表学习代码：

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1

typedef int ElemType;
typedef int Status;

typedef struct DuLNode
{
    ElemType data;          // 数据域
    struct DuLNode *prior;  // 指向直接前驱
    struct DuLNode *next;   // 指向直接后继
} DuLNode, *DuLinkList;

Status GetElem_DuL(DuLinkList L, int i, ElemType *e)
{
    int j;
    DuLinkList p;
    p = L->next; // p指向第一个结点
    j = 1;
    while (p && j < i)
    {
        p = p->next;
        ++j;
    }
    if (!p || j > i)
        return ERROR; // 第i个元素不存在
    *e = p->data;     // 取第i个元素的数据
    return OK;
}

Status ListInsert_DuL(DuLinkList *L, int i, ElemType e)
{
    DuLinkList p, s;
    if (i < 1) // 如果位置不合法
        return ERROR;

    s = (DuLinkList) malloc(sizeof(DuLNode));
    if (!s)
        exit(EXIT_FAILURE); // 内存分配失败，退出程序
    s->data = e;

    if (i == 1 || !(*L)->next)
    { // 在第一个位置插入或者链表为空时
        s->next = (*L)->next;
        if ((*L)->next) // 如果链表不为空
            (*L)->next->prior = s;
        s->prior = *L;
        (*L)->next = s;
        return OK;
    }

    p = (*L)->next;
    while (--i && p) p = p->next; // 找到第 i-1 个节点
    if (!p) // 如果位置超出链表长度
        return ERROR;

    s->next = p->next;
    s->next->prior = s;
    s->prior = p;
    p->next = s;
    return OK;
}


Status ListDelete_DuL(DuLinkList *L, int i)
{
    DuLinkList p, q;
    int j = 1;
    p = *L; // 将 p 指向头节点
    while (p->next && j < i)
    {
        p = p->next;
        ++j;
    }
    if (!p->next || j > i)
        return ERROR; // 第i个元素不存在
    q = p->next;
    p->next = q->next;
    if (q->next) // 如果 q 的下一个节点不为空
        q->next->prior = p;
    free(q);
    return OK;
}


int main()
{
    DuLinkList L;
    L = (DuLinkList) malloc(sizeof(DuLNode));
    if (!L)
        exit(EXIT_FAILURE); // 内存分配失败，退出程序
    L->next = NULL;
    ElemType e;
    if (ListInsert_DuL(&L, 1, 10) == OK)
        printf("Insert successful!\n");
    if (GetElem_DuL(L, 1, &e) == OK)
        printf("The first element is: %d\n", e);
    if (ListDelete_DuL(&L, 1) == OK)
        printf("Delete successful!\n");
    //system("pause");
    return 0;
}

```



### 作业4——栈



#### 学习代码：

```c
#include <stdio.h>
#include <malloc.h>
#include <string.h>

typedef int SElemType ;
typedef int Status;

#define ERROR 0
#define OK 1
#define MAXSIZE 100
typedef struct
{
    SElemType *base;
    SElemType *top;
    int stackSize;
}SqStack;

Status InitStack(SqStack *S)
{
    S->base = (SElemType*) malloc(sizeof (SqStack));
    if(!S->base)    return ERROR;
    S->top = S->base;//top 初始为 base ,空栈
    S->stackSize = MAXSIZE;
    return OK;
}

Status Push(SqStack *S,SElemType e)
{
    if(S->top - S->base == S->stackSize)    return ERROR;//栈满
    *S->top ++= e;//将元素e压入栈顶，栈顶指针加1
    return OK;
}

Status Pop(SqStack *S,SElemType *e)
{
    if(S->base == S->top)   return ERROR;//栈空
    *e = *--S->top;//栈顶指针减1，将栈顶元素赋给e
    return OK;
}

SElemType GetTop(SqStack S)
{//返回S的栈顶元素，不修改栈顶指针
    if(S.top != S.base)   return *(S.top - 1);//返回栈顶元素的值，栈顶指针不变
}

Status destorystack(stack *p)//毁坏
{
	free(p->base);
	p->base=NULL;
	p->top=NULL;
	p->stacksize=0;
	if(!p->base)
		printf("栈被毁坏成功！！！\n");
	return OK;
}

```



```c
//将中缀表达式转化为逆波兰表达式
#include <stdio.h>
#include <stdlib.h>


typedef struct
{
	char *base;
	char *top;
	int stackSize;
}sqStack;

void InitStack(sqStack *s)
{
	s->base = (char *)malloc(100*sizeof(char));
	s->top = s->base;
	s->stackSize = 100; 
}

void Push(sqStack *s, char e)
{
	*(s->top) = e;
	s->top++; 
}

int Pop(sqStack *s, char *e)
{
	if(s->top == s->base)
	{
		return 0;	
	}
	*e = *--(s->top);	
	return 0;
} 

int StackLen(sqStack s)
{
	return (s.top - s.base);
}

int main(void)
{
	sqStack s;
	char c, e;
	
	InitStack(&s);
	printf("Input: \n");
	scanf("%c", &c);
	
	while(c != '#')
	{
		while(c>='0' && c<='9')
		{
			printf("%c", c);
			scanf("%c", &c);
			if(c<'0' || c>'9')
			{
				printf(" ");
			}
		}
		
		if(c == ')')
		{
			Pop(&s, &e);
			while(e != '(')
			{
				printf("%c", e);
				Pop(&s, &e);
			}
		}
		else if('+' == c || c=='-')
		{
			if(StackLen(s) == 0)
			{
				Push(&s, c);
			}
			else
			{
				do
				{
					Pop(&s, &e);
					if(e == '(')
					{
						Push(&s, e);
					}
					else
					{
						printf("%c", e);
					}
				}while(StackLen(s) && e != '(');
				Push(&s, c);
			}
		}
		else if('*' == c || '/'==c || '('==c)
		{
			Push(&s, c);
		}
		else if('#' == c)
		{
			break;
		}
		else
		{
			printf("error!");
			return -1;
		}
		scanf("%c", &c);	
	}
	while(StackLen(s) != 0)
	{
		Pop(&s, &e);
		printf("%c ", e);
	}
	return 0;	
} 
```



```c
//计算逆波兰表达式的result

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

typedef struct
{
	double *base;
	double *top;
	int stackSize;
}sqStack;

void InitStack(sqStack *s)
{
	s->base = (double *)malloc(100*sizeof(double));
	s->top = s->base;
	s->stackSize = 100;
}

void Push(sqStack *s, double e)
{
	*(s->top) = e;
	s->top++;
}

void Pop(sqStack *s, double *e)
{
	s->top = s->top-1;
	*e = *(s->top);
}

int main(void)
{
	char c;
	double d, e, f, g;
	char str[100];
	int i = 0;
	
	sqStack s;
	InitStack(&s);
	
	printf("input: \n");
	scanf("%c", &c);
	while(c != '#' )
	{
		while(isdigit(c) || c=='.')
		{
			str[i++] = c;
			str[i] = '\0';
			scanf("%c", &c);
			if(c == ' ')
			{
				d = atof(str);
				Push(&s, d);
				i = 0;
				break;
			}
		}
		switch(c)
		{
			case '+':
				Pop(&s, &e);
				Pop(&s, &f);
				g = f+e;
				Push(&s, g);
				break;
			case '-':
				Pop(&s, &e);
				Pop(&s, &f);
				g = f-e;
				Push(&s, g);
				break;
			case '*':
				Pop(&s, &e);
				Pop(&s, &f);
				g = f*e;
				Push(&s, g);
				break;
			case '/':
				Pop(&s, &e);
				Pop(&s, &f);
				if(e != 0)
				{
					g = f/e;
					Push(&s, g);
					break;
				}
				else
				{
					printf("error!\n");
					break;
				}
	 
		}
		scanf("%c", &c);
	}
	
	Pop(&s, &d);
	printf("Result is: %f\n", d);
	return 0;
}
```



#### 1.堆栈练习题

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0

struct Stack
{
    int top;
    unsigned capacity;
    char *array;
};

struct Stack* createStack(unsigned capacity)
{
    struct Stack *stack = (struct Stack *)malloc(sizeof(struct Stack));
    if (stack == NULL) 
    {
        printf("Memory allocation failed!\n");
        exit(EXIT_FAILURE);
    }
    stack->capacity = capacity;
    stack->top = -1;
    stack->array = (char*)malloc(stack->capacity * sizeof(char));
    if (stack->array == NULL) 
    {
        printf("Memory allocation failed!\n");
        exit(EXIT_FAILURE);
    }
    return stack;
}

int isFull(struct Stack stack)
{
	int full = 0;   
	/*在表达式 (int)stack.capacity 中，stack.capacity 是 unsigned 类型的无符号整数，
	  而 (int) 是将其强制转换为有符号整数类型 int。
	  这个强制转换的目的是为了避免比较不同类型的数据时出现警告或错误*/
	full = (stack.top == (int)stack.capacity - 1)?1:0;
	return full;
}

int isEmpty(struct Stack stack)
{
	return (stack.top == -1) ? 1 :0;
}

void push(struct Stack *stack, char item)
{
    if (!isFull(*stack)) 
    {
        stack->array[++stack->top] = item;
    } 
    else 
    {
        printf("Stack is full. Cannot push element.\n");
    }
}

char pop(struct Stack *stack)
{
    if (!isEmpty(*stack)) 
    {
        return stack->array[stack->top--];
    } 
    else 
    {
        printf("Stack is empty. Cannot pop element.\n");
        return '\0';
    }
}

void reverseStr(char *str)
{
    int length = strlen(str);
    struct Stack* stack = createStack(length + 1);
    for (int i = 0; i < length; i++) 
    {
        push(stack, str[i]);
    }
    for (int i = 0; i < length; i++) 
    {
        str[i] = pop(stack);
    }
    printf("%s\n", str);
}

int main()
{
    char str[] = "ILoveChina, ILoveBJTU, ILoveGJCXSJXL";
    reverseStr(str);
    return 0;
}

```



####    2. 栈-创建堆栈

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef int SElemType;
typedef int Status;

#define STACK_INIT_SIZE   100     // 初始栈大小
#define STACKINCREMENT    10      // 栈增量大小

typedef struct {
    SElemType *base;    // 栈底指针
    SElemType *top;     // 栈顶指针
    int stacksize;      // 当前栈容量
} SqStack;

Status InitStack(SqStack *S) 
{
    S->base = (SElemType *)malloc(sizeof(SElemType) * STACK_INIT_SIZE);
    if (!S->base)      return ERROR;
    S->top = S->base;
    S->stacksize = STACK_INIT_SIZE;
    return OK;
}

Status StackEmpty(SqStack S) 
{
    return (S.top == S.base) ? TRUE : FALSE;
}

int StackLength(SqStack S) 
{
    return (S.top - S.base);
}

Status GetTop(SqStack S, SElemType *e) 
{
  if (StackEmpty(*S))      return ERROR;
    *e = *(S.top - 1);
    return OK;
}

Status Pop(SqStack *S, SElemType *e) 
{
    if (StackEmpty(*S))      return ERROR;
    *e = *(--S->top);
    return OK;
}

Status Push(SqStack *S, SElemType e) 
{
    if (S->top - S->base >= S->stacksize) 
    {
        //内存不够，重新分配空间
        S->base = (SElemType *)realloc(S->base, (S->stacksize + STACKINCREMENT) * sizeof(SElemType));
        if (!S->base)        return ERROR;
        S->top = S->base + S->stacksize;
        S->stacksize += STACKINCREMENT;
    }
    *(S->top++) = e;
    return OK;
}

void PrintStack(SqStack S) 
{
    int len = StackLength(S);
    for (int i = 0; i < len; i++) 
    {
        SElemType e;
        Pop(&S, &e);
        printf("%d ", e);
    }
    printf("\n");
}

int reverseOutput(SqStack S) 
{
    if (StackEmpty(S))      return ERROR;
    PrintStack(S);
    return StackLength(S);
}

int main() 
{
    SqStack S;
    InitStack(&S);
    int n, i = 0;
    scanf("%d", &n);
    int arr[n];
    for (; i < n; i++) 
    {
        scanf("%d", &arr[i]);
        Push(&S, arr[i]);
    }
    printf("%d", reverseOutput(S));
    return OK;
}

```



#### 3. 栈-比较含退格的字符串

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef char ElemType;
typedef int Status;

#define STACK_INIT_SIZE   100          // Initial size for memory allocation
#define STACKINCREMENT    10           // Incremental size

typedef struct 
{
    ElemType  *base;    // Base pointer
    ElemType  *top;     // Top pointer
    int        stacksize;     // Current size
} SqStack;

Status InitStack(SqStack *S) 
{
    S->base = (ElemType *)malloc(STACK_INIT_SIZE * sizeof(ElemType));
    if (!S->base) return ERROR;
    S->top = S->base;
    S->stacksize = STACK_INIT_SIZE;
    return OK;
}

Status StackEmpty(SqStack S)
{
    return S.base == S.top ? TRUE : FALSE;
}

int StackLength(SqStack S) 
{
    return S.top - S.base;
}

Status GetTop(SqStack S, ElemType *e) 
{
    if (StackEmpty(S)) return ERROR;
    *e = *(S.top - 1);
    return OK;
}

Status Pop(SqStack *S, ElemType *e)
{
    if (StackEmpty(*S)) return ERROR;
    *e = *--S->top;
    return OK;
}

Status Push(SqStack *S, ElemType e) 
{
    if (S->top - S->base >= S->stacksize)
    {
        S->base = (ElemType *)realloc(S->base, (S->stacksize + STACKINCREMENT) * sizeof(ElemType));
        if (!S->base) return ERROR;
        S->top = S->base + S->stacksize;
        S->stacksize += STACKINCREMENT;
    }
    *S->top++ = e;
    return OK;
}

int CompareString(char *S,  char *T)
{
    SqStack stack_S, stack_T;
    InitStack(&stack_S);
    InitStack(&stack_T);
    
    for (int i = 0; S[i] != '\0'; i++) 
    {
        if (S[i] != '#')     Push(&stack_S, S[i]);
        else 
        {
            if (!StackEmpty(stack_S)) 
            {
                ElemType temp;
                Pop(&stack_S, &temp);
            }
        }
    }
    
    for (int i = 0; T[i] != '\0'; i++) 
    {
        if (T[i] != '#')        Push(&stack_T, T[i]); 
        else 
        {
            if (!StackEmpty(stack_T)) 
            {
                ElemType temp;
                Pop(&stack_T, &temp);
            }
        }
    }
    
    if (StackLength(stack_S) != StackLength(stack_T))      return FALSE;
    while (!StackEmpty(stack_S)) 
    {
        ElemType charS, charT;
        Pop(&stack_S, &charS);
        Pop(&stack_T, &charT);
        if (charS != charT)      return FALSE;
    }
    return TRUE;
}

int main() 
{
    char s[1000], t[1000];
    scanf("%s", s);
    scanf("%s", t);
    
    int res = CompareString(s, t);
    if (res)   printf("true");
    else 		printf("false");

    return 0;
}

```



#### 4. 820230003栈基本操作与应用



```c
#define BASE 17

#include <stdio.h>
#include <stdlib.h>

#define Status int
#define SElemType char

#define STACK_INIT_SIZE 100        //存储空间的初始分配量
#define STACKINCREMENT  10          //存储空间的分配增量
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0

//栈数据结构
typedef struct Stack 
{
    SElemType *base;    //栈底指针
    SElemType *top;     //栈顶指针
    int stacksize;      //栈可用的最大容量
} SqStack;

//初始化函数
Status InitStack(SqStack *S) 
{
    S->base = (SElemType *)malloc(STACK_INIT_SIZE * sizeof(SElemType));
    if (!S->base) 
    {
        printf("init fail\n");
        return ERROR;
    }
    S->top = S->base;     //栈顶指针与栈底相同
    S->stacksize = STACK_INIT_SIZE;
    return OK;
}

//销毁 
Status DestroyStack(SqStack *S) 
{
    //补全代码
	free(S->base);
	S->base = NULL;
	S->top = NULL;  
	S->stacksize = 0;
	if(S->base)	
	{
		printf("Fail Destroy");
		return ERROR;
	}
	return OK;
}

//清空 
Status ClearStack(SqStack *S) 
{
    S->top = S->base;
    return OK;
}

//判断是否为空 
Status StackEmpty(SqStack S) 
{
    if (S.top == S.base) 
        return TRUE;
    else
        return FALSE;
}

int StackLength(SqStack S) 
{
    return S.top - S.base;
}

//得到栈顶元素，不修改指针
Status GetTop(SqStack S, SElemType *e) 
{ 
    if (S.top == S.base) 
        return ERROR;
    *e = *(S.top - 1);
    return OK;
}

//入栈
Status Push(SqStack *S, SElemType e) 
{
    if (S->top - S->base >= S->stacksize) 
    {  //栈满,追加存储空间
        S->base = (SElemType *)realloc(S->base, (S->stacksize + STACKINCREMENT) * sizeof(SElemType));
        if (!S->base) 
            return ERROR;
        S->top = S->base + S->stacksize;
        S->stacksize += STACKINCREMENT;
    }
    *S->top++ = e;
    return OK;
}

//出栈
Status Pop(SqStack *S, SElemType *e) 
{
    if (S->top == S->base) 
        return ERROR;    //栈空
    *e = *--S->top;
    return OK;
}

//遍历栈
Status StackTraverse(SqStack S) 
{
    if (S.base == NULL)
        return ERROR;
    if (S.top == S.base)
        printf("empty\n");
    SElemType *p;
    p = S.top;
    while (p > S.base) 
    {
        p--;
        printf("%c", *p);//从栈顶开始打印，而且未修改栈顶指针 
    }
    return OK;
}

void conversion(SqStack *S) 
{
    //补全代码
    int decimal = 0;
    scanf("%d",&decimal);
    char base17[20] = "0123456789ABCDEFG";
    while(decimal)
    {
    	int index = decimal % 17;
    	Push(S,base17[index]);
    	decimal /=17;
	}
	StackTraverse(*S);
}

//主函数
int main() 
{
    SqStack S;
    InitStack(&S);
    conversion(&S);
    DestroyStack(&S);
    return 0;
}

```



#### 5. 实验4 栈实验1



```c
#include <stdio.h>

#include <string.h>

#include <stdlib.h>


#define STACK_INIT_SIZE    20     /*存储空间的初始分配量*/

#define STACK_INCREMENT    10     /*存储空间的分配增量*/

//#define CHAR_MAX 127

#define DBL_MAX 100

#define ERROR 0

#define OK 1


/*数据栈结构体定义，要求：

包括栈底指针，栈顶指针和当前分配的存储容量*/

typedef struct
{

    double *Dbase;

    double *Dtop;

    int Dstacksize;

} DataStack;


/*操作符结构体定义，要求包括栈底指针，栈顶指针和当前分配的存储容量*/

typedef struct
{

    char *Obase;

    char *Otop;

    int Ostacksize;

} OpStack;


/*静态二维优先级数组：static char OperationPreceder[7][7]   

定义操作符＋、－、＊、／、（、）、=的运算优先级*/

static char OperationPreceder[7][7] =

        {{'>', '>', '<', '<', '<', '>', '>'},

         {'>', '>', '<', '<', '<', '>', '>'},

         {'>', '>', '>', '>', '<', '>', '>'},

         {'>', '>', '>', '>', '<', '>', '>'},

         {'<', '<', '<', '<', '<', '=', 'x'},

         {'>', '>', '>', '>', 'x', '>', '>'},

         {'<', '<', '<', '<', '<', 'x', '='}

        };


/*函数接口定义为：int TransOPtoCD(char op_temp)   

* 输入参数：操作符x   

* 处理规则及返回值：将操作符转化为运算优先级静态表的坐标，并返回；   

* 输入参数非＋、－、＊、／、（、）、=，则返回－1*/

int TransOPtoCD(char op_temp)
{

    switch (op_temp)
    {

        case '+':
            return (0);

        case '-':
            return (1);

        case '*':
            return (2);

        case '/':
            return (3);

        case '(':
            return (4);

        case ')':
            return (5);

        case '=':
            return (6);

        default:
            return (-1);  /*当输入参数不是四则运算、括号、等号时，返回－1*/

    }


}


/*函数接口定义为：char Precede(char op1, char op2)   

* 输入参数：进行比较的运算符op1和op2；   

* 处理规则及返回值：将op1和op2转化为二维数组OperationPreceder的坐标，查找该坐标存储的符号，并作为返回值输出；   

* 如果无法找到坐标则返回0*/

char Precede(char op1, char op2)
{

    int x, y;

    x = y = -1;

    x = TransOPtoCD(op1);

    y = TransOPtoCD(op2);

    if (x != -1 && y != -1)
    {

        //    printf("%c\n", OperationPreceder[x][y]);       

        return OperationPreceder[x][y];

    } else

        return 0;

}


/*函数接口定义为：int checkch (char c)   

* 输入参数：表达式字符c；   

* 处理规则及返回值：判断字符c是数字还是操作符；   

* 如果c是数字返回1，如果是小数点返回2，如果是运算符返回3，否则为无效字符返回－1；   

* 假设：表达式中的所有云算数均为正数*/

int checkch(char c)
{

    if (c >= '0' && c <= '9')

        return 1;

    if (c == '.')

        return 2;

    if (c == '+' || c == '-' || c == '*' || c == '/' || c == '(' || c == ')' || c == '=')

        return 3;

    else

        return 0;

}


/*函数接口定义为：double Operate(double x,double y, char op)；   

* 输入参数：运算数x，被运算数y，操作符op；   

* 处理规则及返回值：进行x op y运算，返回运算结果；默认返回0.0*/

double Operate(double x, double y, char op)
{

    switch (op)
    {

        case '+':

            return x + y;

        case '-':

            return x - y;

        case '*':

            return x * y;

        case '/':

            if (y != 0)

                return x / y;

            else

                printf("The divisor cannot be 0!\n");

            exit(-1);

        default:

            break;

    }

    return 0.0;

}


/*数据栈初始化函数定义，要求：   

* 函数接口定义为：int InitDataStack(DataStack *DS)   

* 输入参数：数据栈DS   

* 处理规则及返回值：从内存堆中申请STACK_INIT_SIZE个整型空间，将栈顶指针与栈底指针都指向初始地址，给Dstacksize赋值STACK_INIT_SIZE   

* 初始化成功返回1，否则返回0.*/

int InitDataStack(DataStack *DS)
{


    //根据注释, 将该函数补充完整
    DS->Dbase = (double*)malloc(sizeof(double));
    if(!DS->Dbase)	return ERROR;
    DS->Dtop = DS->Dbase;
	DS->Dstacksize =  STACK_INIT_SIZE;
	return OK;
	
	
}


/* 数据栈入栈函数定义，要求：   

* 函数接口定义为：int PushDataStack(DataStack *DS,int e)   

* 输入参数：待操作数据栈DS，插入数据e；   

* 处理规则及返回值：在栈顶指针位置存储e，并将栈顶指针位置后移，返回1；   

如果数据栈不存在或者数据栈上溢，返回错误（0）。*/

int PushDataStack(DataStack *DS, double e)
{
	if(!DS->Dbase)	return ERROR;//数据栈不存在
	if(DS->Dtop - DS->Dbase >= DS->Dstacksize)
	{//据栈上溢,重新分配内存 
		DS->Dbase = (double*)realloc(DS->Dbase,(DS->Dstacksize +STACK_INCREMENT ) * sizeof(double));
		if(!DS->Dbase)	return ERROR;
		DS->Dtop = DS->Dbase + DS->Dstacksize;
		DS->Dstacksize += STACK_INCREMENT;
	}
	*(DS->Dtop++) = e;
	return OK;
   // 根据注释, 将该函数补充完整


}


/*数据栈出栈函数定义，要求：   

* 函数接口定义为：int PopDataStack(DataStack *DS, int *e)   

* 输入参数：数据栈DS, 输出整型指针变量e；   

* 处理规则及返回值：将栈顶指针减1，将该地址存储的变量付给＊e，返回1；   

如果数据栈不存在或数据栈为空，返回0。*/

int PopDataStack(DataStack *DS, double *e)
{

    //根据注释, 将该函数补充完整
    if(!DS->Dbase)	return ERROR;
    *e = *--DS->Dtop;
	return OK; 

}


/*数据栈查看栈顶元素函数定义，要求：   

* 函数接口定义为：int GetDataTop(DataStack *DS)   

* 输入参数：数据栈DS, 记录栈顶元素变量e；   

* 处理规则及返回值：如果数据栈不存在或数据栈为空，返回DBL_MAX; 否则，返回栈顶元素。*/

double GetDataTop(DataStack *DS)
{


    //根据注释, 将该函数补充完整
	if(!DS->Dbase)	return DBL_MAX;
	return *(DS->Dtop - 1);
	
}


/*数据栈销毁函数定义，要求：   

* 函数接口定义为：int DestroyDataStack(DataStack *DS   

* 输入参数：数据栈DS   

* 处理规则及返回值：释放栈底指针所指空间，并将数据栈的栈底和栈顶指针置空，数据栈Dstacksize置为0。最后返回1*/

int DestroyDataStack(DataStack *DS)
{

    //根据注释, 将该函数补充完整
    free(DS->Dbase);
	DS->Dbase = NULL;
	DS->Dtop = NULL;
	DS->Dstacksize = 0;
	if(DS->Dbase)	return ERROR;
	return OK;

}


/*符号栈初始化函数定义，要求：   

* 函数接口定义为：int InitOpStack(OpStack *OS)   

* 输入参数：符号栈OS   

* 处理规则及返回值：从内存堆中申请STACK_INIT_SIZE个整型空间，将栈顶指针与栈底指针都指向初始地址，给Dstacksize赋值STACK_INIT_SIZE   

* 初始化成功返回1，否则返回0.*/

int InitOpStack(OpStack *OS)
{

    //根据注释, 将该函数补充完整
    OS->Obase = (char*)malloc(sizeof(char));
    if(!OS->Obase)	return ERROR;
    OS->Otop = OS->Obase;
    OS->Ostacksize = STACK_INIT_SIZE;
    return OK;

}


/* 符号栈入栈函数定义，要求：   

* 函数接口定义为：int PushOpStack(OpStack *OS,int e)   

* 输入参数：待操作符号栈DS，插入符号e；   

* 处理规则及返回值：在栈顶指针位置存储e，并将栈顶指针位置后移，返回1；   

如果符号栈不存在或者符号栈上溢，返回0。*/

int PushOpStack(OpStack *OS, char e)
{


//    根据注释, 将该函数补充完整
	if(!OS->Obase)	return OK;
	if(OS->Otop - OS->Obase >= OS->Ostacksize)	
	{
		OS->Obase = (char*)realloc(OS->Obase,(OS->Ostacksize + STACK_INCREMENT)*sizeof(char));
		
	}
	*OS->Otop++ = e;
}


/* 符号栈出栈函数定义，要求：   

* 函数接口定义为：int PopOpStack(OpStack *OS, int *e)   

* 输入参数：符号栈DS, 输出符号指针变量e；   

* 处理规则及返回值：将栈顶指针减1，将该地址存储的变量付给＊e，返回1；   

如果符号栈不存在或符号栈为空，返回0。*/

int PopOpStack(OpStack *OS, char *e)
{

    //根据注释, 将该函数补充完整
    if(!OS->Obase)	return ERROR;
    *e = *--OS->Otop;
    return OK;

}


/* 符号栈查看栈顶元素函数定义，要求：   

* 函数接口定义为：char GetOpTop(OpStack *OS)   

* 输入参数：数据栈DS, 记录栈顶元素变量e；   

* 处理规则及返回值：如果数据栈不存在或数据栈为空，返回CHAR_MAX; 否则，返回栈顶元素。*/

char GetOpTop(OpStack *OS)
{


    //根据注释, 将该函数补充完整
	if(!OS->Obase)	return ERROR;
	return *(OS->Otop - 1);

}


/* 符号栈销毁函数定义，要求：   

* 函数接口定义为：int DestroyOpStack(OpStack *OS)   

* 输入参数：符号栈DS   

* 处理规则及返回值：释放栈底指针所指空间，并将符号栈的栈底和栈顶指针置空，符号栈Dstacksize置为0。最后返回1*/

int DestroyOpStack(OpStack *OS)
{

    //根据注释, 将该函数补充完整
	free(OS->Obase);
	OS->Obase = NULL;
	OS->Otop = NULL;
	OS->Ostacksize = 0;
	if(OS->Obase)	return ERROR;
	return OK; 

}


int main()
{

    OpStack OPTR = {0};      /*运算符栈*/

    DataStack OPND = {0};    /*操作数栈*/

    char op = 0;             /*当前运算符*/

    double value = 0.0;        /*数字字符的组合结果*/

    double b = 0.0;         /*当前运算的操作数*/

    double a = 0.0;         /*当前运算的被操作数*/

    char expression[1001] = {0};          /*表达式缓存，表达式长度不大于1000个字符*/

    int i = 0;                            /*表达式缓存的当前读取位置*/



    /*数据栈初始化函数定义，要求：   

    * 函数接口定义为：int InitDataStack(DataStack *DS)   

    * 输入参数：数据栈DS   

    * 处理规则及返回值：从内存堆中申请STACK_INIT_SIZE个整型空间，将栈顶指针与栈底指针都指向初始地址，给Dstacksize赋值STACK_INIT_SIZE   

    * 初始化成功返回1，否则返回0.*/

    if (InitDataStack(&OPND) == 0)
    {

        printf("InitDataStack Wrong\n");

        return 1;

    }



    /*符号栈初始化函数定义，要求：   

    * 函数接口定义为：int InitOpStack(OpStack *OS)   

    * 输入参数：符号栈OS   

    * 处理规则及返回值：从内存堆中申请STACK_INIT_SIZE个整型空间，将栈顶指针与栈底指针都指向初始地址，给Dstacksize赋值STACK_INIT_SIZE   

    * 初始化成功返回1，否则返回0.*/

    if (InitOpStack(&OPTR) == 0)
    {

        printf("InitOpStack Wrong\n");

        return 1;

    }



    /*符号栈栈底压入'＝'*/

    PushOpStack(&OPTR, '=');

    /*提示输入表达式，以等号结束*/

    printf("Please input the expression:\n");

    /*从标准输入获得表达式存入数组expression*/

    gets(expression);

    /*防护代码：当用户遗漏＝时提示*/

    if (expression[strlen(expression) - 1] != '=')
    {

        printf("Error: Please make sure the expression is ended with '='!");

        return 0;

    }


    while (i < strlen(expression) - 1 || GetOpTop(&OPTR) != '=')
    {

        //防护无效输入       

        if (checkch(expression[i]) == 0)
        {

            printf("Error: Invalid Input!");

            return 0;

        }

        //当表达式当前字符是数字时，逐位读入并组合       

        if (checkch(expression[i]) == 1)
        {

            while (checkch(expression[i]) == 1)
            {

                value = 10 * value + expression[i] - '0';

                i++;

            }

            /*如果表达式当前字符是小数，小数点后的数字处理后与小数点之前的数字相加*/

            if (checkch(expression[i]) == 2)
            {

                int r = 10;

                i++;

                while (checkch(expression[i]) == 1)
                {

                    value += (double) (expression[i] - '0') / r;

                    r = 10 * r;

                    i++;

                }

            }

            //数字压入数字栈OPND        

            PushDataStack(&OPND, value);

            value = 0.0;

        }



        /*如果表达式当前字符是运算符，则需要判断当前运算符与符号栈栈顶运算符的优先级*/

        if (checkch(expression[i]) == 3)
        {


            switch (Precede(GetOpTop(&OPTR), expression[i]))
            {

                /*如果符号栈栈顶运算符的优先级 < 表达式当前字符，则将表达式当前字符压入符号栈*/

                case '<':

                    PushOpStack(&OPTR, expression[i]);

                    i++;

                    break;

                    /*如果符号栈栈顶运算符的优先级 = 表达式当前字符，删去该栈顶符号*/

                case '=':

                    PopOpStack(&OPTR, &op);

                    i++;

                    break;

                    /*如果符号栈栈顶运算符的优先级 > 表达式当前字符，则计算栈顶运算符子式*/

                case '>':

                    PopOpStack(&OPTR, &op);

                    PopDataStack(&OPND, &b);

                    PopDataStack(&OPND, &a);

                    PushDataStack(&OPND, Operate(a, b, op));  /*运算结果入数据栈*/

                    break;

                default:

                    break;

            }

        }

    }

    /*打印表达式计算结果*/

    printf("The result is:%.2f\n", GetDataTop(&OPND));

    /*主动释放数据栈和符号栈的空间*/

    DestroyDataStack(&OPND);

    DestroyOpStack(&OPTR);

    return 0;

} 
```





#### 6. 实验4 栈实验2

```c
#include<stdio.h>
#include<stdlib.h>

#define OK 1
#define ERROR 0

typedef int SElemType;

typedef struct StackNode 
{
    SElemType data;
    struct StackNode *next;
} StackNode, *LinkStack;

void InitStack(LinkStack *S) 
{
    *S = (LinkStack)malloc(sizeof(StackNode));
    if(!(*S))	return;
    (*S)->next = NULL; 
    //下面是错误的内存开辟，sizeof(LinkStack)是一个指针变量的大小，存的就地址值，无法为StackNode开辟空间
    //S = (LinkStack*)malloc(sizeof(LinkStack));
    //if(!S)	return ;
    //(*S)->next = NULL; 
}

int StackEmpty(LinkStack S) 
{
    if (S->next == NULL) 
    {
        return 1;
    } 
    else 
    {
        return 0;
    }
}

void Push(LinkStack *S, SElemType e) 
{
    LinkStack p = *S;	
    LinkStack r;
    r = (LinkStack)malloc(sizeof(StackNode));
    if(!r)	return;
    r->data = e;
    r->next = p->next;
    p->next = r;
}

int Pop(LinkStack *S, SElemType *e) 
{
    if(StackEmpty(*S)) return ERROR;
    LinkStack p = *S;
    LinkStack q = p->next;
    *e = q->data;
    p->next = q->next;
    free(q);
    return OK;
}

void Conversion() 
{
    LinkStack S;
    InitStack(&S);
    printf("请输入非负十进制数\n");
    int N;
    N = 1348;
    while (N != 0) 
    {
        int mod = N % 8;
        Push(&S, mod);
        N = N / 8;
    }
    printf("八进制形式为: ");
    int e;
    while (StackEmpty(S) != 1) 
    {
        if(Pop(&S, &e) == OK)//判断是否pop成功
            printf("%d", e);
    }
    printf("\n");
}

int main() 
{
    Conversion();
    return 1;
}

```



#### 7. 栈-棒球比赛



```c
#include <stdio.h>  

#include <stdlib.h>  

#include <malloc.h>

 

#define ERROR 0

#define OK 1

#define TRUE 1

#define FALSE 0

 

typedef int SElemType;  

typedef int Status;

 

typedef struct L_node{

     SElemType     data;  //data field

     struct L_node  *next;   //pointer field

}LNode, *LinkList;

 

typedef struct{

   LinkList  Head;  //head pointer

   int  length;  //length

}LinkStack;

 

//========================================== 

// initialization of linked list based stack

//=========================================== 

Status InitStack(LinkStack *S)
{
	
	S->Head = (LinkList)malloc(sizeof(LNode));
	if(!(S->Head))	return ERROR; 
	S->Head->next = NULL;
	S->length = 0;
	return OK;
}

//========================================

//Test empty stack

//========================================

Status StackEmpty (LinkStack S)
{

	return (S.length == 0)?TRUE:FALSE;

}

 

//===============================================

// Get the length of a stack

//==============================================

int StackLength (LinkStack S)
{
 	               

}

 

//=====================================

// Get top item of a stack

//====================================

int GetTop(LinkStack S)
{
	if(S.length == 0) return ERROR;
	return S.Head->next->data;

}

 

//===================================================

// Delete an item from the stack

//====================================================

Status Pop(LinkStack *S, SElemType *e)
{
	if(S->length == 0)	return ERROR;
	LinkList p = S->Head->next;
	LinkList r = S->Head;
	*e = p->data;
	r->next = p->next;
	S->length --;
	free(p);
	return OK;
}

 

//======================================

// Insert an item into the stack

//=======================================

Status Push(LinkStack *S, SElemType e)
{
	LinkList p = S->Head;
	LinkList r;
	r = (LinkList)malloc(sizeof(LNode));
	if(!r) return ERROR;
	r->data = e;
	r->next = p->next;
	p->next = r;
	S->length ++;
	return OK;

}

 

//======================================

// Print the elements in a stack

//=======================================

void PrintStack (LinkStack S)
{

	LinkList p = S.Head->next;
	while(p)
	{
		printf("%d ",p->data);
		p = p->next;
	 } 
	 
}

//=========================

// 计算分值，s为字符串数组，nSize为数组的长度

//========================

int CalPoints(char *s,  int nSize)

{
	LinkStack Sstack;
	InitStack(&Sstack);
	int count = 0,i = 0,e;
	for(;i < nSize;i ++)
	{
		if(s[i] <= '9' && s[i] >= '0')	Push(&Sstack,s[i] - '0');
		else if(s[i] == '+')	
		{
			LinkList p = Sstack.Head->next;
			//while(p->next->next)	p = p->next;
			Push(&Sstack,p->data + p->next->data);
		}
		else if(s[i] == 'D')	Push(&Sstack,2 * GetTop(Sstack));
		else if(s[i] == 'C')	Pop(&Sstack,&e);
	}
	
	LinkList q = Sstack.Head->next;
	while(q)	
	{
		count +=q->data;
		q = q->next; 
	}
	return count;

} 



int main()  

{  
	int n,i = 0;
	char str[n + 1];
	scanf("%d",&n);
	for(;i < n;i ++)	
	{
		getchar(); 
		scanf("%c",&str[i]);
	}
	str[n] = '\0';
	printf("%s",str); 
	printf("%d",CalPoints(str,n));
	
	return OK;

 } 
```



#### 8. 栈-判断操作序列是否合法

```c
#include <stdio.h>  

#include <stdlib.h>  

#include <malloc.h>

 

#define ERROR 0

#define OK 1

#define TRUE 1

#define FALSE 0

typedef char SElemType;  

typedef int Status;

 

// definition of array based stack

#define STACK_INIT_SIZE   100          //Initial size for memory allocation

#define STACKINCREMENT  10          //incremental size

typedef struct{

   SElemType  *base;    //base pointer

   SElemType  *top;      //top pointer

   int        stacksize;     //current size

}SqStack;

 

//========================================== 

// initialization of array-based stack

//=========================================== 

Status InitStack(SqStack *S)
{

	S->base = (char*)malloc(STACK_INIT_SIZE*sizeof(char));
	if(!S->base)	return ERROR;
	S->top = S->base;
	S->stacksize =  STACK_INIT_SIZE;
	return OK;
}

 

//========================================

//Test empty stack

//========================================

Status StackEmpty (SqStack S)
{

	return (S.base == S.top)?TRUE:FALSE;

}

 

//===============================================

// Get the length of a stack

//==============================================

int StackLength (SqStack S)
{

	return S.top - S.base;                            

}

 

//=====================================

// Get top item of a stack

//====================================

Status GetTop(SqStack S, SElemType *e)
{
	if(StackEmpty(S))	return ERROR;
	*e = *(S.top - 1);
 	return OK;

}

 

//===================================================

// Delete an item from the stack

//====================================================

Status Pop(SqStack *S)
{

	if(StackEmpty(*S))	return ERROR;
	--S->top; 
	return OK;
}

 

//======================================

// Insert an item into the stack

//=======================================

Status Push(SqStack *S,SElemType e)
{

	if(S->stacksize == StackLength(*S)) 
	{
		S->base = (char*)realloc(S->base,(S->stacksize + STACKINCREMENT) *sizeof(char));
		if(!S->base)	return ERROR;
		S->top = S->base + S->stacksize;
		S->stacksize += STACKINCREMENT; 
	 } 
	 *S->top ++ = e;
	return OK;
}

 

//======================================

// Print the elements in a stack

//=======================================

void PrintStack (SqStack S)
{
	
	SElemType *p = S.base;
	while(p < S.top)
	{
		printf("%c",*p++);
	}
	printf("\n"); 
}

 

//======================================

// 检查操作序列是否合法, 如果合法，返回1，否则返回0

//=======================================

int isLegal(char *s)

{
	SqStack T; 
	InitStack(&T);
	
	int i = 0;
	for(;s[i] != '\0';i ++)
	{
		if(s[i] == 'I')	Push(&T,s[i]);
		else if(s[i] == 'O')	if(!Pop(&T)) return ERROR;
	}
	return StackEmpty(T);
}



int main( )  

{  
	char str[10010];
	scanf("%s",str);
	int tag = isLegal(str);
	if(tag)	printf("True");
	else printf("False");
	return OK;


 } 
```



#### 9. 栈-删除元素



> ```c
> #include <stdio.h>  
> #include <stdlib.h>  
> #include <malloc.h>
> 
> #define ERROR 0
> #define OK 1
> #define TRUE 1
> #define FALSE 0
> 
> typedef int SElemType;  
> typedef int Status;
> 
> typedef struct L_node {
>     SElemType data;  //data field
>     struct L_node *next;   //pointer field
> } LNode, *LinkList;
> 
> typedef struct {
>     LinkList Head;  //head pointer
>     int length;  //length
> } LinkStack;
> 
> //========================================== 
> // initialization of linked list based stack
> //=========================================== 
> Status InitStack(LinkStack *S)
> {
>    S->Head = (LinkList)malloc(sizeof(LNode));
>    if(!S->Head)	return ERROR;
>    S->Head->next = NULL;
>    S->length = 0;
>    return OK; 
> }
> 
> //========================================
> // Test empty stack
> //========================================
> Status StackEmpty(LinkStack S)
> {
> 	return (!S.length);
> }
> 
> //===============================================
> // Get the length of a stack
> //==============================================
> int StackLength(LinkStack S)
> {
> 	return S.length;
> }
> 
> //=====================================
> // Get top item of a stack
> //====================================
> Status GetTop(LinkStack S, SElemType *e)
> {
> 	if(StackEmpty(S))	return ERROR;
> 	*e = S.Head->next->data;
> }
> 
> //===================================================
> // Delete an item from the stack
> //====================================================
> Status Pop(LinkStack *S, SElemType *e)
> {
> 	if(StackEmpty(*S))	return ERROR;
> 	LinkList p = S->Head;
> 	LinkList r = p->next;
> 	p->next = r->next;
> 	*e = r->data;
> 	free(r);
> 	S->length --;
> 	return OK;
> }
> 
> //======================================
> // Insert an item into the stack
> //=======================================
> Status Push(LinkStack *S, SElemType e)
> {
> 	LinkList p = S->Head;
> 	LinkList r;
> 	r = (LinkList)malloc(sizeof(LNode));
> 	r->data = e;
> 	r->next = p->next;
> 	p->next = r;
> 	S->length ++;
> 	return OK;
> }
> 
> //======================================
> // Print the elements in a stack
> //=======================================
> void PrintStack(LinkStack S)
> {
> 	LinkList p = S.Head->next;
> 	while(p)
> 	{
> 		printf("%d ",p->data);
> 		p = p->next;
> 	 } 
> 	 printf("\n");
> }
> 
> //======================================
> // 删除堆栈中值为x的元素（可能有多个），返回堆栈的长度
> //=======================================
> int DeleteElem(LinkStack *S, SElemType x)
> {
> 	LinkList p = S->Head;
> 	while(p->next)
> 	{
> 		if(p->next->data != x)	p = p->next;
> 		else
> 		{
> 			LinkList r = p->next;
> 			p->next = r->next;
> 			free(r);
> 			 S->length --;
> 		  }  
> 	}
> 	return S->length;
> }
> 
> int main()  
> {  
> 	LinkStack S;
> 	InitStack(&S);
> 	int n,i = 0;
> 	scanf("%d",&n);
> 	int arr[n];
> 	for(;i < n;i ++)	
> 	{
> 		scanf("%d",&arr[i]);
> 		Push(&S,arr[i]);
> 	}
> 	int x;
> 	scanf("%d",&x);
> 	
> 	int tag = DeleteElem(&S,x);
> 	PrintStack(S);
> 	printf("%d",tag);
> }
> 
> ```
>



### 作业5——队列

#### 学习代码：

##### 循环队列式：

```c
//循环队列
#include <stdio.h>
#include <stdlib.h>

#define MAXQSIZE 100
#define OVERFLOW -1
#define ERROR 0
#define OK 1

typedef int QElemType;
typedef int Status;

// 循环队列
typedef struct {
    QElemType *base;
    int front;
    int rear;
} SqQueue;

Status InitQueue(SqQueue *Q) 
{
    Q->base = (QElemType*) malloc(MAXQSIZE * sizeof(QElemType));
    if (!Q->base) 
    {
        exit(OVERFLOW);
    }
    Q->front = Q->rear = 0;
    return OK;
}

int QueueLength(SqQueue Q) 
{
    return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;
}

Status EnQueue(SqQueue *Q, QElemType e) 
{
    if ((Q->rear + 1) % MAXQSIZE == Q->front) 
    {
        return ERROR; // 队列已满
    }
    Q->base[Q->rear] = e;
    Q->rear = (Q->rear + 1) % MAXQSIZE;
    return OK;
}

Status DeQueue(SqQueue *Q, QElemType *e) 
{
    if (Q->front == Q->rear) 
    {
        return ERROR; // 队列为空
    }
    *e = Q->base[Q->front]; // 保存值
    Q->front = (Q->front + 1) % MAXQSIZE;
    return OK;
}

QElemType GetHead(SqQueue Q) 
{
    if (Q.front != Q.rear) 
    { // 队列不为空
        return Q.base[Q.front]; // 返回值
    }
    // 处理空队列
    return -1; // 或其他适当值
}

void DestroyQueue(SqQueue *Q) 
{
    free(Q->base);
    Q->base = NULL;
    Q->front = Q->rear = 0;
}

int main() 
{
    SqQueue Q;
    InitQueue(&Q);
    EnQueue(&Q, 1);
    EnQueue(&Q, 2);
    EnQueue(&Q, 3);

    printf("队列长度: %d\n", QueueLength(Q));

    QElemType head;
    if (DeQueue(&Q, &head)) 
    {
        printf("出队元素: %d\n", head);
    }

    printf("出队后队列长度: %d\n", QueueLength(Q));

    printf("队列头部元素: %d\n", GetHead(Q));

    DestroyQueue(&Q);

    return 0;
}

```

##### 链队列式：

```c
//链队列
#include <stdio.h>
#include <stdlib.h>

#define MAXQSIZE 100
#define OVERFLOW -1
#define ERROR 0
#define OK 1

typedef int QElemType;
typedef int Status;

// 循环队列
typedef struct {
    QElemType *base;
    int front;
    int rear;
} SqQueue;

Status InitQueue(SqQueue *Q) 
{
    Q->base = (QElemType*) malloc(MAXQSIZE * sizeof(QElemType));
    if (!Q->base) 
    {
        exit(OVERFLOW);
    }
    Q->front = Q->rear = 0;
    return OK;
}

int QueueLength(SqQueue Q) 
{
    return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;
}

Status EnQueue(SqQueue *Q, QElemType e) 
{
    if ((Q->rear + 1) % MAXQSIZE == Q->front) 
    {
        return ERROR; // 队列已满
    }
    Q->base[Q->rear] = e;
    Q->rear = (Q->rear + 1) % MAXQSIZE;
    return OK;
}

Status DeQueue(SqQueue *Q, QElemType *e) 
{
    if (Q->front == Q->rear) 
    {
        return ERROR; // 队列为空
    }
    *e = Q->base[Q->front]; // 保存值
    Q->front = (Q->front + 1) % MAXQSIZE;
    return OK;
}

QElemType GetHead(SqQueue Q) 
{
    if (Q.front != Q.rear) 
    { // 队列不为空
        return Q.base[Q.front]; // 返回值
    }
    // 处理空队列
    return -1; // 或其他适当值
}

void DestroyQueue(SqQueue *Q) 
{
    free(Q->base);
    Q->base = NULL;
    Q->front = Q->rear = 0;
}

int main() 
{
    SqQueue Q;
    InitQueue(&Q);
    EnQueue(&Q, 1);
    EnQueue(&Q, 2);
    EnQueue(&Q, 3);

    printf("队列长度: %d\n", QueueLength(Q));

    QElemType head;
    if (DeQueue(&Q, &head)) 
    {
        printf("出队元素: %d\n", head);
    }

    printf("出队后队列长度: %d\n", QueueLength(Q));

    printf("队列头部元素: %d\n", GetHead(Q));

    DestroyQueue(&Q);

    return 0;
}

```



#### 课外拓展题：

##### 判断字符串回文：

```c
#include <stdio.h>
#include <stdlib.h>

/* run this program using the console pauser or add your own getch, system("pause") or input loop */


#define MAXSIZE 100
#define OVERFLOW -1
#define ERROR 0
#define OK 1

typedef struct
{
    char *base;
    char *top;
    int stackSize;
}SqStack;

typedef struct
{
    char *base;
    int front;
    int rear;
}SqQueue;

void InitStack(SqStack *S)
{
    S->base = (char*)malloc(sizeof (char)*MAXSIZE);
    if(!S->base)
    {
        return;
    }
    S->top = S->base;
    S->stackSize = MAXSIZE;
    return ;
}
void Push(SqStack *S,char e)
{
    if(S->top - S->base == S->stackSize)
    {
        return ;
    }
    *S->top ++= e;
}

void Pop(SqStack *S,char*e)
{
    if(S->top - S->base == 0)
    {
        return;
    }
    *e = *--S->top;
}


void InitQueue(SqQueue *Q)
{
    Q->base = (char *) malloc(MAXSIZE*sizeof (char));
    if(!Q->base)
    {
        return ;
    }
    Q->front = Q->rear = 0;
}

void EnQueue(SqQueue *Q,char e)
{
    if((Q->rear + 1)%MAXSIZE == Q->front)
    {
        printf("队列已满\n");
        return ;
    }
    Q->base[Q->rear] = e;
    Q->rear = (Q->rear + 1 )% MAXSIZE;
}
void DeQueue(SqQueue *Q,char *e)
{
    if(Q->front == Q->rear)
    {
        printf("队列为空\n");
        return ;
    }
    *e = Q->base[Q->front];
    Q->front = (Q->front + 1)%MAXSIZE;
}


int main(int argc, char *argv[])
{
    SqStack S;
    SqQueue Q;
    InitStack(&S);
    InitQueue(&Q);
    char s,c,q;
    while((c = getchar())!= '@')
    {
        Push(&S,c);
        EnQueue(&Q,c);
    }
    while(0 != S.top - S.base)
    {
        Pop(&S,&s);
        DeQueue(&Q,&q);
        if(s != q)
        {
            printf("不是回文字符串\n");
            return 0;
        }
    }
    printf("是回文字符串\n");
    return 0;
}
```

##### 医院排队：

```c
#include <stdio.h>
#include <malloc.h>
#include <string.h>

typedef int QElemType ;
typedef int Status;

#define ERROR 0
#define OK 1
#define MAXSIZE 100

typedef struct
{
    QElemType *base;
    int front;
    int rear;
}SqQueue;

void InitQueue(SqQueue *Q)
{
    Q->base = (int*) malloc(sizeof (int)*MAXSIZE);
    if(!Q->base)
    {
        return ;
    }
    Q->front = 0 ;
	Q->rear = 0;
}

int QueueLength(SqQueue Q)
{
    return ((Q.rear - Q.front + MAXSIZE) % MAXSIZE);
}

void EnQueue(SqQueue *Q,QElemType e)
{
    if((Q->rear + 1) %MAXSIZE == Q->front)
    {
        return ;
    }
    Q->base[Q->rear] = e;
    Q->rear = (Q->rear + 1)%MAXSIZE;
}

void DeQueue(SqQueue *Q,QElemType *e)
{
    if(Q->front == Q->rear)
    {
        return;
    }
    *e = Q->base[Q->front];
    Q->front = (Q->front - 1)%MAXSIZE;
}


void SeeDoctor()
{
    SqQueue Q;
    int n;
    InitQueue(&Q);
    int flag = 1;
    while(flag)
    {
    	char ch;
        printf("请输入命令\n");
        scanf("%c",&ch);
        getchar();
        switch(ch)
        {
            case 'a' :
	            {
	                printf("病例号：\n");
	                scanf("%d",&n);
	                getchar();
	                EnQueue(&Q,n);
	                break;
	            }
            case 'n':
            {
                if(QueueLength(Q) != 0)
                {
                    DeQueue(&Q,&n);
                    printf("病历号为%d的病人就诊\n",n);
                }
                else
                {
                    printf("无病人等待就诊\n");
                }
                break;
            }
            case 'q':
            {
                printf("今天停止挂号，下列病人依次就诊\n");
                while(QueueLength(Q) == 0)
                {
                    DeQueue(&Q,&n);
                    printf("%d",n);
                }
                flag = 0;
                break;
            }
            default:
                break;
        }
    }
}

int main()
{
    SeeDoctor();
    return 0;
}
```



#### 1. 基于顺序表的队列基本操作

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1

typedef int QElemType;
typedef int Status;

#define MAXQSIZE 100

typedef struct {
    QElemType *base;
    int front;
    int rear;
} SqQueue;

Status InitQueue(SqQueue *Q) 
{
    Q->base = (QElemType*)malloc(MAXQSIZE * sizeof(QElemType));
    if (!Q->base) 
    {
        exit(ERROR);
    }
    Q->front = Q->rear = 0;
    return OK;
}

Status QueueEmpty(SqQueue Q) 
{
    return Q.front == Q.rear ? OK : ERROR;
}

int QueueLength(SqQueue Q) 
{
    return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;
}

Status GetHead(SqQueue Q, QElemType *e) 
{
    if (QueueEmpty(Q)) 
    {
        return ERROR;
    }
    *e = Q.base[Q.front];
    return OK;
}

Status DeQueue(SqQueue *Q, QElemType *e) 
{
    if (QueueEmpty(*Q)) 
    {
        return ERROR;
    }
    *e = Q->base[Q->front];
    Q->front = (Q->front + 1) % MAXQSIZE;
    return OK;
}

Status EnQueue(SqQueue *Q, QElemType e) 
{
    if ((Q->rear + 1) % MAXQSIZE == Q->front) 
    {
        return ERROR;
    }
    Q->base[Q->rear] = e;
    Q->rear = (Q->rear + 1) % MAXQSIZE;
    return OK;
}

void PrintQueue(SqQueue Q) 
{
    int i = Q.front;
    while (i != Q.rear) 
    {
        printf("%d ", Q.base[i]);
        i = (i + 1) % MAXQSIZE;
    }
    printf("\n");
}

int main() 
{
    SqQueue Q;
    InitQueue(&Q);
    int e;
    while (1) 
    {
        scanf("%d", &e);
        if (e == -1) 
        {
            break;
        }
        EnQueue(&Q, e);
    }
    PrintQueue(Q);
    printf("%d\n", QueueLength(Q));
    int n = QueueLength(Q);
    for (int i = 0; i < n; ++i) 
    {
        if (DeQueue(&Q, &e)) 
        {
            printf("%d ", e);
        }
    }
    printf("\n");
    return OK;
}

```



#### 2. 基于链表的队列合并



```c
//自己写的代码及老师给的代码模板
#include <stdio.h>  
#include <stdlib.h>  
#include <malloc.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef struct 
{
    char name;    
    int arriveTime;  
} QElemType;

typedef int Status;

typedef struct Qnode 
{
    QElemType   data;
    struct Qnode* next;
} QNode, * QueuePtr;

typedef struct
{
    QueuePtr  front;  //front pointer
    QueuePtr  rear;   //rear pointer
} LinkQueue;

Status InitQueue(LinkQueue* Q)
{
    Q->front = (QNode*)malloc(sizeof(QNode));
    if (Q->front == NULL)
        return ERROR;
    Q->rear = Q->front;
    Q->rear->next = NULL;
    return OK;
}

Status QueueEmpty(LinkQueue Q)
{
    if (Q.front == Q.rear)
        return OK;
    else
        return ERROR;
}

int QueueLength(LinkQueue Q) 
{
    QNode* p;
    p = Q.front->next;
    int length = 0;
    for (; p->next != NULL; p = p->next)
        length++;
    return length;
}

Status GetHead(LinkQueue Q, QElemType* e) 
{
    if (Q.front == Q.rear)
        return ERROR;
    *e = Q.front->next->data;
    return OK;
}

Status DeQueue(LinkQueue *Q, QElemType* e) 
{
    QNode* p;
    if (Q->front == Q->rear)
        return ERROR;
    p = Q->front->next;
    *e = Q->front->next->data;
    Q->front->next = Q->front->next->next;
    if (p == Q->rear)
        Q->rear = Q->front;
    return OK;
}

Status EnQueue(LinkQueue* Q, QElemType e) 
{
    QNode* p;
    p = (QNode*)malloc(sizeof(QNode));
    if (p == NULL)
        return ERROR;
    p->data = e;
    p->next = NULL;
    Q->rear->next = p;
    Q->rear = Q->rear->next;
    return OK;
}

void PrintQueue(LinkQueue Q) 
{
    QNode* p;
    p = Q.front->next;
    while (p != NULL) 
    {
        printf("(%c,%d)\n", p->data.name, p->data.arriveTime);
        p = p->next;
    }
}

void mergeQueue(LinkQueue *Q1, LinkQueue* Q2, LinkQueue* Q3) 
{
    QElemType e1,e2,e3;
    while(!QueueEmpty(*Q1) && !QueueEmpty(*Q2))
    {
        GetHead(*Q1,&e1);
        GetHead(*Q2,&e2);
        if(e1.arriveTime > e2.arriveTime)  
        {
            EnQueue(Q3,e2);
            DeQueue(Q2,&e2);
        }
        else 
        {
             EnQueue(Q3,e1);
             DeQueue(Q1,&e1);
        }
    }
    while(!QueueEmpty(*Q1))
    {
        GetHead(*Q1,&e1);
        EnQueue(Q3,e1);
        DeQueue(Q1,&e1);
    }
    while(!QueueEmpty(*Q2))
    {
        GetHead(*Q2,&e2);
        EnQueue(Q3,e2);
        DeQueue(Q2,&e2);
    }
}

int main()
{
    LinkQueue Q1, Q2, Q3;
    char c;
    int length1, length2;
    QElemType QData;
    InitQueue(&Q1);
    InitQueue(&Q2);
    InitQueue(&Q3);
    scanf("%d", &length1);
    c=getchar();
    int i = 0;
    for (; i <= length1 - 1; i++) 
    {
        scanf("%c%d", &QData.name, &QData.arriveTime);
        EnQueue(&Q1, QData);
        c = getchar();
    }
    scanf("%d", &length2);
    c = getchar();
    for (i = 0; i <= length2 - 1; i++)
    {
        scanf("%c%d", &QData.name, &QData.arriveTime);
        EnQueue(&Q2, QData);
        c = getchar();
    }
    mergeQueue(&Q1, &Q2, &Q3);
    printf("%d\n", length1 + length2);
    PrintQueue(Q3);
}

```



```c
//AI优化后的代码
#include <stdio.h>  
#include <stdlib.h>  

#define ERROR 0
#define OK 1

typedef struct {
    char name;    
    int arriveTime;  
} QElemType;

typedef int Status;

typedef struct Qnode {
    QElemType   data;
    struct Qnode* next;
} QNode, * QueuePtr;

typedef struct {
    QueuePtr  front;  //front pointer
    QueuePtr  rear;   //rear pointer
    int length;       // Length of the queue
} LinkQueue;

// initialization of linked list based queue
Status InitQueue(LinkQueue* Q) 
{
    Q->front = (QNode*)malloc(sizeof(QNode));
    if (Q->front == NULL)
        return ERROR;
    Q->rear = Q->front;
    Q->rear->next = NULL;
    Q->length = 0; // Initialize length to 0
    return OK;
}

// Test empty queue
Status QueueEmpty(LinkQueue Q) 
{
    if (Q.front == Q.rear)
        return OK;
    else
        return ERROR;
}

// Get the length of a queue
int QueueLength(LinkQueue Q) 
{
    return Q.length; // Return length directly
}

// Get front item of a queue
Status GetHead(LinkQueue Q, QElemType* e) 
{
    if (Q.front == Q.rear)
        return ERROR;
    *e = Q.front->next->data;
    return OK;
}

// Delete an item from the queue
Status DeQueue(LinkQueue *Q, QElemType* e) 
{
    QNode* p;
    if (Q->front == Q->rear)
        return ERROR;
    p = Q->front->next;
    *e = Q->front->next->data;
    Q->front->next = Q->front->next->next;
     /*下一行是检查被出队的节点 (p) 是否是队列中唯一的节点。
	如果 p 是队列中唯一的节点，意味着在出队这个节点后，队列将变为空。在这种情况下，队列的前后指针都应该指向同一个节点（即头节		点）。这是因为在空队列中，前后指针都应该指向同一个节点以表示队列为空。*/
    if (p == Q->rear)
        Q->rear = Q->front;
    Q->length--; // Update length
    free(p); // Free memory
    return OK;
}

// Insert an item into the queue
Status EnQueue(LinkQueue* Q, QElemType e) 
{
    QNode* p;
    p = (QNode*)malloc(sizeof(QNode));
    if (p == NULL)
        return ERROR;
    p->data = e;
    p->next = NULL;
    Q->rear->next = p;
    Q->rear = Q->rear->next;
    Q->length++; // Update length
    return OK;
}

// Print the elements in a queue
void PrintQueue(LinkQueue Q) 
{
    QNode* p;
    p = Q.front->next;
    while (p != NULL) {
        printf("(%c,%d)\n", p->data.name, p->data.arriveTime);
        p = p->next;
    }
}

// Merge two queues
void mergeQueue(LinkQueue *Q1, LinkQueue* Q2, LinkQueue* Q3) 
{
    QElemType e1, e2;
    while (!QueueEmpty(*Q1) && !QueueEmpty(*Q2)) 
    {
        GetHead(*Q1, &e1);
        GetHead(*Q2, &e2);
        if (e1.arriveTime > e2.arriveTime) 
        {
            EnQueue(Q3, e2);
            DeQueue(Q2, &e2);
        } 
        else 
        {
            EnQueue(Q3, e1);
            DeQueue(Q1, &e1);
        }
    }
    while (!QueueEmpty(*Q1)) 
    {
        GetHead(*Q1, &e1);
        EnQueue(Q3, e1);
        DeQueue(Q1, &e1);
    }
    while (!QueueEmpty(*Q2)) 
    {
        GetHead(*Q2, &e2);
        EnQueue(Q3, e2);
        DeQueue(Q2, &e2);
    }
}

int main() 
{
    LinkQueue Q1, Q2, Q3;
    char c;
    int length1, length2;
    QElemType QData;
    
    // Initialize queues
    InitQueue(&Q1);
    InitQueue(&Q2);
    InitQueue(&Q3);

    // Input for queue 1
    scanf("%d", &length1);
    c = getchar(); // consume newline character
    for (int i = 0; i < length1; i++) 
    {
        scanf("%c%d", &QData.name, &QData.arriveTime);
        EnQueue(&Q1, QData);
        c = getchar(); // consume newline character
    }

    // Input for queue 2
    scanf("%d", &length2);
    c = getchar(); // consume newline character
    for (int i = 0; i < length2; i++) 
    {
        scanf("%c%d", &QData.name, &QData.arriveTime);
        EnQueue(&Q2, QData);
        c = getchar(); // consume newline character
    }

    // Merge queues
    mergeQueue(&Q1, &Q2, &Q3);

    // Output total length and merged queue
    printf("%d\n", length1 + length2);
    PrintQueue(Q3);

    return 0;
}
```



#### 3. 队列9-约瑟夫环问题

```c
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 36 //存储空间的初始分配量 

typedef struct {
    int data[MAXSIZE];
    int front;
    int rear;
} SqQueue; 

void InitQueue(SqQueue *Q) 
{
    Q->front = Q->rear = 0;
}

int QueueLength(SqQueue Q) 
{
    return ((Q.rear - Q.front + MAXSIZE) % MAXSIZE);
}

void EnQueue(SqQueue *Q, int e) 
{
    if ((Q->rear + 1) % MAXSIZE == Q->front) return; // 队列已满
    Q->data[Q->rear] = e;
    Q->rear = (Q->rear + 1) % MAXSIZE;
}

void DeQueue(SqQueue *Q, int *e) 
{
    if (Q->front == Q->rear) return; // 队列为空
    *e = Q->data[Q->front];
    Q->front = (Q->front + 1) % MAXSIZE;
}

void joseph_ring(int n, int m, int k) 
{
    SqQueue Q;
    InitQueue(&Q);
    int i, e;
    for (i = 0; i < n; i++) 
    {
        EnQueue(&Q, i + 1);
    }
    for (i = 0; i < k - 1; i++) 
    {
        int e;
        DeQueue(&Q, &e);
        EnQueue(&Q, e);
    }
    while (QueueLength(Q)) 
    {
        for (i = 0; i < m - 1; i++) 
        {
            DeQueue(&Q, &e);
            EnQueue(&Q, e);
        }
        DeQueue(&Q, &e);
        printf("%d ", e);
    }
    printf("\n");
}

int main(int argc, char *argv[]) 
{
    int m, n, k;
    scanf("%d%d%d", &n, &m, &k);
    joseph_ring(n, m, k);
    return 0;
}

```



#### 4. 队列7-杨辉三角

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

typedef struct {
    int data[MAX_SIZE];
    int front;
    int rear;
} Queue;

void initQueue(Queue *q) {
    q->front = q->rear = 0;
}

int isEmpty(Queue *q) {
    return q->front == q->rear;
}
int QueueLength(Queue Q)
{
    return (Q.rear - Q.front+ MAX_SIZE )%MAX_SIZE;
}

void enqueue(Queue *q, int value) {
    if(QueueLength(*q) == MAX_SIZE - 1)	return ;
    q->data[q->rear] = value;
    q->rear = (q->rear + 1) % MAX_SIZE;
}

int dequeue(Queue *q) {
    if(isEmpty(q))	return 0;
    int value = q->data[q->front];
    q->front = (q->front + 1) % MAX_SIZE;
    return value;
}

void printYanghuiTriangle(int n) {
    Queue q;
    initQueue(&q);
    
    enqueue(&q, 1);  // 第一行的1
    
    for (int i = 0; i < n; i++) {
        int previous = 0;
        for (int j = 0; j <= i; j++) {
            int current = dequeue(&q);
            printf("%4d", current);
            
            // 计算下一行的数字并入队
            enqueue(&q, current + previous);
            previous = current;
        }
        enqueue(&q, 1);  // 每行最后一个数字是1
        printf("\n");
    }
}

int main() {
    int n;
    //printf("请输入一个数字(2到9之间): ");做题时要加入判断
    scanf("%d", &n);

    printYanghuiTriangle(n);

    return 0;
}

```



#### 5. 数据结构和ACM2023-第四章-循环队列判断回文- LJD

```c
#include "stdio.h"
#include "stdlib.h"
#include "string.h"

#define OK 1
#define ERROR 0
#define TURE 1
#define FALSE 0
#define MAXSIZE 36 //存储空间的初始分配量

typedef int Status;
typedef char QElemType;

typedef struct {
    QElemType data[MAXSIZE];
    int front;
    int rear;
} SqQueue;

int QueueLength(SqQueue Q) 
{
    return ((Q.rear - Q.front + MAXSIZE) % MAXSIZE); 
}

Status EnQueue(SqQueue *Q, QElemType d) 
{
    if (QueueLength(*Q) == MAXSIZE) 
    {
        return ERROR;
    }
    Q->data[Q->rear] = d;
    Q->rear = (Q->rear + 1) % MAXSIZE;
    return OK;
}

Status DeQueue(SqQueue *Q, QElemType *d) 
{
    if (!QueueLength(*Q)) 
    {
        return ERROR;
    }
    *d = Q->data[Q->front];
    Q->front = (Q->front + 1) % MAXSIZE;
    return OK;
}

int main() 
{
    int i, j, d = 1;
    char a[20];
    SqQueue Q;
    Q.front = 0;
    Q.rear = 0;

    for (i = 0;; i++) 
    {
        scanf("%c", &a[i]);
        if (a[i] == '@')
            break;
        else
            EnQueue(&Q, a[i]);
    }

    j = QueueLength(Q);

    for (i = 0; i < (j + 1) / 2; i++) 
    {
        if (Q.data[Q.front + i] == Q.data[Q.rear - i - 1])
            d = 1;
        else 
        {
            d = 0;
            break;
        }
    }

    if (d == 0)  
    {
        printf("此字符串不是回文\n");
    }
    else if (d == 1) 
    {
        printf("此字符串为回文\n");
    }

    return 0;
}
```



#### 6. 队列实验

```c
#include <stdio.h>
#include "stdlib.h"
#include <malloc.h>
#include <string.h>

#define OK 1
#define ERROR 0
#define OVERFLOW -1
#define TRUE 1
#define FALSE -2

/*定义队列节点结构体类型、和队列节点结构体指针类型*/ 
typedef struct QUEUE_NODE 
{ 
	int data;
	struct QUEUE_NODE *next; 
//    补充完整
} QUEUE_NODE, *QUEUE_NODE_PTR; 

/*队列结构体类型、和队列结构体指针类型定义，包括：
  队列真实长度；
  队头位置指针；
  队尾位置指针*/ 
typedef struct 
{ 
    int Len; 
    QUEUE_NODE_PTR front;
    QUEUE_NODE_PTR rear;
//    补充完整
} LINK_QUEUE, *LINK_QUEUE_PTR; 

/*队列初始化函数，要求生成头结点，并将队列头指针、尾指针和长度正确赋值*/ 
int InitQueue(LINK_QUEUE *q) 
{  
	q->front = (QUEUE_NODE_PTR)malloc(sizeof(QUEUE_NODE));
	if(!q->front) return ERROR;
	q->rear = q->front;
	q->rear->next = NULL;
	return OK;
//    补充完整
    return 1; /*初始化成功返回1*/ 
} 

/*.队列判空函数，要求：
函数接口定义为：int IsQueueEmpty(LINK_QUEUE *q)；
2.输入参数：待判空队列q；
3 处理规则及返回值：通过队列长度元素判空。
                     队列为空返回1；队列非空返回0.*/
int IsQueueEmpty(LINK_QUEUE *q) 
{ 
	return ((q->Len == 0)?1:0); 
//    补充完整
}

/*.入队列函数，要求：
1.函数接口定义为：int EnQueue(LINK_QUEUE *q, int MRN)；
2.输入参数：待操作队列名q，待入队列数值（病例号）MRN；
3 处理规则及返回值：从内存堆中申请一个队列结点大小的存储空间作为新的队列结点newNode，给节点数据域赋值MRN，指针域为空。
    将队列队尾结点的指针域指向新节点newNode，队尾指针指向新节点newNode。
    入队列成功时返回1，入队列失败时返回0.*/
int EnQueue(LINK_QUEUE *q, int MRN) 
{ 
	QUEUE_NODE_PTR p ;
	p = (QUEUE_NODE_PTR)malloc(sizeof(QUEUE_NODE));
	if(!p)	return ERROR;
	p->data = MRN;
	p->next = q->rear->next;
	q->rear->next = p;
	q->rear = q->rear->next;
	q->Len ++;
	return OK;
//    补充完整
} 
 

/*.出队列函数，要求：
.函数接口定义为：int DeQueue(LINK_QUEUE *q)；
2.输入参数：待操作队列q；
3 处理规则及返回值：取队头节点，将其数据域数值作为返回值输出。
                     删除队头结点，并将头节点的next指针指向新的队头节点；
                     当出队列失败时返回0；成功时返回原队头结点的数据域数值。*/
int DeQueue(LINK_QUEUE *q) 
{  
	if(IsQueueEmpty(q))	return ERROR;
    int mn;
    QUEUE_NODE_PTR p = q->front->next;
    mn = p->data;
    q->front->next = q->front->next->next;
	if(p == q->rear ) q->rear = q->front;
	q->Len --;
	free(p);	 
//    补充完整
    return mn;//返回原队头结点的病历号 
} 

/*.销毁队列函数，要求：
函数接口定义为：int DestroyQueue(LINK_QUEUE *q)
2.输入参数：待销毁队列q；
3 处理规则及返回值：在队尾指针的辅助下，从头至尾逐一释放队列结点空间。
                     销毁成功返回1；否则，返回0.*/
int DestroyQueue(LINK_QUEUE *q) 
{ 
    /*一般防护：如果队列不存在，返回错误*/ 
    if(q->front == NULL) 
    { 
        return 0; 
    } 
    /*在队尾指针的辅助下，从头至尾逐一释放队列结点空间*/
    while(q->Len)
    {
    	DeQueue(q);
	}
    q->front = q->rear = NULL; 
//    补充完整
    return 1; 
} 

/*.队列遍历函数，要求：
.函数接口定义为：int QTraverse(LINK_QUEUE *q)
2.输入参数：进行遍历的队列q；
3 处理规则及返回值：从首至尾遍历队列，依次打印输出所有队列结点数据域数值。数值之间间隔一个制表符位置；
                     遍历成功返回1；队列不存在或为空返回0*/
int QTraverse(LINK_QUEUE *q) 
{ 
    QUEUE_NODE_PTR p; 
    /*队列不存在或为空返回0*/ 
    if(q->front == NULL || q->Len == 0) 
    { 
        return 0; 
    } 
    /*从队列第一个元素开始遍历队列，依次打印输出所有队列结点数据域数值，每次循环结束p后移一个节点*/ 
    for(p=q->front->next; p!=NULL; p= p->next) 
    { 
        printf("%d\t", p->data); 
    } 
    return 1; 
} 

/**************************************************************************/ 
/*                                                                        */ 
/**************************************************************************/ 

int main() 
{ 
    LINK_QUEUE QPatient ={0};//定义病人队列 
    int flag = 1; /*上下班标志位： 1为上班，0为下班*/ 
    int Medical_Record_NO = 0; 
    char ch = 0; 
    char a[100];
    int length;
    int index;
    //初始化病人对列 
    InitQueue(&QPatient); 
    //输入处理命令 
    gets(a); 
    length = strlen(a); 
    index = 0; 
    /*上班时，依次处理各个输入命令*/ 
    while( (flag==1) && (index<length) ) 
    { 
        ch = a[index] &0xff; /*从控制台接收命令*/ 
        index++; 
        switch (ch) 
        { 
            case 'a': 
                /*新增病人排至队尾*/ 
                Medical_Record_NO=Medical_Record_NO+1;  /*记录病人数量*/
                EnQueue(&QPatient, Medical_Record_NO); 
                printf("\nYour patient's No. is:%d.\t", Medical_Record_NO); 
                printf("There are %d patient(s) waiting ahead of you.", QPatient.Len); 
                break; 
            case 'n': 
                /*队头病人出队看病*/ 
                if(!IsQueueEmpty(&QPatient)) 
                { 
                    Medical_Record_NO = DeQueue(&QPatient); 
                    printf("\nPatient No. %d, please go to the clinic", Medical_Record_NO); 
                } 
                else 
                { 
                    printf("\n No patient is waiting in line.\n"); 
                } 
                break; 
            case 'q': 
                /*下班：如果队列中还有病人则依次出队，否则打印hello*/ 
                if(!IsQueueEmpty(&QPatient)) 
                { 
                    printf("\nIt is the end of today. Following patients please go to the clinic in turn: "); 
                    QTraverse(&QPatient); 
                    printf("\n"); 
                } 
                else 
                {                    
                    printf("hello\n"); 
                } 
                flag = 0;//置下班标志 
                //销毁队列 
                DestroyQueue(&QPatient); 
                break; 
            default: 
                printf("ERROR\n"); 
                break; 
        }// end of switch(ch) 
    }//end of while() 
    return 0; 
} 

```



### 作业6——串

#### 学习代码：

##### 定长顺序存储：

```c
#include <stdio.h>
#include <string.h>

#define MAXSTRLEN 255
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

typedef int Status;
typedef unsigned char SString[MAXSTRLEN + 1];

// Function to clear the string
Status ClearString(SString S) {
    S[0] = '\0';
    return OK;
}

// Function to get the length of the string
int StrLength(SString S) {
    return S[0];
}

// Function to check if the string is empty
Status StrEmpty(SString S) {
    return (S[0] == 0) ? TRUE : FALSE;
}

// Function to assign a character array to the string
Status StrAssign(SString T, char *chars) {
    int len = strlen(chars);
    
    //在不能使用 strlen函数的情况下，求chars的长度i
    //for(int i = 0,c = chars;*c != '\0';++i, ++c)    
    
    if (len > MAXSTRLEN) return ERROR;
    T[0] = len;
    for (int i = 1; i <= len; i++) {
        T[i] = *(chars + i - 1);
    }
    return OK;
}

// Function to copy one string to another
Status StrCopy(SString T, SString S) {
    for (int i = 0; i <= S[0]; i++) {
        T[i] = S[i];
    }
    return OK;
}

// Function to compare two strings
int StrCompare(SString S, SString T) {
    for (int i = 1; i <= S[0] && i <= T[0]; ++i) {
        if (S[i] != T[i]) return S[i] - T[i];
    }
    return S[0] - T[0];
}

// Function to concatenate two strings
Status Concat(SString T, SString S1, SString S2) {
    if (S1[0] + S2[0] <= MAXSTRLEN) {//未截断
        StrCopy(T, S1);
        for (int i = 1; i <= S2[0]; i++) {
            T[S1[0] + i] = S2[i];
        }
        T[0] = S1[0] + S2[0];
        return OK;
    } 
    else {
        return ERROR;
    }
}

Status Concat(SString T, SString S1, SString S2) 
{
    StrCopy(T, S1);
    memmove(T + S1[0] + 1, S2 + 1, MAXSTRLEN - S1[0]);
    if (S1[0] + S2[0] <= MAXSTRLEN) 
    {
        T[0] = S1[0] + S2[0];
        return OK;
    } 
    else 
    {
        T[0] = MAXSTRLEN;
        T[MAXSTRLEN] = '\0';
        return ERROR;
    }
}


// Function to concatenate two strings
Status Concat(SString T, SString S1, SString S2) {
    if (S1[0] + S2[0] <= MAXSTRLEN) 
    { // 未截断
        StrCopy(T, S1);
        for (int i = 1; i <= S2[0]; i++) 
        {
            T[S1[0] + i] = S2[i];
        }
        T[0] = S1[0] + S2[0];
        return OK;
    } 
    else 
    {
            StrCopy(T, S1);
            for (int i = 1; i <= MAXSTRLEN - S1[0]; i++) 
            {
                T[S1[0] + i] = S2[i];
            }
            T[0] = MAXSTRLEN; // 设置T的长度为最大长度
         	T[MAXSTRLEN] = '\0'; // 添加字符串结束符
            return ERROR;
    }
}



// Function to extract a substring from a string
Status SubString(SString Sub, SString S, int pos, int len) {
    if (pos < 1 || pos > S[0] || len < 0 || pos + len - 1 > S[0]) return ERROR;
    for (int i = 1; i <= len; i++) {
        Sub[i] = S[pos + i - 1];
    }
    Sub[0] = len;
    return OK;
}

// Function to insert a string into another string at a specified position
Status StrInsert(SString S, int pos, SString T) {
    if (pos < 1 || pos > S[0] + 1) return ERROR;
    if (S[0] + T[0] <= MAXSTRLEN) {//完全插入
        for (int i = S[0]; i >= pos; i--) {
            S[i + T[0]] = S[i];
        }
        for (int i = pos; i < pos + T[0]; i++) {
            S[i] = T[i - pos + 1];
        }
        S[0] = S[0] + T[0];
        return OK;
    } 
    else 
    {//部分插入
        for (int i = MAXSTRLEN; i >= pos + T[0]; i--) {
            S[i] = S[i - T[0]];
        }
        for (int i = pos; i < pos + T[0]; i++) {
            S[i] = T[i - pos + 1];
        }
        S[0] = MAXSTRLEN;
        return ERROR;
    }
}

// Function to delete a substring from a string
Status StrDelete(SString S, int pos, int len) {
    if (pos < 1 || pos + len - 1 > S[0] || len < 0) return ERROR;
    for (int i = pos + len; i <= S[0]; i++) {
        S[i - len] = S[i];
    }
    S[0] -= len;
    return OK;
}

// Function to find the first occurrence of a substring in a string
int Index(SString S, SString T, int pos) {
    int n, m;
    if (pos < 0) return ERROR;
    n = StrLength(S);
    m = StrLength(T);
    int i = pos;
    while (i <= n - m + 1) {
        SString sub;
        SubString(sub, S, i, m);
        if (StrCompare(sub, T) != 0) {
            ++i;
        } else {
            return i;
        }
    }
    return 0;
}

// Function to replace all occurrences of a substring in a string with another substring
Status Replace(SString S, SString T, SString V) {
    int i = 1;
    if (StrEmpty(T)) return ERROR;
    do {
        i = Index(S, T, i);
        if (i) {
            StrDelete(S, i, StrLength(T));
            StrInsert(S, i, V);
            i += StrLength(V);
        }
    } while (i);
    return OK;
}

int main() {
    SString s, t, v;

    // Example usage
    StrAssign(s, "Hello");
    StrAssign(t, "l");
    StrAssign(v, "XYZ");

    Replace(s, t, v);

    printf("%s\n", s + 1); // Output should be "HeXYZo"

    return 0;
}
```

##### 堆分配存储表示：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef int Status;

#define MAXSTRLEN 255

#define OK 1
#define ERROR 0
#define FALSE -1
#define TRUE 2
#define OVERFLOW -2

typedef struct {
    char *ch;   // Pointer to the dynamic array storing the characters of the string
    int length; // Length of the string
} HString;

// Function to initialize a string
Status InitString(HString *T) {
    T->length = 0;
    T->ch = NULL;
    return OK;
}

// Function to clear the string
Status ClearString(HString *S) {
    if (S->ch) {
        free(S->ch);
        S->ch = NULL; // Set the pointer to NULL after freeing the memory
        S->length = 0;
    }
    return OK;
}

// Function to assign a character array to a string
Status StrAssign(HString *T, char *chars) {
    int i = strlen(chars);
    if (!i) {
        T->ch = NULL;
        T->length = 0;
    } else {
        T->ch = (char*)malloc((i + 1) * sizeof(char)); // Allocate memory for the string including '\0'
        if (!T->ch) exit(OVERFLOW);
        strcpy(T->ch, chars); // Use strcpy to copy characters from chars to T->ch
        T->length = i;
    }
    return OK;
}

// Function to copy a string
Status StrCopy(HString *T, HString S) {
    T->ch = (char*)malloc((S.length + 1) * sizeof(char)); // Allocate memory for the string including '\0'
    if (!T->ch) return ERROR;
    strcpy(T->ch, S.ch); // Use strcpy to copy characters from S.ch to T->ch
    T->length = S.length;
    return OK;
}

// Function to check if a string is empty
Status StrEmpty(HString S) {
    return (S.length == 0 && S.ch == NULL) ? TRUE : FALSE;
}

// Function to get the length of a string
int StrLength(HString S) {
    return S.length;
}

// Function to compare two strings

//使用strcmp函数的字符串比较
//int StrCompare(HString S, HString T) {
//    return strcmp(S.ch, T.ch); // Use strcmp to compare strings
//}

//不使用函数的字符串比较
int StrCompare(HString S, HString T) {
    int i = 0;
    while (S.ch[i] != '\0' && T.ch[i] != '\0') {
        if (S.ch[i] != T.ch[i]) {
            return S.ch[i] - T.ch[i];
        }
        i++;
    }
    // 如果两个字符串中的所有字符都相等，但其中一个字符串长度更长，则返回长度差值
    return S.length - T.length;
}

// Function to insert a string into another string at a specified position
Status StrInsert(HString *S, int pos, HString T) {
    if (pos < 1 || pos > S->length + 1) return ERROR;
    if (T.length) 
    {
        S->ch = (char*)realloc(S->ch, (S->length + T.length + 1) * sizeof(char)); // Reallocate memory
        if (!S->ch) return ERROR;
        
        memmove(S->ch + pos + T.length - 1, S->ch + pos - 1, (S->length - pos + 2) * sizeof(char)); // Move characters to make space for insertion
      
        memcpy(S->ch + pos - 1, T.ch, T.length * sizeof(char)); // Copy characters of T to the specified position in S
        S->length += T.length;
    }
    return OK;
}

// Function to delete a substring from a string
Status StrDelete(HString *S, int pos, int len) {
    if (pos < 1 || pos + len - 1 > S->length) return ERROR;
    memmove(S->ch + pos - 1, S->ch + pos + len - 1, (S->length - pos - len + 2) * sizeof(char)); // Move characters to remove the substring
    S->length -= len;
    S->ch = (char*)realloc(S->ch, (S->length + 1) * sizeof(char)); // Reallocate memory
    return OK;
}

// Function to replace all occurrences of a substring in a string with another substring
Status Replace(HString *S, HString T, HString V) {
    int i = 1;
    if (StrEmpty(T)) return ERROR;
    do {
        i = StrIndex(*S, T, i); // Call StrIndex function
        if (i) {
            StrDelete(S, i, T.length);
            StrInsert(S, i, V);
            i += V.length;
        }
    } while (i);
    return OK;
}

// Function to find the first occurrence of a substring in a string
int StrIndex(HString S, HString T, int pos) {
    int i = pos, j = 1;
    while (i <= S.length && j <= T.length) {
        if (S.ch[i - 1] == T.ch[j - 1]) {
            ++i;
            ++j;
        } 
        else {
            i = i - j + 2;
            j = 1;
        }
    }
    if (j > T.length) return i - T.length;
    else return 0;
}

int main() {
    HString s, t, v;

    // Initialize strings
    InitString(&s);
    InitString(&t);
    InitString(&v);

    // Assign values to strings
    StrAssign(&s, "Hello");
    StrAssign(&t, "l");
    StrAssign(&v, "XYZ");

    // Replace all occurrences of string t in string s with string v
    Replace(&s, t, v);

    // Output the modified string s
    printf("%s\n", s.ch);

    // Clear memory
    ClearString(&s);
    ClearString(&t);
    ClearString(&v);

    return 0;
}
```



##### BF算法：

```c
int Index(SString S,SString T,int pos)
{
    if(pos >= 1 && pos <= S[0])
    {
        int i = pos;
        int j = 1;
        while(i <= S[0] && j <= T[0])
        {
            if(S[i] == T[j])
            {
                ++i;++j;
            }
            else
            {
                i = i - j + 2;
                j = 1;
            }
        }
        if(j > T[0])    return i - T[0];//返回 离pos 的距离
        else return 0;
    }
    else return 0;
}
```



##### KMP算法

```c
// 计算子串T的next数组
void GetNext(SString T, int *next) {
    int i = 1;
    int j = 0;
    next[1] = 0;
    while (i < T[0]) 
    {
        if (j == 0 || T[i] == T[j]) 
        {
            ++i; ++j;
            next[i] = j;
        } 
        else    j = next[j];
    }
}

// 使用KMP算法在字符串S中查找子串T
int Index(SString S, SString T, int pos) {
    int i = pos;
    int j = 1;
    int s_len = S[0];
    int t_len = T[0];
    int next[MAXSTRLEN];
    GetNext(T, next); // 获取子串T的next数组

    while (i <= s_len && j <= t_len) 
    {
        if (j == 0 || S[i] == T[j]) 
        {
            ++i; ++j;
        }
        else   j = next[j]; // 根据next数组进行回溯
    }
    if (j > t_len)    return i - t_len;
    else 	   return 0;
}
```



#### 1. 串的基本操作

```c
//AIxi
#include <stdio.h>
#include <string.h>

#define MAIN_STR_LEN 100
#define SUB_STR_LEN 20

int MyStrCompare(char* Str1, char* Str2) 
{ 
    int i;
    int result = 0;
    for (i = 1; (i <= Str1[0]) && (i <= Str2[0]); i++) 
    {
        if (Str1[i] > Str2[i]) 
        {
            result = 1;
            break;
        } 
        else if (Str1[i] < Str2[i]) 
        {
            result = -1;
            break;
        } 
    }
    if (result == 0) 
    {
        if (Str1[0] > Str2[0]) 
        {
            result = 1;
        } 
        else if (Str1[0] < Str2[0]) 
        {
            result = -1;
        } 
    } 
    return result;
}

int MySubStrIndex(char* MainStr , char* SubStr , int pos) 
{
    int i, j, result;
    if ((pos < 0) || (pos > (MainStr [0] - SubStr[0] + 1))) 
    {
        return 0;
    } 
    i = pos;
    j = 1;
    while (i <= MainStr [0] && j <= SubStr [0]) 
    {
        if (MainStr[i] == SubStr[j]) 
        {
            i++;
            j++;
        } 
        else 
        {
            i = i - j + 2;
            j = 1;
        }
    }
    if (j > SubStr [0]) 
    {
        result = i - SubStr [0];
    } 
    else 
    {
        result = 0;
    }
    return result;
}

char MyStrDelete(char* S, int pos , int len) 
{
    int i;
    if (pos < 1 || pos > S[0] - len + 1 || len < 0)
        return -1;
    for (i = pos + len; i <= S[0]; i++)
        S[i - len] = S[i];
    S[0] -= len;
    return 1;
}

char MyStrInsert(char* S, int pos , char* T) 
{
    int i;
    if (pos < 1 || pos > S[0] + 1)
        return -1;
    if (S[0] + T[0] <= MAIN_STR_LEN) 
    {
        for (i = S[0]; i >= pos; i--) 
        {
            S[i + T[0]] = S[i];
        }
        for (i = pos; i < pos + T[0]; i++) 
        {
            S[i] = T[i - pos + 1];
        }
        S[0] = S[0] + T[0];
        return 1;
    } 
    else 
    {
        for (i = MAIN_STR_LEN; i <= pos; i--) 
        {
            S[i] = S[i - T[0]];
        }
        for (i = pos; i < pos + T[0]; i++) 
        {
            S[i] = T[i - pos + 1];
        }
        S[0] = MAIN_STR_LEN;
        return 0;
    }
}

int MyStrAssign(char * StrTobeAssigned , char * StrInput)

{
    int len = strlen(StrInput);
    if (len > MAIN_STR_LEN)
        return -1;
    StrTobeAssigned[0] = len;
    strcpy(&StrTobeAssigned[1], StrInput);
    return 1;
}

int MyStrReplace(char * MainStr , char * SubStr1 , char * SubStr2)

{
    int i = 1, tot = 0;
    do 
    {
        i = MySubStrIndex(MainStr, SubStr1, i);
        if (i)
        {
            MyStrDelete(MainStr, i, SubStr1[0]);
            MyStrInsert(MainStr, i, SubStr2);
            i += strlen(SubStr2);
            tot++;
        }
    } while (i);
    return tot;
}

int main() 
{
    char MainStr[MAIN_STR_LEN + 1];
    char SubStr1[SUB_STR_LEN + 1];
    char SubStr2[SUB_STR_LEN + 1];
    int i;
    int compareResult;
    int pos;
    int replaceCounter = 0;
    char InputBuf[3][MAIN_STR_LEN + 1];

    printf("please input 3 strings as MainStr , SubStr1 and SubStr2\n");
    scanf("%s %s %s", InputBuf[0], InputBuf[1], InputBuf [2]);

    if (MyStrAssign(MainStr, InputBuf[0]) == -1 || MyStrAssign(SubStr1, InputBuf[1]) == -1 || MyStrAssign(SubStr2, InputBuf[2]) == -1)
    {
        printf("Error: String length exceeds maximum length\n");
        return -1;
    }

    printf("MainStr =:%d,", MainStr[0]);
    for (i = 1; i <= MainStr[0]; i++) 
    {
        printf("%c,", MainStr[i]);
    }
    printf("\n");
    printf("SubStr1 =:%d,", SubStr1[0]);
    for (i = 1; i <= SubStr1[0]; i++) 
    {
        printf("%c,", SubStr1[i]);
    }
    printf("\n");
    printf("SubStr2 =:%d,", SubStr2[0]);
    for (i = 1; i <= SubStr2[0]; i++) 
    {
        printf("%c,", SubStr2[i]);
    }
    printf("\n");

    compareResult = MyStrCompare(SubStr1, SubStr2);
    printf("SubStr1 compare with SubStr2 is %d\n", compareResult);

    pos = MySubStrIndex(MainStr, SubStr1, 1);
    printf("pos of SubStr1 in MainStr is %d\n", pos);

    pos = MySubStrIndex(MainStr, SubStr2, 1);
    printf("pos of SubStr2 in MainStr is %d\n", pos);

    replaceCounter = MyStrReplace(MainStr, SubStr1, SubStr2);
    printf("The content of MainStr after %d times of replacing SubStr1 with SubStr2 is :\n%d,", replaceCounter , MainStr[0]);
    for (i = 1; i <= MainStr[0]; i++) 
    {
        printf("%c,", MainStr[i]);
    }
    printf("\n");
    return 0;
}
```



#### 2. 统计字符数



```c
//自己写的代码

#include <stdio.h>
#include <string.h>

#define MAXSTRLEN 100
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

typedef char SString[MAXSTRLEN + 1];

void SStringAssign(SString S,char*str)
{
	int i = 1,len = 0;
	for(;str[len] != '\0';len ++)
	for(;str[i - 1] != '\0';i ++)
	{
		S[i] = str[i - 1];
	}
	S[0] = len;
	S[len + 1] = '\0'; 
}

void CountStr(SString S,int *total)
{
	int i = 1;
	for(;i <= S[0];i ++)
	{
		total[S[i] - 'a'] ++;
	}
}

void PrintMax(int *total)
{
	int max = total[0],i = 0,max_n = 0;
	for(;i < 26;i ++)
	{
		if(max < total[i])
		{
			max = total[i] ;
			max_n = i;
		}
	}
	printf("%c %d\n",max_n + 'a',max);
}

int main(int argc, char *argv[]) 
{
	int n ;
	scanf("%d",&n);
	getchar();
	while(n --)
	{
		SString S;
		char str[MAXSTRLEN + 1000];
		scanf("%s",str); 
        str[100] = '\0';
		getchar();
		//printf("%s",str); 
		SStringAssign(S,str);
		
		int total[26] = {0};
		CountStr(S,total);
		
		PrintMax(total);			
	} 
	return 0;
}
```



```c
//AI修改的代码

#include <stdio.h>
#include <string.h>

#define MAXSTRLEN 100
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

typedef char SString[MAXSTRLEN + 2]; // 加一位存储字符串长度，一位存储字符串结尾标记

void SStringAssign(SString S, char *str) {
    int len = strlen(str);
    S[0] = len;
    strncpy(&S[1], str, MAXSTRLEN); // 将字符串复制到 SString 结构体中
    S[len + 1] = '\0'; // 添加字符串结尾标记
}

void CountStr(SString S, int *total) {
    int i;
    for (i = 1; i <= S[0]; i++) {
        total[S[i] - 'a']++;
    }
}

void PrintMax(int *total) {
    int max = total[0], i, max_n = 0;
    for (i = 0; i < 26; i++) {
        if (max < total[i]) {
            max = total[i];
            max_n = i;
        }
    }
    printf("%c %d\n", max_n + 'a', max);
}

int main(int argc, char *argv[]) {
    int n;
    scanf("%d", &n);
    getchar(); // 清除换行符
    while (n--) {
        SString S;
        char str[MAXSTRLEN + 1]; // 调整字符数组大小
        scanf("%100s", str); // 限制输入的最大长度为100个字符
        getchar(); // 清除换行符

        SStringAssign(S, str);

        int total[26] = {0};
        CountStr(S, total);

        PrintMax(total);
    }
    return 0;
}
```



#### 3.字符串连接

```c
//自编代码

#include <stdio.h>
#include <string.h>
#define MAXSTRLEN 100
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

typedef char SString[MAXSTRLEN + 1];

void StrAssign(SString S,char*str)
{
	int i = 1;
	for(;str[i - 1] != '\0';i ++)
	{
		if(str[i - 1] == '#')	break;
		S[i] = str[i - 1];
	}
	S[0] = i;
	S[i + 1] = '\0';
}

int StrConcat(SString S, SString T) {
    if (S[0] + T[0] > MAXSTRLEN) {
        return ERROR;
    }
    int i = 1;
	for(;S[i] != '\0';i++)
	{
		T[T[0] + i] = S[i];
	}
    
    T[0] += S[0];

    return OK;
}

int main(int argc, char *argv[]) 
{
	int n = 1000,i;
	char str1[n],str2[n];
       
	//scanf("%s %s",str1,str2);  //这样输入出问题了，中间有空格，就间断输入了
   
    // 读取两个字符串，以 '#' 结束
    scanf("%[^#]#", str1);
    getchar();  // 读取并丢弃换行符
    scanf("%[^#]#", str2);
    
	//printf("%s\n",str1);
	//printf("%s\n",str2);
    
	SString S,T;
	StrAssign(S,str1);
	StrAssign(T,str2);
	
	StrConcat(S,T);
	
	for(i = 1;i <= T[0];i ++)
	{
		printf("%c",T[i]);
	}
	printf("\n");
	return 0;
}
```



#### 4. 词频统计

```c
//AI跑得代码   
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_WORD_LENGTH 50
#define HASH_SIZE 1000

// 定义单词节点结构体
typedef struct WordNode {
    char word[MAX_WORD_LENGTH];
    int count;
    struct WordNode* next;
} WordNode;

// 定义哈希表结构体
typedef struct {
    WordNode* buckets[HASH_SIZE];
} HashTable;

// 哈希函数，将单词转换为哈希值
int hash(char *word) {
    int hash = 0;
    while (*word) {
        hash = (hash * 31 + *word) % HASH_SIZE;
        word++;
    }
    return hash;
}

// 创建单词节点
WordNode* createWordNode(char *word) {
    WordNode* newNode = (WordNode*)malloc(sizeof(WordNode));
    if (newNode == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }
    strcpy(newNode->word, word);
    newNode->count = 1;
    newNode->next = NULL;
    return newNode;
}

// 在哈希表中查找单词节点，如果不存在则返回NULL
WordNode* findWord(HashTable* hashTable, char *word) {
    int index = hash(word);
    WordNode* current = hashTable->buckets[index];
    while (current != NULL) {
        if (strcmp(current->word, word) == 0) {
            return current;
        }
        current = current->next;
    }
    return NULL;
}

// 向哈希表中插入单词节点，如果已存在则增加计数，否则创建新节点插入
void insertWord(HashTable* hashTable, char *word) {
    int index = hash(word);
    WordNode* current = hashTable->buckets[index];
    WordNode* previous = NULL;
    while (current != NULL) {
        if (strcmp(current->word, word) == 0) {
            current->count++;
            return;
        }
        previous = current;
        current = current->next;
    }
    // 单词不存在，创建新节点插入
    WordNode* newNode = createWordNode(word);
    if (previous == NULL) {
        hashTable->buckets[index] = newNode;
    } else {
        previous->next = newNode;
    }
}

// 比较函数，用于qsort排序
int compare(const void *a, const void *b) {
    const WordNode *word1 = *(const WordNode **)a;
    const WordNode *word2 = *(const WordNode **)b;
    // 先比较出现次数，出现次数相同时按照字典序排序
    if (word1->count != word2->count) {
        return word2->count - word1->count;
    } else {
        return strcmp(word1->word, word2->word);
    }
}

// 释放哈希表
void freeHashTable(HashTable* hashTable) {
    for (int i = 0; i < HASH_SIZE; i++) {
        WordNode* current = hashTable->buckets[i];
        while (current != NULL) {
            WordNode* temp = current;
            current = current->next;
            free(temp);
        }
    }
    free(hashTable);
}

int main() {
    // 打开文件
    FILE *file = fopen("article.txt", "r");
    if (file == NULL) {
        fprintf(stderr, "Failed to open file\n");
        return 1;
    }

    // 创建哈希表
    HashTable* hashTable = (HashTable*)malloc(sizeof(HashTable));
    if (hashTable == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        return 1;
    }
    memset(hashTable->buckets, 0, sizeof(hashTable->buckets));

    char word[MAX_WORD_LENGTH];
    // 读取文件中的每个单词并进行统计
    while (fscanf(file, "%s", word) == 1) {
        // 转换为小写
        for (int i = 0; word[i]; i++) {
            word[i] = tolower(word[i]);
        }
        // 去除单词末尾的标点符号
        int len = strlen(word);
        while (len > 0 && ispunct(word[len - 1])) {
            word[len - 1] = '\0';
            len--;
        }
        // 插入哈希表
        insertWord(hashTable, word);
    }
    fclose(file);

    // 将哈希表中的单词节点存入数组
    WordNode* wordArray[HASH_SIZE];
    int count = 0;
    for (int i = 0; i < HASH_SIZE; i++) {
        WordNode* current = hashTable->buckets[i];
        while (current != NULL) {
            wordArray[count++] = current;
            current = current->next;
        }
    }

    // 对单词节点数组按照出现次数进行排序
    qsort(wordArray, count, sizeof(WordNode*), compare);

    // 输出前100个单词及其出现次数
    int numWords = count < 100 ? count : 100;
    for (int i = 0; i < numWords; i++) {
        printf("%s %d\n", wordArray[i]->word, wordArray[i]->count);
    }

    // 释放内存
    freeHashTable(hashTable);

    return 0;
}

```



#### 5. 字符串中的第一个唯一字符

```c
//我的代码
#include <stdio.h>
#include <string.h>

#define MAXSTRLEN 300000
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

typedef char SString [MAXSTRLEN + 1]; 

void StrAssign(SString S,char*str)
{
	int i = 1;
	for(;str[i - 1] != '\0';i ++)
	{
		S[i] = str[i - 1];
	}
	S[0] = i - 1;
	S[i] = '\0';
}

int Unique_Index(SString S)
{
	if(S[0] == 0)	return -1;
	int i,j,tag;
	for(i = 1;i <= S[0];i ++)
	{
		for(j = 1;j <= S[0];j ++)
		{
			tag = -1;
			if(j == i)	continue;	
			else if(S[i] == S[j])	break;
			if(S[i] != S[j])	tag = i;
		}
		if(tag != -1)	return i - 1;
	}
	return -1;
}

int main(int argc, char *argv[]) 
{
	char str[MAXSTRLEN + 1];
	scanf("%s",str);
	
	SString S;
	StrAssign(S,str);
	
	int a = Unique_Index(S);
	printf("%d",a); 
	
	return 0;
}
```



```c
//AI跑的代码
#include <stdio.h>
#include <string.h>

#define MAXSTRLEN 300000
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

typedef char SString[MAXSTRLEN + 1];

void StrAssign(SString S, char *str) {
    int i = 1;
    for (; str[i - 1] != '\0'; i++) {
        S[i] = str[i - 1];
    }
    S[0] = i - 1; // 修正字符串长度
    S[i] = '\0';
}

int Unique_Index(SString S) {
    if (S[0] == 0) return -1; // 如果字符串为空，则返回 -1
    int i;
    int char_count[256] = {0}; // 哈希表，用于记录每个字符的出现次数
    // 第一次遍历字符串，统计每个字符出现的次数
    for (i = 1; i <= S[0]; i++) {
        char_count[(int)S[i]]++; // 将字符映射到哈希表中，并统计出现次数
    }
    // 第二次遍历字符串，找到第一个出现次数为1的字符，返回其下标
    for (i = 1; i <= S[0]; i++) {
        if (char_count[(int)S[i]] == 1) {
            return i - 1;
        }
    }
    return -1;
}

int main(int argc, char *argv[]) {
    char str[MAXSTRLEN + 1];
    scanf("%s", str);

    SString S;
    StrAssign(S, str);

    int a = Unique_Index(S);
    printf("%d", a);

    return 0;
}

```



#### 6. 求一个串中出现的第一个最长重复子串

```c
#include <stdio.h>
#include <string.h>
#include<malloc.h>

#define MAXSTRLEN 255
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

int check(char *s, int x, int n,int *pos) 
{
	int j = 0,i,k;

	for(;j < n - x + 1;j ++)
	{
		char substr[x + 1];
		for(i = j,k=0;i < x + j; i ++,k++)
		{
			substr[k] = s[i];
		}
		substr[x] = '\0';
	    int count = 0;
		for (i = 0; i <= n - x; i++) 
		{
	        if (strncmp(s + i, substr, x) == 0) 
			{
	            count++;
	        }
	        if(count == 2)
	        {
	        	*pos = j;
	        	return 1;
			}
	    } 
	}
	return 0;
}

char *search_longest_repeated_substring(char *s, int n) {
    int l = 0, r = n,pos = 0;
    while (l < r) {
        int mid = l + (r - l + 1) / 2;
        if (check(s, mid, n, &pos))    l = mid;
        else      r = mid - 1;
    }
    if (l == 0) {
        return NULL;
    }
    char *result;
	result = (char*)malloc((l + 1) * sizeof(char));
    if (result == NULL) {
        printf("内存分配失败\n");
        return NULL;
    }
    strncpy(result, s + pos, l);
    result[l] = '\0';
    return result;
}

int main() {
    char *s = malloc(MAXSTRLEN * sizeof(char));
    if (s == NULL) 
	{
        printf("内存分配失败\n");
        return 1;
    }
    scanf("%s", s);

    char *result = search_longest_repeated_substring(s, strlen(s));
    
    if (result == NULL) 
	{
        printf("没有最长重复子串\n");
    }
	 else 
	 {
        printf("%s\n", result);
        free(result);
    }

    free(s);

    return 0;
}

```



```c
//AI优化的hash算法
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAXSTRLEN 255
#define TRUE 1
#define FALSE 0
#define ERROR -1
#define OK 1

// Function to compute the hash value of a substring
unsigned long long hash(char *s, int start, int end) {
    unsigned long long hash_value = 0;
    for (int i = start; i <= end; i++) {
        hash_value = hash_value * 31 + s[i];
    }
    return hash_value;
}

// Function to check if a substring appears more than once in the string
int check(char *s, int x, int n, int *pos) {
    unsigned long long *hashes = malloc((n - x + 1) * sizeof(unsigned long long));
    if (hashes == NULL) {
        printf("内存分配失败\n");
        return ERROR;
    }

    // Precompute hashes for all substrings of length x
    for (int i = 0; i <= n - x; i++) {
        hashes[i] = hash(s, i, i + x - 1);
    }

    // Search for repeated substrings using the hashes
    for (int i = 0; i <= n - x; i++) {
        unsigned long long target_hash = hashes[i];
        int count = 0;
        for (int j = i + 1; j <= n - x; j++) {
            if (hashes[j] == target_hash) {
                count++;
                if (count == 1) {
                    *pos = i;
                    free(hashes);
                    return TRUE;
                }
            }
        }
    }

    free(hashes);
    return FALSE;
}

char *search_longest_repeated_substring(char *s, int n) {
    int l = 0, r = n, pos = 0;
    while (l < r) {
        int mid = l + (r - l + 1) / 2;
        if (check(s, mid, n, &pos))    l = mid;
        else      r = mid - 1;
    }
    if (l == 0) {
        return NULL;
    }
    char *result;
    result = (char *)malloc((l + 1) * sizeof(char));
    if (result == NULL) {
        printf("内存分配失败\n");
        return NULL;
    }
    strncpy(result, s + pos, l);
    result[l] = '\0';
    return result;
}

int main() {
    char *s = malloc(MAXSTRLEN * sizeof(char));
    if (s == NULL) {
        printf("内存分配失败\n");
        return 1;
    }
    scanf("%s", s);

    char *result = search_longest_repeated_substring(s, strlen(s));

    if (result == NULL) {
        printf("没有最长重复子串\n");
    } else {
        printf("%s\n", result);
        free(result);
    }

    free(s);

    return 0;
}

```



#### 7. Caesar密码

```c
//AI	跑的代码
#include <stdio.h>
#include <string.h>

// 函数用于解密Caesar密码
void decrypt_caesar(char *cipher_text) {
    // 定义字母替换表
    char mapping[26] = {
        'V', 'W', 'X', 'Y', 'Z', 'A', 'B', 'C', 'D', 'E',
        'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
        'P', 'Q', 'R', 'S', 'T', 'U'
    };

    // 对密码消息中的每个字符进行解密
    for (int i = 0; cipher_text[i] != '\0'; i++) {
        // 如果是字母，则进行解密
        if (cipher_text[i] >= 'A' && cipher_text[i] <= 'Z') {
            cipher_text[i] = mapping[cipher_text[i] - 'A'];
        }
    }
}

int main() {
    char line[200];

    // 读取输入直到遇到ENDOFINPUT
    while (1) {
        scanf("%s", line);
        if (strcmp(line, "ENDOFINPUT") == 0) {
            break;
        }

        if (strcmp(line, "START") == 0) {
            getchar(); // 消耗掉换行符
            fgets(line, 200, stdin); // 读取密码消息
            decrypt_caesar(line); // 解密消息
            printf("%s", line); // 输出原始消息
        }
    }

    return 0;
}

```



#### 8.判断等值子串

```c
//算法1 —— 贪心
#include <stdio.h>
#include <string.h>

void longest_equal_substring(char *s) {
    int max_length = 0;
    char *max_substring = NULL;
    
    int current_length = 1,i;
    char *current_start = s;
    for ( i = 1; s[i] != '!'; i++) {
        if (s[i] == s[i - 1]) {
            current_length++;
        } else {
            if (current_length > max_length) {
                max_length = current_length;
                max_substring = current_start;
            }
            current_length = 1;
            current_start = s + i;
        }
    }
    
    // Check the last substring
    if (current_length > max_length) {
        max_length = current_length;
        max_substring = current_start;
    }

    if (max_length > 1) {
        for (i = 0; i < max_length; i++) {
            printf("%c", max_substring[i]);
        }
    } else {
        printf("no");
    }
}

int main() {
    char input_str[1000];
    scanf("%s", input_str);
    longest_equal_substring(input_str);
    return 0;
}

```



```c
//算法2 —— 双指针
#include <stdio.h>
#include <string.h>

void longest_equal_substring(char *s) {
    int n = strlen(s);
    int max_length = 0;
    int max_start = 0;

    int start = 0; // 记录当前等值子串的起始位置
    for (int i = 1; i <= n; i++) {
        if (s[i] != s[i - 1]) {
            int length = i - start; // 计算当前等值子串的长度
            if (length > max_length) {
                max_length = length;
                max_start = start;
            }
            start = i; // 更新当前等值子串的起始位置
        }
    }

    if (max_length > 1) {
        for (int i = max_start; i < max_start + max_length; i++) {
            printf("%c", s[i]);
        }
    } else {
        printf("no");
    }
}

int main() {
    char input_str[1000];
    scanf("%s", input_str);
    longest_equal_substring(input_str);
    return 0;
}

```



```c
//算法3 —— 动态规划
#include <stdio.h>
#include <string.h>

void longest_equal_substring(char *s) {
    int n = strlen(s);
    int max_length = 0;
    int max_start = 0;
    
    int current_length = 1;
    for (int i = 1; i < n; i++) {
        if (s[i] == s[i - 1]) {
            current_length++;
        } else {
            if (current_length > max_length) {
                max_length = current_length;
                max_start = i - max_length;
            }
            current_length = 1;
        }
    }
    
    // Check the last substring
    if (current_length > max_length) {
        max_length = current_length;
        max_start = n - max_length;
    }

    if (max_length > 1) {
        for (int i = max_start; i < max_start + max_length; i++) {
            printf("%c", s[i]);
        }
    } else {
        printf("no");
    }
}

int main() {
    char input_str[1000];
    scanf("%s", input_str);
    longest_equal_substring(input_str);
    return 0;
}

```



#### 9.判断两个字符串是否匹配



```c
//我的代码 + AI优化
#include <stdio.h>
#include <stdbool.h>

#define TRUE 1
#define FALSE 0

bool isMatch(char *str1, char *str2) {
    // 当两个字符串都为空时，它们是匹配的
    if (*str1 == '\0' && *str2 == '\0')
        return TRUE;
    
    // 当其中一个字符串为空时，另一个不为空，它们不匹配
    if (*str1 == '\0' || *str2 == '\0')
        return FALSE;

    // 如果当前字符匹配或者是 '?'，则继续比较下一个字符
    if (*str1 == *str2 || *str2 == '?')
        return isMatch(str1 + 1, str2 + 1);

    // 如果遇到 '*'，则递归地尝试所有可能的情况
    if (*str2 == '*') {
        // 将 '*' 后面的子串作为模式串
        char *pattern = str2 + 1;
        
		while(*pattern == '*')	
		{
			pattern ++; 
			str1++;
		}
		       
		if(*pattern == '\0')	return TRUE;
		
		while(*pattern == '?')
		{
			pattern++;
        	str1++;
        	
        	// 当两个字符串都为空时，它们是匹配的
   			if (*str1 == '\0' && *pattern == '\0')
        		return TRUE;
        		
        	// 当其中一个字符串为空时，另一个不为空，它们不匹配
    		if (*str1 == '\0' || *str2 == '\0')
        		return FALSE;
		}
		

		
        // 在 str1 中查找所有可能的匹配
        while (*str1 != '\0') {
            if (isMatch(str1, pattern))
                return TRUE;
            str1++;
        }

        // 如果在 str1 中没有找到匹配，则返回 FALSE
        return FALSE;
    }

    // 如果当前字符不匹配，且不是通配符，则说明不匹配
    return FALSE;
}


int main() {
    char str1[1000], str2[1000];

    // 读取两个字符串，以 '#' 结束
    scanf("%[^#]#", str1);
    getchar();  // 读取并丢弃换行符
    scanf("%[^#]#", str2);
    
//    puts(str1);
//	puts(str2); 
    
    // 调用匹配函数进行匹配
    if (isMatch(str2, str1)) {
        printf("yes\n");
    } else {
        printf("no\n");
    }

    return 0;
}
```



```c
//AI跑得	有bug
#include <stdio.h>
#include <stdbool.h>
#include <string.h>

// Function to check if two strings match considering wildcard characters
bool isMatch(char *str1, char *str2) {
    // Pointers to traverse both strings
    char *s1 = str1, *s2 = str2;
    // Pointers to store the positions when '*' and '?' are encountered
    char *star = NULL, *ques = NULL;

    // Traverse until the end of the first string
    while (*s1 != '\0' && *s2 != '\0') {
        // If current characters match or '?' is encountered
        if (*s2 == *s1 || *s2 == '?') {
            s1++;
            s2++;
        }
        // If '*' is encountered in the second string
        else if (*s2 == '*') {
            star = s2; // Store the position of '*'
            ques = s1; // Store the position of corresponding character in the first string
            s2++;      // Move to the next character in the second string
        }
        // If characters don't match and there is no '*' in the second string
        // Go back to the last '*' position and try to match from there
        else if (star != NULL) {
            s2 = star + 1; // Move to the next character after '*'
            s1 = ++ques;   // Move to the next character in the first string from the last '*' position
        } else {
            return false; // If no '*' encountered and characters don't match, return false
        }
    }

    // Ignore any extra '*' characters in the second string
    while (*s2 == '*') {
        s2++;
    }

    // If both strings have reached the end, return true
    return (*s1 == '\0' && (*s2 == '\0' || (*s2 == '*' && *(s2+1) == '\0')));
}

int main() {
    // Input two strings terminated by '#'
    char str1[100], str2[100];
    scanf("%[^#]#%[^#]#", str1, str2);

    // Check if the strings match and print the result
    if (isMatch(str1, str2)) {
        printf("yes\n");
    } else {
        printf("no\n");
    }

    return 0;
}

```

```c
//leetcode 官方解答 —— 动态规划方案	仍有bug
#include <stdio.h>
#include<string.h>
#include <stdbool.h>

bool isMatch(char* s, char* p) {
    int m = strlen(s),j;
    int n = strlen(p),i;
    int dp[m + 1][n + 1];
    memset(dp, 0, sizeof(dp));
    dp[0][0] = true;
    for (i = 1; i <= n; ++i) {
        if (p[i - 1] == '*') {
            dp[0][i] = true;
        } else {
            break;
        }
    }
    for (i = 1; i <= m; ++i) {
        for (j = 1; j <= n; ++j) {
            if (p[j - 1] == '*') {
                dp[i][j] = dp[i][j - 1] | dp[i - 1][j];
            } else if (p[j - 1] == '?' || s[i - 1] == p[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            }
        }
    }
    return dp[m][n];
}


int main() {
    char str1[1000], str2[1000];

    // 读取两个字符串，以 '#' 结束
    scanf("%[^#]#", str1);
    getchar();
    scanf(" %[^#]#", str2);
    
    //putchar(ch);
	
//	scanf("%s",str1);
//	scanf("%s",str2);
	//puts(str1);
	//puts(str2); 
	
    // 调用匹配函数进行匹配
    if (isMatch(str1, str2)) {
        printf("yes\n");
    } else {
        printf("no\n");
    }

    return 0;
}

```



### 2023期中考试



#### 1. 2023春期中机考第一题 顺序表（7+8 = 15分)

```c
#include <stdio.h>

#include <stdlib.h>

#define OK 1

#define ERROR 0



typedef struct

{

	int *elem;

	int length;

	int listsize;

} sqlist;



//初始化一个空的顺序表

int initlist(sqlist *l)

{

	l->elem = (int *)malloc(100 * sizeof(int));

	if (!l->elem)

		return ERROR;

	l->length = 0;

	l->listsize = 100;

	return OK;

}



//根据长度为n的数组x，创建顺序表L   

//如果成功返回OK，否则返回ERROR

int insertlist(sqlist *l, int a[], int n)

{
	int i; 
	for (i = 0; i < n; i++)

	{

		l->elem[i] = a[i];

	}

	l->length = n;

	return OK;

}



//将顺序表a中大于t的元素存入顺序表b中

void getb(sqlist *b, sqlist a, int t)

{

	//★★★请补全代码
	int i = 0,j = 0;
	for(;i < a.length;i ++)
	{
		if(a.elem[i] > t)	
		{
			b->elem[j + b->length] = a.elem[i];	
			j ++;
		}
	} 
	b->length += j;







}



// 将b中的元素逆置，并打印输出逆置后b中所有元素

void  reverselist(sqlist *b)

{

	//★★★请补全代码
	int i = 0;
	for(;i * 2 < b->length;i ++)
	{
		int temp = b->elem[i];
		b->elem[i] = b->elem[b->length - i - 1];
		b->elem[b->length - i - 1] = temp;		
	}

}



int main()

{

	sqlist a,b;

	initlist(&a);

	initlist(&b);

	int x[100];

	int n,i;

	scanf("%d", &n);

	for (i = 0; i < n; i++)

	{

		scanf("%d", &x[i]);

	}

	insertlist(&a, x, n);

	int t;

	scanf("%d", &t);

	getb(&b, a, t);

	reverselist(&b);
	
	for(i = 0;i < b.length;i ++)
	{
		printf("%d ",b.elem[i]);
	}

	return 0;

}


```



#### 2. 2023春期中机考第二题 链表（5+7+8=20分）

```C
#include <stdio.h>

#include <stdlib.h>

#define ERROR -1

#define OK 1



typedef struct Lnode

{

	int data;

	struct Lnode *next;

}LNode,*LinkList;



// 创建带头结点的单链表

int CreateList(LinkList *L)

{

	*L=(LinkList)malloc(sizeof(LNode));

	if((*L)==NULL)

	{

		printf("Memory failure\n");

		return ERROR;

	}

	(*L)->next=NULL;

	LinkList r;

	r=*L;

	int x;

	int i;

	for(i=0; ; i++)

	{

		scanf("%d",&x);

		if(x==-1)

		break;

		LNode *p=(LinkList)malloc(sizeof(LNode));

		if(!p) 

		{

			printf("Initialization failure");

			return ERROR;

		}

		p->data=x;

		p->next= NULL;

		r->next=p;

		r=p;

	}

	return OK;

}



//打印单链表

void ListPrint(LinkList L)

{

	LNode *p;

	for(p=L->next;p!=NULL;p=p->next)

	{

		printf("%d ",p->data);

	}

}



//求单链表长度

int ListLength(LinkList L)

{

	//★★★请补全代码
	int len = 0;
	 LinkList p = L->next;
	 while(p)
	 {
	 	len ++;
	 	p = p->next;
	 }
	return len;






}



//删除单链表的倒数第x个元素, 参数length为单链表长度，

//如果操作成功，返回OK，否则返回ERROR

int DeleteX(LinkList  *L,int length, int x)

{
	
	if(x > ListLength(*L))
	{
		printf("\nThe x value is not valid");
		return 0;
	}

	//★★★请补全代码
	int i = 0;
	LinkList p = (*L);
	while(p->next && i < length - x)
	{
		p = p->next;
		i ++;
	}
	LinkList s = p->next;
	p->next = s->next;
	free(s);
	return OK;







}



//单链表元素求和，并将累加和添加到单链表尾部

//如果操作成功，返回OK，否则返回ERROR

int AppendSumToList(LinkList *L)

{

	//★★★请补全代码
	int sum = 0;
	LinkList p = (*L);
	while(p->next)
	{
		sum += p->next->data;
		p = p->next;
	}
	LinkList s;
	s = (LinkList)malloc(sizeof(LNode));
	if(!s)	return ERROR;
	s->data = sum;
	s->next = NULL;
	p->next = s;
	return 1;
	






} 



int main()

{

	int length;

	int x;

	LinkList L;

	CreateList(&L);

	scanf("%d",&x);
	


	printf("The original linked list is：");

	ListPrint(L);

	printf("\nThe length of list is：");

	length=ListLength(L);

	printf("%d ",length);
	


	DeleteX (&L,length, x);

	printf("\nAfter deleting the element, the linked list is: ");

	ListPrint(L);

	printf("\nAfter inserting the sum, the new list is: ");

	AppendSumToList(&L);

	ListPrint(L);

	return 0;

}
```



#### 3. 2023春期中机考第三题 链队列（7+8=15分）

```c
#include <stdio.h>

#include <stdlib.h>

#define OK 1

#define ERROR 0

#define OVERFLOW 0



typedef char ElemType;

typedef int Status;

typedef struct QNode

{

    ElemType data;

    struct QNode *next;

}QNode,*queuePtr;   



typedef struct

{

    queuePtr front; //指向链队列的头

    queuePtr rear;  //指向链队列的尾 

}LinkQueue;



//队列初始化

Status InitQueue(LinkQueue *q)

{

   q->front=q->rear=(queuePtr)malloc(sizeof(QNode));  //创建头节点 头指针指向头节点

   if(!q->front)  //创建失败

   {

       return ERROR;

   }

   q->front->next=NULL;

   return OK;

}



//判断队列是否为空

Status QueueEmpty(LinkQueue Q)

{

    if(Q.front==Q.rear)

        return OK;

    else

        return ERROR;

}// QueueEmpty



int QueueLength (LinkQueue Q)

{

    int i;

    queuePtr p;

    p = Q.front->next;   //p指向队头

    i=1;

    while(p!=Q.rear)  //遍历链队列,统计结点数

	{

        i++;

        p=p->next;

    }

    return i;

}// QueueLength



//获得队首元素

Status GetHead(LinkQueue q,ElemType *e)

{

    if(q.front == q.rear)

        return ERROR;

    *e = q.front->next->data;

    return OK;

}



//入队

Status EnQueue(LinkQueue *q,ElemType e)

{

    queuePtr p=(queuePtr)malloc(sizeof(QNode)); //为新元素分配空间

    if(!p) return ERROR; 

    p->data=e;

    p->next=NULL;

    q->rear->next=p; //为尾指针的next重新赋值 将元素插入表尾

    q->rear=p;  //重新定位尾指针

    return OK;

}



//删除元素

Status DeQueue(LinkQueue *q,ElemType *e)

{

    if(q->front == q->rear) return ERROR; //此时队列为空

    queuePtr p = q->front->next;  

    *e=p->data;  //删除是队首元素

    q->front->next=p->next;

    if(q->rear == p)

        q->rear=q->front;

    free(p);

    return OK;

}



//清空链队列，如果成功，返回OK，否则返回ERROR

Status ClearQueue (LinkQueue *Q)

{

	//★★★请补全代码
	if(!Q->front)	return ERROR;
	free(Q->front);
	Q->front = Q->rear = 0;
	return OK; 







}// ClearQueue



//输出队列

Status PrintQueue(LinkQueue q)

{

    queuePtr p;

    p = q.front->next;

    while(p)

    {

        printf("%c ",p->data);

        p=p->next;

    }

    return OK;

}



//解密游戏

void DecryptGame(LinkQueue *Q)

{

	//★★★请补全代码
	LinkQueue S;
	InitQueue(&S);
	
	while(!QueueEmpty(*Q))
	{
		char temp;
		DeQueue(Q,&temp);
		EnQueue(&S,temp);
		if(!QueueEmpty(*Q))
		{
			DeQueue(Q,&temp);
			EnQueue(Q,temp);
		}
	} 

	PrintQueue(S);

 



}



int main()

{

    LinkQueue Q;

    InitQueue(&Q);

    int i;

    char a;

    for(i=0;i<10;i++)

    {

        scanf("%c",&a);

        EnQueue(&Q,a);

    }

    DecryptGame(&Q);

    printf("\n");

    ClearQueue(&Q);

    return 0;

}
```



#### 4. 2023春 期中考试 第四题 顺序栈（5+10=15分）

```c
#include<stdio.h>

#include<stdlib.h>

#define OK 1

#define ERROR 0

#define OVERFLOW -2

#define MAXSIZE  100



typedef int Status;

typedef int SElemType;

typedef struct{

	SElemType *base;

	SElemType *top;

	int stacksize;

}SqStack;



//顺序栈的初始化

Status InitStack(SqStack *S){ 

	S->base = (SElemType *)malloc(MAXSIZE * sizeof(SElemType));

	if(!S->base)

		return ERROR;

	S->top = S->base;

	S->stacksize = MAXSIZE;

	return OK;

}



Status Push(SqStack *S,SElemType e)
{

	//★★★请补全代码
	if(S->top - S->base >= S->stacksize)	return ERROR;
	*(S->top ++) = e;
	return OK;


}



//顺序栈的出栈

Status Pop(SqStack *S,SElemType *e){

	if(S->base == S->top)

		return ERROR;

	*e = *(--S->top);

	return OK;

}





// 将一个十进制数转换为二进制数，并打印输出

// 要求使用堆栈来实现，如果未用堆栈，答题无效



int main()

{

	//★★★请补全代码
	int n;
	scanf("%d",&n);
	if(n <= 0)
	{
		printf("Input error!");
		return 0;
	}
	
	SqStack S;
	InitStack(&S);
	
	while(n)
	{
		int x = n%2;
		Push(&S,x);
		n = (n - x) / 2;
	}
	
	while(S.base != S.top)
	{
		int e;
		Pop(&S,&e);
		printf("%d",e);
	}
	return 0;
}






```



#### 5. 2023春 期中考试 第五题 字符串 (7+8=15分)

```c
#include <stdio.h>   

#include <stdlib.h>   



#define ERROR 0

#define OK 1

#define TRUE 1

#define FALSE 0

#define MAXSIZE 20



typedef struct

{

    char *ch;       //若串非空,则按串长分配存储区

    int  length;    //串长度

}HString;



int InitString(HString *T) 

{

    T->ch=(char*)malloc(sizeof(char)*MAXSIZE);

    if(!T->ch)

        return ERROR;

    T->length=0;

    return OK;

}



//将字符数组chars赋值到串T

//如果操作成功，返回OK，否则返回ERROR

int StrAssign(HString *T,char *chars)

{

//★★★请补全代码
	int i = 0;
	for(;chars[i] !='\0';i++)
	{
	}
	if(!i)
	{
		T->ch = NULL;
		T->length = 0;
	}
	else
	{
		int j = 0;
		for(j = 0;chars[j] != '\0';j ++)
		{
			T->ch[j] = chars[j];
			T->length ++;
		}
		
	}
	return OK;


}



   

// 比较字符串大小

//（1）如果两个串长度相等，且每一个相应位置上的字符都一样，则结果为0；

//（2）如果两个串长度不相等，则则以第一个不相同的字符作为基准，返回第一个不相同的字符ASCII差值；

//（3）如果两个串长度不相等，且所有相应位置上的字符都一样，则返回两个字符串的长度之差。

int StrCompare(HString S,HString T)

{

  //★★★请补全代码
  int i = 0;
  while(i < S.length && i < T.length)
  {
  		if(S.ch[i] != T.ch[i])	return (S.ch[i] - T.ch[i]);
  		i++; 
  }
  return S.length - T.length;



}//StrCompare    



int main()

{

    HString S;

    HString T;

    char mainstr[20];

    char substr[10];

    int index;

    InitString(&S);

    InitString(&T);

    gets(mainstr);

    gets(substr);

    StrAssign(&S,mainstr);

    StrAssign(&T,substr);

    printf("%d\n",StrCompare(S,T));

    return 1;

}
```



#### 6. 2023春 期中考试 第六题 综合题（一） (7分)

```c
#define MAXINTSIZE 512 /* 最大整数长度 */

#include<stdio.h>

#include<stdlib.h>



#define ERROR 0

#define OK 1

typedef int Status;



typedef struct Node

{

    int data;

    struct Node *next;

} LNode;

typedef LNode *LinkList;



/* 用头插法建立单链表 */

Status CreateList(LinkList *L, char *chars)

{

     //★★★请补全代码
    LinkList p = (*L);
	int i = 0;
	for(;chars[i] != '\0';i ++)
	{
		LNode *r;
		r = (LinkList)malloc(sizeof(LNode));
		if(!r)	return ERROR;
		r->data = chars[i] - '0';
		r->next = p->next;
		p->next = r;
		//p = r;
	}
	return OK;



}



int ListLength_L(LinkList L){

    LinkList p;

    int i=0;             

    p=L->next;        //p指向第一个结点

    while(p){         //遍历单链表,统计结点数

        i++;

        p=p->next;

    } 

    return i;                             

}// ListLength_L



Status  InversePrint(LinkList p){

   //逆序打印不带头结点的单链表的元素    

   if(!p) return OK;
   
   //printf("%d",p->data);

   InversePrint(p->next);

   printf("%d",p->data);

   return OK;

}// 



int main()

{

    int len;

    char str[MAXINTSIZE+1];

    LinkList L;

    scanf("%s", str);
    
    L = (LinkList)malloc(sizeof(LNode));

    CreateList(&L, str);

    len=ListLength_L(L);

    printf("the length of the integer is %d\n", len);

    InversePrint(L->next);

    printf("\n");

    return 0;

}


```



#### 7. 2023春 期中考试 第六题 综合题（二） (7+6=13分)

```c
#include<stdio.h>

#include<stdlib.h>



#define ERROR 0

#define OK 1



typedef int Status;



typedef struct Node

{

    int data;

    struct Node *next;

} LNode;

typedef LNode *LinkList;



Status InitList(LinkList *L)

{

    *L = (LinkList)malloc(sizeof(LNode));

    if (*L == NULL)

        return ERROR;

    (*L)->next = NULL;

    return OK;

}

// 单链表表示的大整数与整数相乘

//自己的代码
//int int_mult(LinkList *L, int base) 
//{
//	
//	int carry = 0;
//	LNode *p = (*L);
//	LNode *pre = NULL;
//	
//	while(p)
//	{
//		p->data = p->data * base + carry;
//		carry = p->data / 10;
//		p->data = p->data % 10;
//		pre = p;
//		p = p->next;
//	}
//	
//	if(!p && carry)
//	{
//		p = (LinkList)malloc(sizeof(LNode));
//		if(!p)	return ERROR;
//		p->data = carry;
//		p->next = NULL;
//		pre->next = p;
//	}
//	return OK;
//}

// 单链表表示的大整数与整数相乘

int int_mult(LinkList *L, int base) {
    int carry = 0;
    LinkList p = *L; // 从链表头开始遍历
    LinkList pre = NULL; // 记录当前节点的前一个节点，为后面进行尾插新节点提供前驱

    // 遍历链表
    while (p || carry != 0) {
        if (!p) {
            // 如果 p 为空，创建一个数据为 0 的新节点
            LNode *r = (LinkList)malloc(sizeof(LNode));
            if (r == NULL)
                return ERROR; // 如果内存分配失败，则返回错误
            r->data = 0;
            r->next = NULL;

            // 将新节点插入到链表末尾
            if (pre) {
                pre->next = r;
            } else {
                *L = r; // 如果链表为空，则将新节点设为链表头
            }
            p = r; // 更新 p 为新插入的节点
        }

        // 将当前数字乘以基数，并加上进位
        p->data = p->data * base + carry;
        carry = p->data / 10; // 更新下一轮迭代的进位
        p->data %= 10; // 更新当前数字

        pre = p; // 更新前一个节点为当前节点
        p = p->next; // 移动到链表中的下一个节点
    }
    
    return OK; // 如果乘法运算成功，则返回 OK
}



//统计计算结果中0-9出现个数    

void CountNum(LinkList L, int *num)

{

//★★★请补全代码
	LinkList p = L->next;
	while(p)
	{
		num[p->data]  ++;
		p = p->next;
	 } 

}



Status InversePrint(LinkList p){

   //逆序打印不带头结点的单链表的元素    

   if(!p) return OK;

   InversePrint(p->next);

   printf("%d",p->data);

   return OK;

}// 



int main()

{

    int a,n; /* a为底数(0<a<9)，n为指数 */

    int len=0;

    int num[10]; /* 用于统计计算结果中0-9出现次数 */

    LinkList p;

    LinkList L;

    InitList(&L);

    scanf("%d%d",&a,&n);

    int i;

    for(i=0; i<10; i++)

        num[i]=0;        

    /* 生成表头节点并放入1 */

    p=(LinkList)malloc(sizeof(LNode));

    if(p==NULL) return ERROR;

    p->data=1;

    p->next=NULL;

    L->next=p;

    /* 反复调用乘a操作n次 */

    for(i=0; i<n; i++)

        int_mult(&L, a);



    /* 打印计算结果 */

    InversePrint(L->next);

    printf("\n");

    /* 统计计算结果中0-9出现个数 */

    CountNum(L, num);

    for(i=0; i<10; i++){

        printf("the number of %d is: %d\n", i, num[i]);

        len+=num[i];

    }

    printf("the length of the result is %d\n", len);

    return 0;

}


```

