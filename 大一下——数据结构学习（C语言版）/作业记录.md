### 作业1——C语言复习

#### 1. ACM2024-第一章-C语言回顾-结构体2

#### 2. ACM2024-第一章-C语言回顾-结构体2

#### 3. ACM2024-第一章-C语言回顾-结构体1

#### 4. ACM2024-第一章-C语言回顾-数组最大值

#### 5. ACM2024-第一章-C语言回顾-数组1



### 作业2——顺序表



#### 1. ACM2023-第二章-线性表-交叉合并两个顺序表- LJD



```c
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0
#define MAXSIZE 20

typedef int Status;
typedef int ElemType;

typedef struct {
    ElemType data[MAXSIZE];
    int length;
} SqList;

// 遍历顺序表并打印元素
void TraverseList(SqList L) 
{
    for (int i = 0; i < L.length; i++) 
    {
        printf("%d ", L.data[i]);
    }
    printf("\n");
}

// 获取顺序表的长度
int GetListLength(SqList L) 
{
    return L.length;
}

// 获取指定位置的元素值
Status GetElemAt(SqList L, int i, ElemType *e) 
{
    if (i < 1 || i > L.length)
        return ERROR;
    *e = L.data[i - 1];
    return OK;
}

// 在指定位置插入元素
Status InsertIntoList(SqList *L, int i, ElemType e) 
{
    if (L->length >= MAXSIZE || i < 0 || i > L->length)
        return ERROR;
    for (int k = L->length - 1; k >= i; k--) 
    {
        L->data[k + 1] = L->data[k];
    }
    L->data[i] = e;
    L->length++;
    return OK;
}

// 将两个顺序表的元素交错到第三个顺序表中
void InterleaveLists(SqList *L3, SqList L1, SqList L2) 
{
    int i = 1;
    int e;
    while (i <= L1.length || i <= L2.length) 
    {
        int tag = i;//作为判断标志	是否已经插了L1	矫正i 的值
        if (i <= L1.length) 
        {
            GetElemAt(L1, i, &e);
            InsertIntoList(L3, L3->length, e);
            i++;
        }
        if (i - 1 <= L2.length) 
        {
            if (tag != i) i--;
            GetElemAt(L2, i, &e);
            InsertIntoList(L3, L3->length, e);
            i++;
        }
    }
}

int main() 
{
    SqList L1, L2, L3;
    Status i;
    int j, k, l;

    // 输入并创建第一个顺序表
    scanf("%d", &k);
    L1.length = 0;
    if (k > 0)
        for (j = 1; j <= k; j++) 
        {
            scanf("%d", &l);
            i = InsertIntoList(&L1, 0, l);
        }

    // 打印第一个顺序表及其长度
    TraverseList(L1);
    printf("%d \n", GetListLength(L1));

    // 输入并创建第二个顺序表
    scanf("%d", &k);
    L2.length = 0;
    if (k > 0)
        for (j = 1; j <= k; j++) 
        {
            scanf("%d", &l);
            i = InsertIntoList(&L2, 0, l);
        }

    // 打印第二个顺序表及其长度
    TraverseList(L2);
    printf("%d \n", GetListLength(L2));

    // 将两个顺序表的元素交错到第三个顺序表中
    L3.length = 0;
    InterleaveLists(&L3, L1, L2);

    // 打印交错后的顺序表及其长度
    TraverseList(L3);
    printf("%d \n", GetListLength(L3));

    return OK;
}

```



#### 2. ACM2023-第二章-线性表-顺序表的各种操作练习- LJD



```c
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE 0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
typedef int ElemType;

#define INIT_SIZE 100       // 初始分配空间的大小
#define LISTINCREMENT 10    // 分配增量

typedef struct {
    ElemType *elem;         // 存储空间的起始地址
    int length;             // 线性表中数据元素个数，即表长
    int listsize;           // 线性表所申请的存储空间的大小
} SqList;

// 创建一个空的线性表
SqList CreateList_Sq(SqList L)
{
    L.elem = (ElemType*)malloc(100 * sizeof(ElemType));  // 申请空间
    L.length = 0;         // 表长为0
    L.listsize = 100;     // 申请的空间为初始大小
    return L;
}

// 在线性表的第i个位置前插入元素e
void InsertList_Sq(SqList *L, int i, ElemType e)
{
    int *newbase, *q, *p;
    if ((i < 1) || (i > L->length + 1)) 
    {
        printf("i值不合法!\n");
        exit(ERROR);
    }
    // 当前空间已满，增加分配空间
    if (L->length >= L->listsize) 
    {   
        newbase = (ElemType*)realloc(L->elem, (L->listsize + LISTINCREMENT) * sizeof(ElemType));
        if (!newbase) exit(ERROR);
        L->elem = newbase;
        L->listsize = L->listsize + LISTINCREMENT;
    }
    //检查完错误	开始插值
    int j;
    for (j = L->length - 1; j >= i - 1; j--) 
    {
        L->elem[j + 1] = L->elem[j]; // 将元素后移
    }
    L->elem[i - 1] = e;
    L->length++;//插完后	莫忘更新线性表的长度
    return OK;
}

// 删除线性表中的第i个元素
void DeleteList_Sq(SqList *L, int i)
{
    int j;
    if ((i < 1) || (i > L->length)) {
        printf("i值不合法!\n");
        exit(ERROR);
    }
    for (j = i; j < L->length; j++) {
        L->elem[j - 1] = L->elem[j];
    }
    L->length--;
}

// 遍历顺序线性表并输出
void Print_Sq(SqList L)
{
    int i;
    for (i = 0; i < L.length; i++) {
        printf("%3d ", L.elem[i]);
    }
}

// 判两个元素是否相等
int equal(ElemType e1, ElemType e2)
{
    if (e1 == e2) return 1;
    else return 0;
}

// 查找元素在顺序表中的位置
int LocateElem_Sq(SqList L, ElemType e, int (* compare)(ElemType e1, ElemType e2))
{
    int i = 0;
    for (; i < L.length; i++) {
        if (compare(L.elem[i], e)) return i + 1;
    }
    return ERROR;
}

void Getelem(SqList L, int i, ElemType *e)
{
    if (i < 1 || i > L.length) return;
    *e = L.elem[i - 1];
    return;
}

int main()
{
    int i;
    ElemType e;
    SqList Lq;
    Lq = CreateList_Sq(Lq);
    InsertList_Sq(&Lq, 1, 21);
    InsertList_Sq(&Lq, 2, 18);
    InsertList_Sq(&Lq, 3, 30);
    InsertList_Sq(&Lq, 4, 75);
    InsertList_Sq(&Lq, 5, 42);
    InsertList_Sq(&Lq, 6, 56);
    printf("初始顺序表为\n");
    Print_Sq(Lq);
    InsertList_Sq(&Lq, 3, 67);
    printf("\n插入67后顺序表为\n");
    Print_Sq(Lq);
    DeleteList_Sq(&Lq, 6);
    printf("\n删除第6个元素后顺序表为\n");
    Print_Sq(Lq);
    if ((i = LocateElem_Sq(Lq, 75, equal)))
        printf("\n存在元素75且位置为%d\n", i);
    else
        printf("\n不存在元素75\n");
    free(Lq.elem);
    return 1;
}

```



#### 3. ACM2023-第二章-顺序表练习题 -合并两有序表 - LJD



```c
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE 0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10
typedef int ElemType;

typedef struct {
    ElemType *elem;
    int length;
    int listsize;
} SqList;

// Create an empty list
Status InitList_Sq(SqList *L)
{
    //学生添加
    L->elem = (int*)malloc(INIT_SIZE*sizeof(int));
    if (!L->elem) return OVERFLOW;
    L->length = 0;
    L->listsize = INIT_SIZE; 
}

// Create an array based list with n elements
Status CreateList_Sq(SqList *L, int a[], int n)
{
    //学生添加
    int j = 0;
    for(; j < n; j++)
    {
        L->elem[j] = a[j];
    }
    L->length = n;
}

// Get Element
Status GetElem(SqList L, int i, int *e)
{
    //学生添加
    if(i < 1 || i > L.length) return ERROR;
    *e = L.elem[i - 1];
    return OK;
}

// Insert
Status ListInsert(SqList *L, int i, int e)
{
    //学生添加
    if(i < 1 || i > L->length + 1) return ERROR;
    if(L->length == L->listsize) return ERROR;
    int j = L->length - 1;
    for(; j >= i - 1; j--)
    {
        L->elem[j + 1] = L->elem[j];
    }
    L->elem[i - 1] = e;
    L->length++;
    return OK;
}

// Merge two sequential lists 
Status MergeList_Sq(SqList L1, SqList L2, SqList *L3)
{  
    //学生添加
    int i = 0, j = 0, k = 0;
    
    
    while(i < L1.length && j < L2.length)
    {
        if(L1.elem[i] <= L2.elem[j])
        {
            L3->elem[k++] = L1.elem[i++];
        }
        else
        {
            L3->elem[k++] = L2.elem[j++];
        }
    }
    while(i < L1.length)
    {
        L3->elem[k++] = L1.elem[i++];
    }
    while(j < L2.length)
    {
        L3->elem[k++] = L2.elem[j++];
    }
    L3->length = k;
    
    
    //上面的三个while循环逻辑更加清晰	
    //下面一个看着很复杂
    //while (L3->length < L1.length + L2.length)
    //{
    //	if (len1 < L1.length && (L1.elem[len1] <= L2.elem[len2] || len2 >= L2.length))
    //	{
    //		L3->elem[len3++] = L1.elem[len1++];
    //		L3->length++;
    //	}
    //	else if (len2 < L2.length && (L2.elem[len2] < L1.elem[len1] || len1 >= L1.length))
    //	{
    //		L3->elem[len3++] = L2.elem[len2++];
    //		L3->length++;
    //	}
    //}
    
}

// Print out all elements
void PrintList_Sq(SqList L)
{ 
    //学生添加
    int j = 0;
    for(; j < L.length; j++)
    {
        printf("%d ", L.elem[j]);
    }
}

int main()
{
    int n1, n2, i, j;
    int a[20], b[20];
    SqList L1, L2, L3;

    scanf("%d", &n1);
    for(i = 0; i < n1; i++)
    {
        scanf("%d", &a[i]);
    }
    scanf("%d", &n2);
    for(i = 0; i < n2; i++)
    {
        scanf("%d", &b[i]);
    }

    InitList_Sq(&L1);
    InitList_Sq(&L2);
    InitList_Sq(&L3);

    CreateList_Sq(&L1, a, n1);
    CreateList_Sq(&L2, b, n2);

    MergeList_Sq(L1, L2, &L3);

    PrintList_Sq(L3);

    return 0;
}

```



#### 4. ACM2023-第二章-顺序表练习题 -删除顺序表指定位置n后的m个元素 - LJD



```C
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE  0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10  
typedef int ElemType;

typedef struct
{
    ElemType *elem;
    int length;
    int listsize;
}SqList;

// Initialize an empty list
Status InitList_Sq(SqList *L)
{
 //学生添加
 	L->elem = (int*)malloc(INIT_SIZE * sizeof(int));
    if (!L->elem) return OVERFLOW;
 	L->length = 0;
 	L->listsize = INIT_SIZE;
}
//Create an array based list with n elements
Status CreateList_Sq(SqList *L, int a[], int n)
{
 //学生添加
	int i = 0;
	for(;i < n;i ++)
	{
		L->elem[i] = a[i]; 
	}
	L->length = n;
    return OK;
}

// Delete the ith elements of sequential list L
Status DeleteList_Sq(SqList *L, int m,int k)
{    
 //学生添加
       if (m < 0 || m > L->length || k < 0)
        return ERROR;
 	int i = 0; 	
 	for(;m < L->length - k;m ++)
 	{
 		L->elem[m] = L->elem[m + k];
	 }
	 L->length -=k;
}

//print out all elements
void PrintList_Sq(SqList L)
{ 
 //学生添加
	 int i = 0;
	 for(;i < L.length;i ++)
	 {
	 	printf("%d ",L.elem[i]); 
	 }
}

int main()
{ 
	int n;
	scanf("%d",&n);
	int i,arr[n];
	for(i = 0;i < n;i ++)
	{
		scanf("%d",&arr[i]);
	 }
    
	 SqList sq;
	 InitList_Sq(&sq);	 
	 CreateList_Sq(&sq,arr,n);
	 
	 int m,k; 
	 scanf("%d%d",&m,&k);
	 
	 DeleteList_Sq(&sq,m,k);
	 
	 PrintList_Sq(sq);	 
	 return 0;
}

```



#### 5. ACM2023-第二章-顺序表练习题 -就地逆置顺序表 - LJD



```c
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE  0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10  
typedef int ElemType;

typedef struct {
    ElemType *elem;
    int length;
    int listsize;
} SqList;

// Create an empty list
Status InitList_Sq(SqList *L)
{
    //学生添加
    L->elem = (int*)malloc(INIT_SIZE * sizeof(int));
    L->length = 0;
    L->listsize = INIT_SIZE;
}

// Create an array based list with n elements
Status CreateList_Sq(SqList *L, int a[], int n)
{
    //学生添加
    int i = 0;
    for(; i < n; i++)
    {
        L->elem[i] = a[i];
    }
    L->length = n;
}

// Reverse the elements of sequential list L
void swap(int *a, int *b)
{
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;	
}

Status ReverseList_Sq(SqList *L)
{    
    //学生添加
    int i = 0;
    for(; i < L->length / 2; i++)
    {
        swap(&L->elem[i], &L->elem[L->length - i - 1]); 
    }
    return OK;
}

// print out all elements
void PrintList_Sq(SqList L)
{ 
    //学生添加
    int i = 0;
    for(; i < L.length; i++)
    {
        printf("%d ", L.elem[i]);
    }
}

int main()
{ 
    //学生添加
    int n;
    scanf("%d", &n);
    int arr[n];
    int i = 0;
    for(; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }
    SqList sq;
    InitList_Sq(&sq);
    CreateList_Sq(&sq, arr, n);
    ReverseList_Sq(&sq);
    PrintList_Sq(sq);
    return 0;
}

```



#### 6. ACM2023-第二章-顺序表练习题 -顺序表排序 - LJD



```C
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE 0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10  
typedef int ElemType;

typedef struct{
    ElemType *elem;
    int length;
    int listsize;
} SqList;

// Create an empty list
Status InitList_Sq(SqList *L)
{
    //学生添加
    L->elem = (int*)malloc(INIT_SIZE*sizeof(int));
    L->length = 0;
    L->listsize = INIT_SIZE;
}

// Create an array based list with n elements
Status CreateList_Sq(SqList *L, int a[], int n)
{
    //学生添加
    int i = 0;
    for(; i < n; i++)
    {
        L->elem[i] = a[i];
    }
    L->length = n;
}

// Sort the elements of sequential list L into ascending order
Status SortList_Sq(SqList *L)
{    
    //学生添加
    int i = 0, j = 0;
    for(; i < L->length - 1; i++)
    {
        for(j = 0; j < L->length - i - 1; j++)
        {
            if(L->elem[j] > L->elem[j + 1])
            {
                int temp = L->elem[j];
                L->elem[j] = L->elem[j + 1];
                L->elem[j + 1] = temp;
            }
        }
    }
}

// Print out all elements
void PrintList_Sq(SqList L)
{ 
    //学生添加
    int i = 0;
    for(; i < L.length; i++)
    {
        printf("%d ", L.elem[i]);
    }
}

int main()
{ 
    //学生添加
    int n;
    scanf("%d", &n);
    int i = 0, arr[n];
    for(; i < n; i++)
    {
        scanf("%d", &arr[i]);
    } 
    SqList sq;
    InitList_Sq(&sq);
    CreateList_Sq(&sq, arr, n);
    SortList_Sq(&sq);
    PrintList_Sq(sq);
    return 0;
}

```



#### 7. ACM2023-第二章-顺序表练习题 -在顺序表的指定位置插入指定元素 -LJD

```c
#include <stdio.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10  
typedef int ElemType;

typedef struct {
    ElemType *elem;
    int length;
    int listsize;
} SqList;

// 创建一个空的顺序表
Status InitList_Sq(SqList *L) 
{
    L->elem = (int *)malloc(INIT_SIZE * sizeof(int));
    if (!L->elem) 
    {
        printf("Memory allocation failed.\n");
        return OVERFLOW;
    }
    L->length = 0;
    L->listsize = INIT_SIZE;
    return OK;
}

// 创建一个带有 n 个元素的数组列表
Status CreateList_Sq(SqList *L, int a[], int n) 
{
    if (n > INIT_SIZE) 
    {
        printf("The number of elements exceeds the initial size.\n");
        return ERROR;
    }
    int i;
    for (i = 0; i < n; i++) 
    {
        InsertList_Sq(L, i + 1, a[i]);
    }
    return OK;
}

// 在顺序表 L 的特定位置插入元素
Status InsertList_Sq(SqList *L, int i, ElemType e) 
{    
    if (i < 1 || i > L->length + 1) 
    {
        printf("Invalid position.\n");
        return ERROR;
    }
    if (L->length >= L->listsize) 
    {
        printf("The list is full. No more space to insert.\n");
        return OVERFLOW; // 检查是否需要扩展顺序表的空间
    }
    int j;
    for (j = L->length - 1; j >= i - 1; j--) 
    {
        L->elem[j + 1] = L->elem[j]; // 将元素后移
    }
    L->elem[i - 1] = e;
    L->length++;
    return OK;
}

// 打印所有元素
void PrintList_Sq(SqList L) 
{
    int i;
    for (i = 0; i < L.length; i++) 
    {
        printf("%d ", L.elem[i]); 
    }
    printf("\n");
}

int main() 
{
    int n, e, k;
   // printf("Enter the number of elements: ");
    scanf("%d", &n);
    if (n <= 0) 
    {
       // printf("Invalid number of elements.\n");
        return ERROR;
    }
    int i, arr[n];
    //printf("Enter the elements: ");
    for (i = 0; i < n; i++) 
    {
        scanf("%d", &arr[i]);
    }
    SqList sq;
    if (InitList_Sq(&sq) != OK) 
    {
        return ERROR;
    }
    if (CreateList_Sq(&sq, arr, n) != OK) 
    {
        return ERROR;
    }
    //printf("Enter the element and the position to insert: ");
    scanf("%d%d", &e, &k);
    if (InsertList_Sq(&sq, k, e) != OK) 
    {
        return ERROR;
    }
    //printf("The list after insertion: ");
    PrintList_Sq(sq);
    return 0;
}

```

### 作业3——链表



#### 单链表学习代码：

```c
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0

typedef int ElemType;
typedef int Status;

typedef struct LNode
{
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// Initialize a linked list
Status InitList(LinkList *L)
{
    *L = (LinkList)malloc(sizeof(LNode));
    if (!(*L)) return ERROR;
    (*L)->next = NULL;
    return OK;
}

// Get the value at a given position
Status GetElem(LinkList L, int i, ElemType *e)
{
    LNode *p = L->next;
    int j = 1;
    while (p && j < i)
    {
        p = p->next;
        ++j;
    }
    if (!p || j > i) return ERROR;
    *e = p->data;
    return OK;
}

// Locate the element with a given value
LinkList LocateElem(LinkList L, ElemType e)
{
    LinkList p = L->next;
    while (p && p->data != e)
    {
        p = p->next;
    }
    return p;
}

// Insert an element at a given position
Status ListInsert(LinkList *L, int i, ElemType e)
{
    LinkList p = *L;
    int j = 0;
    while (p && j < i - 1)
    {
        p = p->next;
        ++j;
    }
    if (!p || j > i - 1) return ERROR;
    LinkList s = (LinkList)malloc(sizeof(LNode));
    if (!s) return ERROR;
    s->data = e;
    s->next = p->next;
    p->next = s;
    return OK;
}

// Delete the element at a given position
Status ListDelete(LinkList L, int i)
{
    LinkList p = L;
    int j = 0;
    while (p->next && j < i - 1)//循环终止后  p指向的第 i - 1个位置的结点
    {
        p = p->next;
        ++j;
    }
    if (!(p->next) || j > i - 1) return ERROR;//前者便是的是此链表最大长度小于 i，没有第i 个结点
    LinkList q = p->next;
    p->next = q->next;//不能直接使用p->next->next，会造成p->next的内存地址无法找到，内存泄漏
    free(q);
    return OK;
}

// Display the elements in the linked list
void DisplayList(LinkList L)
{
    LinkList p = L->next;
    while (p)
    {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}


/*逆序创建链表通常是为了更高效地插入元素。在逆序创建链表时，我们可以直接将新元素插入链表的头部，而不需要遍历整个链表找到尾部再插入。这样做的好处是，每次插入操作的时间复杂度为O(1)，而不是O(n)，因为不需要遍历链表。

如果采用正序创建链表，每次插入元素都需要遍历到链表的尾部，时间复杂度为O(n)，这在插入大量元素时会导致性能下降。*/

// Create a linked list with elements in reverse order
Status InverseCreateList(LinkList L, ElemType a[], int n)
{
    LNode *r = L;
    int i = 0;
    for(; i < n; i++)
    {
        LNode *p ;
        p = (LNode*)malloc(sizeof(LNode));
        p->data = a[n - i - 1]; // Insert elements in reverse order
        p->next = NULL;
        r->next = p; // Insert p into the linked list
        r = p; // Update r to point to p
    }
    return OK;
}

Status CreateList_L(LinkList L, ElemType a[ ], int n)
{
    LNode *r = L;
    int i = 0;
    for(;i < n;i ++)
    {
        LNode *p ;
        p = (LNode*)malloc(sizeof(LNode));//初始化指针，为其分配内存空间，防止出现内存泄漏和未定义行为
        p->data = a[i];//正序时：a[i]   逆序时：a[n - i - 1]
        p->next = NULL;
        r->next = p;//将p插入链表中
        r = p;//更新r的结点，变成指向p的结点
    }
    return OK;
}

int main()
{
    LinkList L;
    if (InitList(&L) == OK)
    {
        printf("List initialized successfully.\n");

        // Example usage
        ListInsert(&L, 1, 10);
        ListInsert(&L, 2, 20);
        ListInsert(&L, 3, 30);
        printf("Inserted elements: ");
        DisplayList(L);

        ElemType e;
        if (GetElem(L, 2, &e) == OK)
            printf("Element at position 2: %d\n", e);

        LinkList found = LocateElem(L, 20);
        if (found)
            printf("Element 20 found.\n");

        if (ListDelete(L, 2) == OK)
        {
            printf("Deleted element at position 2.\n");
            printf("Current list: ");
            DisplayList(L);
        }

        // Create a linked list with elements in reverse order
        ElemType arr[] = {1, 2, 3, 4, 5};
        if (InverseCreateList(L, arr, 5) == OK)
        {
            printf("Linked list created in reverse order: ");
            DisplayList(L);
        }
    }
    else
    {
        printf("Failed to initialize list.\n");
    }

    return 0;
}

```



#### 1.两个递增有序链表求交集

```c
#include <stdio.h>  
#include <stdlib.h>  

#define ERROR 0
#define OK 1

typedef int ElemType;  
typedef int Status; 

// definition of node structure of singly linked list
typedef struct LNode
{  
    ElemType data;           // data field
    struct LNode *next;      // pointer field
} LNode, *LinkList;

//===========================================
// Initialize a singly linked list L with head node
//===========================================
Status InitList_L(LinkList *L)//在初始化链表时，需要修改链表的头指针，所以需要传入的参数是指针的指针的类型
{
    *L = (LinkList)malloc(sizeof(LNode));
    if (!(*L)) return ERROR;
    (*L)->next = NULL;
    return OK;
}

//===========================================
// Create a singly linked list L with head node, and with n elements
//===========================================
Status CreateList_L(LinkList L, ElemType a[], int n)
{
    LNode *r = L;
    int i = 0;
    for (; i < n; i ++)
    {
        LNode *p = (LNode*)malloc(sizeof(LNode));
        if (!p) return ERROR;
        p->data = a[i];
        p->next = NULL;
        r->next = p;
        r = p;
    }
    return OK; 
}

//======================================
// Insert an element in a list
//=======================================
Status ListInsert_L(LinkList L,int i,ElemType e)
{
	LinkList r = L;
	int j = 0;
	while(r && j < i - 1)
	{
		r = r->next;
		++j;
	}
	if(!r || j > i - 1) return ERROR;
	LinkList s = (LNode*) malloc(sizeof(LNode));
	if(!s) return ERROR;
	s->data = e;
	s->next = r->next;
	r->next = s;
	r = s;
	return OK;
}

//===========================================
// 求两个递增链表La和Lb的交集，得到一个新的链表Lc
//===========================================
Status ListIntersection_L(LinkList La, LinkList Lb, LinkList Lc)
{
    int len_c = 0;
    LNode *ra = La->next;
    LNode *rb = Lb->next;
    LNode *rc = Lc; // 指向 Lc 的头结点
    while (ra && rb)
    {
        if (ra->data > rb->data) rb = rb->next;
        else if (ra->data < rb->data) ra = ra->next;
        else
        {
            ListInsert_L(Lc,++len_c,rb->data);
            //如果不用上面的插入函数，就直接插，
//			LNode *s ;
//			s = (LNode*)malloc(sizeof(LNode));
//			s->data = ra->data;
//			s->next = NULL;
//			rc->next = s;
//			rc = s;
            ra = ra->next;
            rb = rb->next;
        }
    }
    return OK;
}

//===========================================
// Print the elements in a list
//===========================================
void LinkedListPrint(LinkList L)
{
    if (L->next == NULL)//鲁棒性问题，
    {
        return;
    }
    LinkList p = L->next;
    while(p)
    {
        printf("%d ",p->data);
        p = p->next;
    }
    printf("\n");
}

int main()  
{  
    int n, m;
    LinkList La, Lb, Lc;
    //初始化指针，修改了链表的头指针，故要传入指针的指针的类型
    InitList_L(&La);
    InitList_L(&Lb);
    InitList_L(&Lc);
    
    scanf("%d", &n);
    int a[n];
    for (int i = 0; i < n; i++)
        scanf("%d", &a[i]);
    CreateList_L(La, a, n);
    
    scanf("%d", &m);
    int b[m];
    for (int i = 0; i < m; i++)
        scanf("%d", &b[i]);
    CreateList_L(Lb, b, m);

    ListIntersection_L(La, Lb, Lc);

    LinkedListPrint(Lc);
    
    return 0;
}

```



#### 2.将链表的最小值移动到链表的头部

```c
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

#define ERROR 0
#define OK 1

typedef int ElemType;
typedef int Status;

// Definition of a node structure for a singly linked list
typedef struct L_node 
{
    ElemType data;           // Data field
    struct L_node *next;     // Pointer field
} LNode, *LinkedList;

//===========================================
// Initialize a singly linked list L with a head node
//===========================================
Status InitList_L(LinkedList *L)
{
    *L = (LNode*)malloc(sizeof(LNode));
    if (!(*L))     return ERROR;
    (*L)->next = NULL;
    return OK;
}

//===========================================
// Create a singly linked list L with a head node, and with n elements
//===========================================
Status CreateList_L(LinkedList *L, ElemType a[], int n)
{
    if (n <= 0)    return ERROR;
    LNode *r = *L;  // r points to the head node
    int j = 0;
    for (; j < n; j++)
    {
        LNode *p = (LNode*)malloc(sizeof(LNode));  // Create a new node
        if (!p)   return ERROR; 
        p->data = a[j];  // Assign data to the new node
        p->next = NULL;  // Set next pointer to NULL

        r->next = p;     // Link the new node to the list
        r = p;           // Move r to the newly added node
    }
    return OK;
}

//===========================================
// Find the minimum value in an array
//===========================================
int find_Min(int arr[], int n)
{
    int min = arr[0], i = 1;
    for (; i < n; i++)
    {
        if (arr[i] < min)     min = arr[i];
    }
    return min;
}

//===========================================
// Move the node containing the minimum value to the head of the linked list
//===========================================
void MoveMinNode_L(LinkedList L, ElemType minval)
{
    // 如果链表为空或者输入无效，无需操作
    if (!L || !L->next)   return;
        
    // 用于跟踪最小值节点前面的节点
    LNode *prev = NULL;

    // 遍历链表的指针
    LNode *cur = L->next;

    // 寻找包含最小值的节点
    while (cur && cur->data != minval)
    {
        prev = cur;
        cur = cur->next;
    }

    // 如果找不到最小值或者最小值已经在链表头部，无需移动
    if (!cur || cur == L->next)    return;

    // 将包含最小值的节点从当前位置分离出来
    prev->next = cur->next;

    // 将分离的节点插入到链表头部
    cur->next = L->next;
    L->next = cur;
}


//void MoveMinNode_L(LinkedList L, ElemType minval)
//
//{
//	if(!L->next) return;
//	LNode* r = L;
//	while(r && r->next->data != minval)	r = r->next;//找到minval的前一个结点 
	//类似于进行一个删除操作 
//	LNode* p = r->next;
//	r->next = p->next;
// 	free(p);
	//类似进行一个插入操作 
// 	LNode *s = L;
//	LNode*q;
//	q = (LNode*)malloc(sizeof(LNode));
//	q->data = minval;
//	q->next = s->next;
//	s->next = q;
//}


//===========================================
// Print the elements in a linked list
//===========================================
void LinkedListPrint(LinkedList L)
{
    LNode *p = L->next;
    while (p)
    {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}

int main()
{
    int n;
    scanf("%d", &n);

    int arr[n];
    int i; 
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    int min = find_Min(arr, n);
    //printf("Minimum value: %d\n", min);
    printf("%d\n",min);

    LinkedList L;
    if (InitList_L(&L) == ERROR)
    {
        printf("Error: Failed to initialize the list.\n");
        return 1;
    }

    if (CreateList_L(&L, arr, n) == ERROR)
    {
        printf("Error: Failed to create the list.\n");
        return 1;
    }

    MoveMinNode_L(L, min);
    //printf("List after moving the minimum value to the head: ");
    LinkedListPrint(L);

    return 0;
}

```



#### 3. 单链表基本操作与应用



```c
#include <stdio.h>
#include <stdlib.h>

// 定义函数执行结果状态代码
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE 0

// 定义新的函数运行结果类型
typedef int Status;

// 动态单链表的结点结构体定义
typedef int ElemType;
typedef struct LNode 
{
    ElemType data;          // 数据域
    struct LNode* next;     // 指针域
} LNode, *LinkList;

// 初始化链表
Status InitList(LinkList *L) 
{
    int x, i;
    // 创建头结点
    *L = (LinkList)malloc(sizeof(LNode));
    if (*L == NULL) 
    {
        printf("内存分配失败\n");
        return ERROR;
    }
    (*L)->next = NULL;

    // 根据键盘输入构建链表
    LinkList r = *L;
    for (i = 0;; i++) 
    {
        scanf("%d", &x);
        if (x == -1)
            break;
        LinkList p = (LinkList)malloc(sizeof(LNode));
        if (!p) 
        {
            printf("初始化失败\n");
            return ERROR;
        }
        p->data = x;
        p->next = NULL;
        r->next = p;
        r = p;
    }
    return OK;
}

// 销毁链表
Status DestroyList(LinkList *L) 
{
    LinkList p;
    while (*L) 
    {
        p = (*L)->next; // p指向下一个结点
        free(*L);       // 释放L
        *L = p;
    }
    return OK;
}

// 判断链表是否为空
Status ListEmpty(LinkList L) 
{
    return (L->next == NULL);
}

// 清空链表
Status ClearList(LinkList L) 
{
    LinkList p, q;
    p = L->next; // p指向链表第一个结点
    while (p)    // 当p指向空时循环结束
    {
        q = p->next;
        free(p);
        p = q;
    }
    L->next = NULL; // 头结点指针域为空
    return OK;
}

// 获取链表的长度
int ListLength(LinkList L) 
{
    LNode *p = L;
    int len = 0;
    while (p->next) 
    {
        len++;
        p = p->next;
    }
    return len;
}

// 删除链表中的第i个元素，并将删除的元素值存储到e中
Status ListDelete(LinkList L, int i, ElemType* e) 
{
    LinkList p = L;
    int j = 0; // 计数器
    // 当第i个结点为空，或者j = i-1时结束循环，此时p指向第i-1个结点
    while (p->next && j < i - 1) 
    {
        p = p->next;
        j++;
    }

    if (!(p->next) || j > i - 1)    return ERROR;

    LinkList q = p->next;   // q保存删除结点地址
    p->next = p->next->next; // 删除
    *e = q->data;           // e存放删除节点的数据
    free(q);                // 释放
    return OK;
}

// 遍历输出链表
Status ListTraverse(LinkList L) 
{
    LinkList p = L->next;
    while (p) // 当p为空时结束循环
    {
        printf("%d ", p->data); // 每一个数据都进行visit函数操作，例如visit可以是打印函数
        p = p->next;
    }
    printf("\n");
    return OK;
}

// 在第i个位置插入元素e
Status ListInsert(LinkList L, int i, ElemType e) 
{
    LinkList p = L;
    int j = 0;
    while (p && j < i - 1) 
    {
        p = p->next;
        ++j;
    }
    if (!p || j > i - 1)   return ERROR;
    LNode *r = (LNode*)malloc(sizeof(LNode));
    if (!r)      return ERROR;
    r->data = e;
    r->next = p->next;
    p->next = r;
    return OK;
}

// 对链表进行操作
Status ListOperate(LinkList L) 
{
    if (ListEmpty(L)) 
    {
        printf("0 0\n");
        return OK;
    }

    int max = L->next->data, min = L->next->data;
    LNode *p = L->next;
    while (p) 
    {
        if (max < p->data)        max = p->data;
        if (min > p->data)		  min = p->data;
        p = p->next;
    }

    ListInsert(L, 1, max);
    ListInsert(L, ListLength(L) + 1, min);
    return OK;
}

int main() 
{
    // 初始化链表
    LinkList L;
    if (InitList(&L) == ERROR)       return 0;
    ListTraverse(L);    // 打印输出初始链表
    printf("%d\n", ListLength(L)); // 打印链表长度

    ListOperate(L);     // 对链表进行操作

    ListTraverse(L);    // 打印输出操作后的链表
    DestroyList(&L);    // 销毁链表

    return 0;
}

```



#### 4.使用链栈检验括号匹配

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 100

typedef int Status;
typedef char SElemType;

// 定义链表栈节点结构
typedef struct StackNode {
    SElemType data;
    struct StackNode *next;
} StackNode, *LinkStack;

// 函数声明
Status InitStack(LinkStack *S);
Status StackEmpty(LinkStack S);
Status Push(LinkStack *S, char ch);
Status Pop(LinkStack *S, char *ch);
Status GetTop(LinkStack S, char *e);
Status match(char element_l, char element_r);

// 初始化链表栈
Status InitStack(LinkStack *S) {
    (*S) = (LinkStack)malloc(sizeof(StackNode));
    if (!(*S))
        return ERROR;
    (*S)->next = NULL;
    return OK;
}

// 判断栈是否为空
Status StackEmpty(LinkStack S) {
    return S->next == NULL ? TRUE : FALSE;
}

// 元素入栈
Status Push(LinkStack *S, char ch) {
    LinkStack s = (LinkStack)malloc(sizeof(StackNode));
    if (!s)
        return ERROR;
    s->data = ch;
    s->next = (*S)->next;
    (*S)->next = s;
    return OK;
}

// 元素出栈
Status Pop(LinkStack *S, char *ch) {
    if (StackEmpty(*S))
        return ERROR;
    LinkStack p = (*S)->next;
    *ch = p->data;
    (*S)->next = p->next;
    free(p);
    return OK;
}

// 获取栈顶元素
Status GetTop(LinkStack S, char *e) {
    if (StackEmpty(S))
        return ERROR;
    *e = S->next->data;
    return OK;
}

// 检查两个括号是否匹配
Status match(char element_l, char element_r) {
    if (element_l == '(') {
        return (element_r == ')') ? TRUE : FALSE;
    } else if (element_l == '[') {
        return (element_r == ']') ? TRUE : FALSE;
    } else if (element_l == '{') {
        return (element_r == '}') ? TRUE : FALSE;
    } else {
        exit(0);
    }
}

int main() {
	//SetConsoleOutputCP(65001);
    LinkStack S;
    char e;
    int length = 0,i;
    char str[MAXSIZE];

    InitStack(&S);
    scanf("%s", str); // 输入一串括号
    length = strlen(str);

    for (i = 0; i < length; i++) {
        switch (str[i]) {
            case '(':
            case '[':
            case '{':
                Push(&S, str[i]);
                break;
            case ')':
            case ']':
            case '}':
                if (StackEmpty(S)) {
                    printf("右括号多余\n");
                    exit(0);
                } else {
                    GetTop(S, &e);
                    if (match(e, str[i])) {
                        Pop(&S, &e);
                    } else {
                        printf("左右括号不匹配\n");
                        exit(0);
                    }
                }
                break;
            default:
                exit(0);
        }
    }

    if (StackEmpty(S)) {
        printf("括号匹配\n");
    } else {
        printf("左括号多余\n");
    }

    return 0;
}


```



#### 5. 合并两个有序链表

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef int ElemType;
typedef int Status;

// Definition of node structure of singly linked list
typedef struct L_node
{
    ElemType data;           // data field 
    struct L_node *next;     // pointer field
} LNode, *LinkedList;

// Initialize a singly linked list L with head node
Status InitLinkList(LinkedList *L)
{
    (*L) = (LNode *) malloc(sizeof(LNode));
    if (!(*L))     return ERROR;
    (*L)->next = NULL;
    return OK;
}

// Create a singly linked list L with head node, and with n elements
Status CreateList_L(LinkedList L, int a[], int n)
{
    LNode *p = L;
    int i = 0;
    for (i = 0; i < n; i++)
    {
        LNode *r = (LNode *) malloc(sizeof(LNode));
        if (!r)
            return ERROR;
        r->data = a[i];
        r->next = NULL;
        p->next = r;
        p = r;
    }
    return OK;
}

// Merge two singly linked lists La and Lb into Lc
void Merge_L(LinkedList *La, LinkedList *Lb, LinkedList *Lc)
{
    LNode *a = (*La)->next;
    LNode *b = (*Lb)->next;
    LNode *c = (*Lc);
    LNode *c1;

    while (a && b)
    {
        c1 = (LNode *) malloc(sizeof(LNode));
        if (!c1)    return; // Allocation failed

        if (a->data <= b->data)
        {
            c1->data = a->data;
            a = a->next;
        } else
        {
            c1->data = b->data;
            b = b->next;
        }
        c1->next = NULL;
        c->next = c1;
        c = c1;
    }

    while (a)
    {
        c1 = (LNode *) malloc(sizeof(LNode));
        if (!c1)    return; // Allocation failed
        c1->data = a->data;
        c1->next = NULL;
        c->next = c1;
        c = c1;
        a = a->next;
    }

    while (b)
    {
        c1 = (LNode *) malloc(sizeof(LNode));
        if (!c1)   return;
		c1->data = b->data;
        c1->next = NULL;
        c->next = c1;
        c = c1;
        b = b->next;
    }
}

// Print the elements in a list
void LinkedListPrint(LinkedList L)
{
    LNode *p = L->next;
    while (p)
    {
        printf("%d ", p->data);
        p = p->next;
    }
}

int main()
{
    LNode *La, *Lb, *Lc;
    InitLinkList(&La);
    InitLinkList(&Lb);
    InitLinkList(&Lc);

    int n, m;
    scanf("%d", &n);
    int a[n];
    int i = 0;
    for (i = 0; i < n; i++)     scanf("%d", &a[i]);

    CreateList_L(La, a, n);

    scanf("%d", &m);
    int b[m];
    for (i = 0; i < m; i++)     scanf("%d", &b[i]);

    CreateList_L(Lb, b, m);

    Merge_L(&La, &Lb, &Lc);

    LinkedListPrint(Lc);

    return OK;
}  

```



#### 6.链表删除



```c
#include <stdio.h>   
#include <stdlib.h>   
#include <malloc.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef int ElemType;
typedef int Status;

// definition of node structure of singly linked list
typedef struct L_node
{
    ElemType data;           // data field 
    struct L_node* next;       // pointer field
}LNode, * LinkList;

//===========================================
// Initialize  a singly linked list L with head node
//===========================================

Status InitList_L(LinkList *L)

{
	(*L) = (LNode*)malloc(sizeof(LNode));
	(*L)->next = NULL;
	return OK;
}

//===========================================
// Create a singly linked list L with head node, and with n elements
//===========================================

Status CreateList_L(LinkList* L, ElemType a[], int n)
{
	LNode *p = *L;
	int j = 0;
	for(;j < n;j ++)
	{
		LNode*r ;
		r = (LNode*)malloc(sizeof(LNode));
		r->data = a[j];
		r->next = NULL;
		p->next = r;
		p = r;
	}
	return OK;
}

void Delete_List(LinkList L,int i)
{
	LNode*prev = L;
	int j = 0;
	while(prev && j < i - 1)
	{
		prev = prev->next;
		j ++;
	}
	if(!prev || j > i - 1) return ;
	LinkList r = prev->next;
	prev->next = r->next;
	free(r);
	return ;
}
//===========================================
//  删除位序为偶数的结点，并返回删除结点的总数
//===========================================

int Delete_L(LinkList *L,int len)
{
	int i = len / 2;
	int j = 2 * i;
	int count = 0;
	for(;j >1;j -=2)	
	{
		Delete_List(*L,j);
		count ++;
	}
	return count;
}
//======================================
// Print the elements in a list
//=======================================

void LinkedListPrint(LinkList L)

{
	LNode *p = L->next;
	while(p)
	{
		printf("%d ",p->data);
		p = p->next;
	}
	return;
}

int main()
{
	LNode *L;
	InitList_L(&L);
	int i = 0,n;
	scanf("%d",&n);
	int arr[n];
	for(;i < n;i ++) scanf("%d",&arr[i]);
	CreateList_L(&L,arr,n);
	int tot = Delete_L(&L,n);
	printf("%d\n",tot);
	LinkedListPrint(L);
	return OK;
}
```



#### 7.链表拼接

```c
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef int ElemType;
typedef int Status;

// definition of node structure of singly linked list
typedef struct L_node
{
    ElemType data;           // data field 
    struct L_node *next;       // pointer field
} LNode, *LinkedList;

//===========================================
// Initialize  a singly linked list L with head node
//===========================================
Status InitList_L(LinkedList *L)
{
    *L = (LNode *) malloc(sizeof(LNode));
    if (!(*L)) return ERROR;
    (*L)->next = NULL;
    return OK;
}

//===========================================
// Create a singly linked list L with head node, and with n elements
//===========================================

Status CreateList_L(LinkedList *L, int a[], int n)
{
    LNode *r = (*L);
    int i = 0;
    for (; i < n; i++)
    {
        LNode *p;
        p = (LNode *) malloc(sizeof(LNode));
        p->data = a[i];
        p->next = NULL;
        r->next = p;
        r = p;
    }
    return OK;
}

//===========================================
//  Merge two singly linked lists 
//===========================================

int Merge_L(LinkedList *ha, int len_a, LinkedList *hb, int len_b, LinkedList *hc)
{
    LNode *a = (*ha)->next;
    LNode *b = (*hb)->next;
    LNode *c = *hc;
    LNode *c1;
    c1 = (LNode *) malloc(sizeof(LNode));
    if (len_a > len_b)
    {
        while (b)
        {
            c1 = b;
            c->next = c1;
            c = c1;
            b = b->next;
        }
        while (a)
        {
            c1 = a;
            c->next = c1;
            c = c1;
            a = a->next;
        }
    } 
    else
    {
        while (a)
        {
            c1 = a;
            c->next = c1;
            c = c1;
            a = a->next;
        }
        while (b)
        {
            c1 = b;
            c->next = c1;
            c = c1;
            b = b->next;
        }
    }
}

//======================================
// Print the elements in a list
//=======================================

void LinkedListPrint(LinkedList L)
{
    LNode *p = L->next;
    while (p)
    {
        printf("%d ", p->data);
        p = p->next;
    }
}

int main()
{
    LNode *La;
    LNode *Lb;
    LNode *Lc;
    InitList_L(&La);
    InitList_L(&Lb);
    InitList_L(&Lc);
    int n, m, i = 0;
    scanf("%d", &n);
    int a[n];
    for (; i < n; i++) scanf("%d", &a[i]);
    CreateList_L(&La, a, n);
    scanf("%d", &m);
    int b[m];
    for (i = 0; i < m; i++) scanf("%d", &b[i]);
    CreateList_L(&Lb, b, m);
    Merge_L(&La, n, &Lb, m, &Lc);
    LinkedListPrint(Lc);
	return OK;
}  
```



#### 双向链表学习代码：

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1

typedef int ElemType;
typedef int Status;

typedef struct DuLNode
{
    ElemType data;          // 数据域
    struct DuLNode *prior;  // 指向直接前驱
    struct DuLNode *next;   // 指向直接后继
} DuLNode, *DuLinkList;

Status GetElem_DuL(DuLinkList L, int i, ElemType *e)
{
    int j;
    DuLinkList p;
    p = L->next; // p指向第一个结点
    j = 1;
    while (p && j < i)
    {
        p = p->next;
        ++j;
    }
    if (!p || j > i)
        return ERROR; // 第i个元素不存在
    *e = p->data;     // 取第i个元素的数据
    return OK;
}

Status ListInsert_DuL(DuLinkList *L, int i, ElemType e)
{
    DuLinkList p, s;
    if (i < 1) // 如果位置不合法
        return ERROR;

    s = (DuLinkList) malloc(sizeof(DuLNode));
    if (!s)
        exit(EXIT_FAILURE); // 内存分配失败，退出程序
    s->data = e;

    if (i == 1 || !(*L)->next)
    { // 在第一个位置插入或者链表为空时
        s->next = (*L)->next;
        if ((*L)->next) // 如果链表不为空
            (*L)->next->prior = s;
        s->prior = *L;
        (*L)->next = s;
        return OK;
    }

    p = (*L)->next;
    while (--i && p) p = p->next; // 找到第 i-1 个节点
    if (!p) // 如果位置超出链表长度
        return ERROR;

    s->next = p->next;
    s->next->prior = s;
    s->prior = p;
    p->next = s;
    return OK;
}


Status ListDelete_DuL(DuLinkList *L, int i)
{
    DuLinkList p, q;
    int j = 1;
    p = *L; // 将 p 指向头节点
    while (p->next && j < i)
    {
        p = p->next;
        ++j;
    }
    if (!p->next || j > i)
        return ERROR; // 第i个元素不存在
    q = p->next;
    p->next = q->next;
    if (q->next) // 如果 q 的下一个节点不为空
        q->next->prior = p;
    free(q);
    return OK;
}


int main()
{
    DuLinkList L;
    L = (DuLinkList) malloc(sizeof(DuLNode));
    if (!L)
        exit(EXIT_FAILURE); // 内存分配失败，退出程序
    L->next = NULL;
    ElemType e;
    if (ListInsert_DuL(&L, 1, 10) == OK)
        printf("Insert successful!\n");
    if (GetElem_DuL(L, 1, &e) == OK)
        printf("The first element is: %d\n", e);
    if (ListDelete_DuL(&L, 1) == OK)
        printf("Delete successful!\n");
    //system("pause");
    return 0;
}

```

