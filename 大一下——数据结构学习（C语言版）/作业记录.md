### 作业1——C语言复习

#### 1. ACM2024-第一章-C语言回顾-结构体2

#### 2. ACM2024-第一章-C语言回顾-结构体2

#### 3. ACM2024-第一章-C语言回顾-结构体1

#### 4. ACM2024-第一章-C语言回顾-数组最大值

#### 5. ACM2024-第一章-C语言回顾-数组1



### 作业2——顺序表



#### 1. ACM2023-第二章-线性表-交叉合并两个顺序表- LJD



```c
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0
#define MAXSIZE 20

typedef int Status;
typedef int ElemType;

typedef struct {
    ElemType data[MAXSIZE];
    int length;
} SqList;

// 遍历顺序表并打印元素
void TraverseList(SqList L) 
{
    for (int i = 0; i < L.length; i++) 
    {
        printf("%d ", L.data[i]);
    }
    printf("\n");
}

// 获取顺序表的长度
int GetListLength(SqList L) 
{
    return L.length;
}

// 获取指定位置的元素值
Status GetElemAt(SqList L, int i, ElemType *e) 
{
    if (i < 1 || i > L.length)
        return ERROR;
    *e = L.data[i - 1];
    return OK;
}

// 在指定位置插入元素
Status InsertIntoList(SqList *L, int i, ElemType e) 
{
    if (L->length >= MAXSIZE || i < 0 || i > L->length)
        return ERROR;
    for (int k = L->length - 1; k >= i; k--) 
    {
        L->data[k + 1] = L->data[k];
    }
    L->data[i] = e;
    L->length++;
    return OK;
}

// 将两个顺序表的元素交错到第三个顺序表中
void InterleaveLists(SqList *L3, SqList L1, SqList L2) 
{
    int i = 1;
    int e;
    while (i <= L1.length || i <= L2.length) 
    {
        int tag = i;//作为判断标志	是否已经插了L1	矫正i 的值
        if (i <= L1.length) 
        {
            GetElemAt(L1, i, &e);
            InsertIntoList(L3, L3->length, e);
            i++;
        }
        if (i - 1 <= L2.length) 
        {
            if (tag != i) i--;
            GetElemAt(L2, i, &e);
            InsertIntoList(L3, L3->length, e);
            i++;
        }
    }
}

int main() 
{
    SqList L1, L2, L3;
    Status i;
    int j, k, l;

    // 输入并创建第一个顺序表
    scanf("%d", &k);
    L1.length = 0;
    if (k > 0)
        for (j = 1; j <= k; j++) 
        {
            scanf("%d", &l);
            i = InsertIntoList(&L1, 0, l);
        }

    // 打印第一个顺序表及其长度
    TraverseList(L1);
    printf("%d \n", GetListLength(L1));

    // 输入并创建第二个顺序表
    scanf("%d", &k);
    L2.length = 0;
    if (k > 0)
        for (j = 1; j <= k; j++) 
        {
            scanf("%d", &l);
            i = InsertIntoList(&L2, 0, l);
        }

    // 打印第二个顺序表及其长度
    TraverseList(L2);
    printf("%d \n", GetListLength(L2));

    // 将两个顺序表的元素交错到第三个顺序表中
    L3.length = 0;
    InterleaveLists(&L3, L1, L2);

    // 打印交错后的顺序表及其长度
    TraverseList(L3);
    printf("%d \n", GetListLength(L3));

    return OK;
}

```



#### 2. ACM2023-第二章-线性表-顺序表的各种操作练习- LJD



```c
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE 0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
typedef int ElemType;

#define INIT_SIZE 100       // 初始分配空间的大小
#define LISTINCREMENT 10    // 分配增量

typedef struct {
    ElemType *elem;         // 存储空间的起始地址
    int length;             // 线性表中数据元素个数，即表长
    int listsize;           // 线性表所申请的存储空间的大小
} SqList;

// 创建一个空的线性表
SqList CreateList_Sq(SqList L)
{
    L.elem = (ElemType*)malloc(100 * sizeof(ElemType));  // 申请空间
    L.length = 0;         // 表长为0
    L.listsize = 100;     // 申请的空间为初始大小
    return L;
}

// 在线性表的第i个位置前插入元素e
void InsertList_Sq(SqList *L, int i, ElemType e)
{
    int *newbase, *q, *p;
    if ((i < 1) || (i > L->length + 1)) 
    {
        printf("i值不合法!\n");
        exit(ERROR);
    }
    // 当前空间已满，增加分配空间
    if (L->length >= L->listsize) 
    {   
        newbase = (ElemType*)realloc(L->elem, (L->listsize + LISTINCREMENT) * sizeof(ElemType));
        if (!newbase) exit(ERROR);
        L->elem = newbase;
        L->listsize = L->listsize + LISTINCREMENT;
    }
    //检查完错误	开始插值
    int j;
    for (j = L->length - 1; j >= i - 1; j--) 
    {
        L->elem[j + 1] = L->elem[j]; // 将元素后移
    }
    L->elem[i - 1] = e;
    L->length++;//插完后	莫忘更新线性表的长度
    return OK;
}

// 删除线性表中的第i个元素
void DeleteList_Sq(SqList *L, int i)
{
    int j;
    if ((i < 1) || (i > L->length)) {
        printf("i值不合法!\n");
        exit(ERROR);
    }
    for (j = i; j < L->length; j++) {
        L->elem[j - 1] = L->elem[j];
    }
    L->length--;
}

// 遍历顺序线性表并输出
void Print_Sq(SqList L)
{
    int i;
    for (i = 0; i < L.length; i++) {
        printf("%3d ", L.elem[i]);
    }
}

// 判两个元素是否相等
int equal(ElemType e1, ElemType e2)
{
    if (e1 == e2) return 1;
    else return 0;
}

// 查找元素在顺序表中的位置
int LocateElem_Sq(SqList L, ElemType e, int (* compare)(ElemType e1, ElemType e2))
{
    int i = 0;
    for (; i < L.length; i++) {
        if (compare(L.elem[i], e)) return i + 1;
    }
    return ERROR;
}

void Getelem(SqList L, int i, ElemType *e)
{
    if (i < 1 || i > L.length) return;
    *e = L.elem[i - 1];
    return;
}

int main()
{
    int i;
    ElemType e;
    SqList Lq;
    Lq = CreateList_Sq(Lq);
    InsertList_Sq(&Lq, 1, 21);
    InsertList_Sq(&Lq, 2, 18);
    InsertList_Sq(&Lq, 3, 30);
    InsertList_Sq(&Lq, 4, 75);
    InsertList_Sq(&Lq, 5, 42);
    InsertList_Sq(&Lq, 6, 56);
    printf("初始顺序表为\n");
    Print_Sq(Lq);
    InsertList_Sq(&Lq, 3, 67);
    printf("\n插入67后顺序表为\n");
    Print_Sq(Lq);
    DeleteList_Sq(&Lq, 6);
    printf("\n删除第6个元素后顺序表为\n");
    Print_Sq(Lq);
    if ((i = LocateElem_Sq(Lq, 75, equal)))
        printf("\n存在元素75且位置为%d\n", i);
    else
        printf("\n不存在元素75\n");
    free(Lq.elem);
    return 1;
}

```



#### 3. ACM2023-第二章-顺序表练习题 -合并两有序表 - LJD



```c
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE 0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10
typedef int ElemType;

typedef struct {
    ElemType *elem;
    int length;
    int listsize;
} SqList;

// Create an empty list
Status InitList_Sq(SqList *L)
{
    //学生添加
    L->elem = (int*)malloc(INIT_SIZE*sizeof(int));
    if (!L->elem) return OVERFLOW;
    L->length = 0;
    L->listsize = INIT_SIZE; 
}

// Create an array based list with n elements
Status CreateList_Sq(SqList *L, int a[], int n)
{
    //学生添加
    int j = 0;
    for(; j < n; j++)
    {
        L->elem[j] = a[j];
    }
    L->length = n;
}

// Get Element
Status GetElem(SqList L, int i, int *e)
{
    //学生添加
    if(i < 1 || i > L.length) return ERROR;
    *e = L.elem[i - 1];
    return OK;
}

// Insert
Status ListInsert(SqList *L, int i, int e)
{
    //学生添加
    if(i < 1 || i > L->length + 1) return ERROR;
    if(L->length == L->listsize) return ERROR;
    int j = L->length - 1;
    for(; j >= i - 1; j--)
    {
        L->elem[j + 1] = L->elem[j];
    }
    L->elem[i - 1] = e;
    L->length++;
    return OK;
}

// Merge two sequential lists 
Status MergeList_Sq(SqList L1, SqList L2, SqList *L3)
{  
    //学生添加
    int i = 0, j = 0, k = 0;
    
    
    while(i < L1.length && j < L2.length)
    {
        if(L1.elem[i] <= L2.elem[j])
        {
            L3->elem[k++] = L1.elem[i++];
        }
        else
        {
            L3->elem[k++] = L2.elem[j++];
        }
    }
    while(i < L1.length)
    {
        L3->elem[k++] = L1.elem[i++];
    }
    while(j < L2.length)
    {
        L3->elem[k++] = L2.elem[j++];
    }
    L3->length = k;
    
    
    //上面的三个while循环逻辑更加清晰	
    //下面一个看着很复杂
    //while (L3->length < L1.length + L2.length)
    //{
    //	if (len1 < L1.length && (L1.elem[len1] <= L2.elem[len2] || len2 >= L2.length))
    //	{
    //		L3->elem[len3++] = L1.elem[len1++];
    //		L3->length++;
    //	}
    //	else if (len2 < L2.length && (L2.elem[len2] < L1.elem[len1] || len1 >= L1.length))
    //	{
    //		L3->elem[len3++] = L2.elem[len2++];
    //		L3->length++;
    //	}
    //}
    
}

// Print out all elements
void PrintList_Sq(SqList L)
{ 
    //学生添加
    int j = 0;
    for(; j < L.length; j++)
    {
        printf("%d ", L.elem[j]);
    }
}

int main()
{
    int n1, n2, i, j;
    int a[20], b[20];
    SqList L1, L2, L3;

    scanf("%d", &n1);
    for(i = 0; i < n1; i++)
    {
        scanf("%d", &a[i]);
    }
    scanf("%d", &n2);
    for(i = 0; i < n2; i++)
    {
        scanf("%d", &b[i]);
    }

    InitList_Sq(&L1);
    InitList_Sq(&L2);
    InitList_Sq(&L3);

    CreateList_Sq(&L1, a, n1);
    CreateList_Sq(&L2, b, n2);

    MergeList_Sq(L1, L2, &L3);

    PrintList_Sq(L3);

    return 0;
}

```



#### 4. ACM2023-第二章-顺序表练习题 -删除顺序表指定位置n后的m个元素 - LJD



```C
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE  0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10  
typedef int ElemType;

typedef struct
{
    ElemType *elem;
    int length;
    int listsize;
}SqList;

// Initialize an empty list
Status InitList_Sq(SqList *L)
{
 //学生添加
 	L->elem = (int*)malloc(INIT_SIZE * sizeof(int));
    if (!L->elem) return OVERFLOW;
 	L->length = 0;
 	L->listsize = INIT_SIZE;
}
//Create an array based list with n elements
Status CreateList_Sq(SqList *L, int a[], int n)
{
 //学生添加
	int i = 0;
	for(;i < n;i ++)
	{
		L->elem[i] = a[i]; 
	}
	L->length = n;
    return OK;
}

// Delete the ith elements of sequential list L
Status DeleteList_Sq(SqList *L, int m,int k)
{    
 //学生添加
       if (m < 0 || m > L->length || k < 0)
        return ERROR;
 	int i = 0; 	
 	for(;m < L->length - k;m ++)
 	{
 		L->elem[m] = L->elem[m + k];
	 }
	 L->length -=k;
}

//print out all elements
void PrintList_Sq(SqList L)
{ 
 //学生添加
	 int i = 0;
	 for(;i < L.length;i ++)
	 {
	 	printf("%d ",L.elem[i]); 
	 }
}

int main()
{ 
	int n;
	scanf("%d",&n);
	int i,arr[n];
	for(i = 0;i < n;i ++)
	{
		scanf("%d",&arr[i]);
	 }
    
	 SqList sq;
	 InitList_Sq(&sq);	 
	 CreateList_Sq(&sq,arr,n);
	 
	 int m,k; 
	 scanf("%d%d",&m,&k);
	 
	 DeleteList_Sq(&sq,m,k);
	 
	 PrintList_Sq(sq);	 
	 return 0;
}

```



#### 5. ACM2023-第二章-顺序表练习题 -就地逆置顺序表 - LJD



```c
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE  0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10  
typedef int ElemType;

typedef struct {
    ElemType *elem;
    int length;
    int listsize;
} SqList;

// Create an empty list
Status InitList_Sq(SqList *L)
{
    //学生添加
    L->elem = (int*)malloc(INIT_SIZE * sizeof(int));
    L->length = 0;
    L->listsize = INIT_SIZE;
}

// Create an array based list with n elements
Status CreateList_Sq(SqList *L, int a[], int n)
{
    //学生添加
    int i = 0;
    for(; i < n; i++)
    {
        L->elem[i] = a[i];
    }
    L->length = n;
}

// Reverse the elements of sequential list L
void swap(int *a, int *b)
{
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;	
}

Status ReverseList_Sq(SqList *L)
{    
    //学生添加
    int i = 0;
    for(; i < L->length / 2; i++)
    {
        swap(&L->elem[i], &L->elem[L->length - i - 1]); 
    }
    return OK;
}

// print out all elements
void PrintList_Sq(SqList L)
{ 
    //学生添加
    int i = 0;
    for(; i < L.length; i++)
    {
        printf("%d ", L.elem[i]);
    }
}

int main()
{ 
    //学生添加
    int n;
    scanf("%d", &n);
    int arr[n];
    int i = 0;
    for(; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }
    SqList sq;
    InitList_Sq(&sq);
    CreateList_Sq(&sq, arr, n);
    ReverseList_Sq(&sq);
    PrintList_Sq(sq);
    return 0;
}

```



#### 6. ACM2023-第二章-顺序表练习题 -顺序表排序 - LJD



```C
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>

#define TRUE  1
#define FALSE 0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10  
typedef int ElemType;

typedef struct{
    ElemType *elem;
    int length;
    int listsize;
} SqList;

// Create an empty list
Status InitList_Sq(SqList *L)
{
    //学生添加
    L->elem = (int*)malloc(INIT_SIZE*sizeof(int));
    L->length = 0;
    L->listsize = INIT_SIZE;
}

// Create an array based list with n elements
Status CreateList_Sq(SqList *L, int a[], int n)
{
    //学生添加
    int i = 0;
    for(; i < n; i++)
    {
        L->elem[i] = a[i];
    }
    L->length = n;
}

// Sort the elements of sequential list L into ascending order
Status SortList_Sq(SqList *L)
{    
    //学生添加
    int i = 0, j = 0;
    for(; i < L->length - 1; i++)
    {
        for(j = 0; j < L->length - i - 1; j++)
        {
            if(L->elem[j] > L->elem[j + 1])
            {
                int temp = L->elem[j];
                L->elem[j] = L->elem[j + 1];
                L->elem[j + 1] = temp;
            }
        }
    }
}

// Print out all elements
void PrintList_Sq(SqList L)
{ 
    //学生添加
    int i = 0;
    for(; i < L.length; i++)
    {
        printf("%d ", L.elem[i]);
    }
}

int main()
{ 
    //学生添加
    int n;
    scanf("%d", &n);
    int i = 0, arr[n];
    for(; i < n; i++)
    {
        scanf("%d", &arr[i]);
    } 
    SqList sq;
    InitList_Sq(&sq);
    CreateList_Sq(&sq, arr, n);
    SortList_Sq(&sq);
    PrintList_Sq(sq);
    return 0;
}

```



#### 7. ACM2023-第二章-顺序表练习题 -在顺序表的指定位置插入指定元素 -LJD

```c
#include <stdio.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int Status;
#define INIT_SIZE 100
#define LISTINCREMENT 10  
typedef int ElemType;

typedef struct {
    ElemType *elem;
    int length;
    int listsize;
} SqList;

// 创建一个空的顺序表
Status InitList_Sq(SqList *L) 
{
    L->elem = (int *)malloc(INIT_SIZE * sizeof(int));
    if (!L->elem) 
    {
        printf("Memory allocation failed.\n");
        return OVERFLOW;
    }
    L->length = 0;
    L->listsize = INIT_SIZE;
    return OK;
}

// 创建一个带有 n 个元素的数组列表
Status CreateList_Sq(SqList *L, int a[], int n) 
{
    if (n > INIT_SIZE) 
    {
        printf("The number of elements exceeds the initial size.\n");
        return ERROR;
    }
    int i;
    for (i = 0; i < n; i++) 
    {
        InsertList_Sq(L, i + 1, a[i]);
    }
    return OK;
}

// 在顺序表 L 的特定位置插入元素
Status InsertList_Sq(SqList *L, int i, ElemType e) 
{    
    if (i < 1 || i > L->length + 1) 
    {
        printf("Invalid position.\n");
        return ERROR;
    }
    if (L->length >= L->listsize) 
    {
        printf("The list is full. No more space to insert.\n");
        return OVERFLOW; // 检查是否需要扩展顺序表的空间
    }
    int j;
    for (j = L->length - 1; j >= i - 1; j--) 
    {
        L->elem[j + 1] = L->elem[j]; // 将元素后移
    }
    L->elem[i - 1] = e;
    L->length++;
    return OK;
}

// 打印所有元素
void PrintList_Sq(SqList L) 
{
    int i;
    for (i = 0; i < L.length; i++) 
    {
        printf("%d ", L.elem[i]); 
    }
    printf("\n");
}

int main() 
{
    int n, e, k;
   // printf("Enter the number of elements: ");
    scanf("%d", &n);
    if (n <= 0) 
    {
       // printf("Invalid number of elements.\n");
        return ERROR;
    }
    int i, arr[n];
    //printf("Enter the elements: ");
    for (i = 0; i < n; i++) 
    {
        scanf("%d", &arr[i]);
    }
    SqList sq;
    if (InitList_Sq(&sq) != OK) 
    {
        return ERROR;
    }
    if (CreateList_Sq(&sq, arr, n) != OK) 
    {
        return ERROR;
    }
    //printf("Enter the element and the position to insert: ");
    scanf("%d%d", &e, &k);
    if (InsertList_Sq(&sq, k, e) != OK) 
    {
        return ERROR;
    }
    //printf("The list after insertion: ");
    PrintList_Sq(sq);
    return 0;
}

```

### 作业3——链表



#### 单链表学习代码：

```c
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0

typedef int ElemType;
typedef int Status;

typedef struct LNode
{
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// Initialize a linked list
Status InitList(LinkList *L)
{
    *L = (LinkList)malloc(sizeof(LNode));
    if (!(*L)) return ERROR;
    (*L)->next = NULL;
    return OK;
}

// Get the value at a given position
Status GetElem(LinkList L, int i, ElemType *e)
{
    LNode *p = L->next;
    int j = 1;
    while (p && j < i)
    {
        p = p->next;
        ++j;
    }
    if (!p || j > i) return ERROR;
    *e = p->data;
    return OK;
}

// Locate the element with a given value
LinkList LocateElem(LinkList L, ElemType e)
{
    LinkList p = L->next;
    while (p && p->data != e)
    {
        p = p->next;
    }
    return p;
}

// Insert an element at a given position
Status ListInsert(LinkList *L, int i, ElemType e)
{
    LinkList p = *L;
    int j = 0;
    while (p && j < i - 1)
    {
        p = p->next;
        ++j;
    }
    if (!p || j > i - 1) return ERROR;
    LinkList s = (LinkList)malloc(sizeof(LNode));
    if (!s) return ERROR;
    s->data = e;
    s->next = p->next;
    p->next = s;
    return OK;
}

// Delete the element at a given position
Status ListDelete(LinkList L, int i)
{
    LinkList p = L;
    int j = 0;
    while (p->next && j < i - 1)//循环终止后  p指向的第 i - 1个位置的结点
    {
        p = p->next;
        ++j;
    }
    if (!(p->next) || j > i - 1) return ERROR;//前者便是的是此链表最大长度小于 i，没有第i 个结点
    LinkList q = p->next;
    p->next = q->next;//不能直接使用p->next->next，会造成p->next的内存地址无法找到，内存泄漏
    free(q);
    return OK;
}

// Display the elements in the linked list
void DisplayList(LinkList L)
{
    LinkList p = L->next;
    while (p)
    {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}


/*逆序创建链表通常是为了更高效地插入元素。在逆序创建链表时，我们可以直接将新元素插入链表的头部，而不需要遍历整个链表找到尾部再插入。这样做的好处是，每次插入操作的时间复杂度为O(1)，而不是O(n)，因为不需要遍历链表。

如果采用正序创建链表，每次插入元素都需要遍历到链表的尾部，时间复杂度为O(n)，这在插入大量元素时会导致性能下降。*/

// Create a linked list with elements in reverse order
Status InverseCreateList(LinkList L, ElemType a[], int n)
{
    LNode *r = L;
    int i = 0;
    for(; i < n; i++)
    {
        LNode *p ;
        p = (LNode*)malloc(sizeof(LNode));
        p->data = a[n - i - 1]; // Insert elements in reverse order
        p->next = NULL;
        r->next = p; // Insert p into the linked list
        r = p; // Update r to point to p
    }
    return OK;
}

Status CreateList_L(LinkList L, ElemType a[ ], int n)
{
    LNode *r = L;
    int i = 0;
    for(;i < n;i ++)
    {
        LNode *p ;
        p = (LNode*)malloc(sizeof(LNode));//初始化指针，为其分配内存空间，防止出现内存泄漏和未定义行为
        p->data = a[i];//正序时：a[i]   逆序时：a[n - i - 1]
        p->next = NULL;
        r->next = p;//将p插入链表中
        r = p;//更新r的结点，变成指向p的结点
    }
    return OK;
}


//利用头插法对单链表进逆序
void reverse_List(LinkList L)
{
    LNode* p, * q, * r;
    q = L->next;
    p = L->next->next;
    while (p)
    {
        r = p->next;
        p->next = L->next;
        L->next = p;
        //p = p->next;之所以不能这样做，是因为p->next在之前被改了
        //这也是为什么需要额外的一个r来记录p->next
        p = r;
    }
    q->next = NULL;
}

int main()
{
    LinkList L;
    if (InitList(&L) == OK)
    {
        printf("List initialized successfully.\n");

        // Example usage
        ListInsert(&L, 1, 10);
        ListInsert(&L, 2, 20);
        ListInsert(&L, 3, 30);
        printf("Inserted elements: ");
        DisplayList(L);

        ElemType e;
        if (GetElem(L, 2, &e) == OK)
            printf("Element at position 2: %d\n", e);

        LinkList found = LocateElem(L, 20);
        if (found)
            printf("Element 20 found.\n");

        if (ListDelete(L, 2) == OK)
        {
            printf("Deleted element at position 2.\n");
            printf("Current list: ");
            DisplayList(L);
        }

        // Create a linked list with elements in reverse order
        ElemType arr[] = {1, 2, 3, 4, 5};
        if (InverseCreateList(L, arr, 5) == OK)
        {
            printf("Linked list created in reverse order: ");
            DisplayList(L);
        }
    }
    else
    {
        printf("Failed to initialize list.\n");
    }

    return 0;
}

```



#### 1.两个递增有序链表求交集

```c
#include <stdio.h>  
#include <stdlib.h>  

#define ERROR 0
#define OK 1

typedef int ElemType;  
typedef int Status; 

// definition of node structure of singly linked list
typedef struct LNode
{  
    ElemType data;           // data field
    struct LNode *next;      // pointer field
} LNode, *LinkList;

//===========================================
// Initialize a singly linked list L with head node
//===========================================
Status InitList_L(LinkList *L)//在初始化链表时，需要修改链表的头指针，所以需要传入的参数是指针的指针的类型
{
    *L = (LinkList)malloc(sizeof(LNode));
    if (!(*L)) return ERROR;
    (*L)->next = NULL;
    return OK;
}

//===========================================
// Create a singly linked list L with head node, and with n elements
//===========================================
Status CreateList_L(LinkList L, ElemType a[], int n)
{
    LNode *r = L;
    int i = 0;
    for (; i < n; i ++)
    {
        LNode *p = (LNode*)malloc(sizeof(LNode));
        if (!p) return ERROR;
        p->data = a[i];
        p->next = NULL;
        r->next = p;
        r = p;
    }
    return OK; 
}

//======================================
// Insert an element in a list
//=======================================
Status ListInsert_L(LinkList L,int i,ElemType e)
{
	LinkList r = L;
	int j = 0;
	while(r && j < i - 1)
	{
		r = r->next;
		++j;
	}
	if(!r || j > i - 1) return ERROR;
	LinkList s = (LNode*) malloc(sizeof(LNode));
	if(!s) return ERROR;
	s->data = e;
	s->next = r->next;
	r->next = s;
	r = s;
	return OK;
}

//===========================================
// 求两个递增链表La和Lb的交集，得到一个新的链表Lc
//===========================================
Status ListIntersection_L(LinkList La, LinkList Lb, LinkList Lc)
{
    int len_c = 0;
    LNode *ra = La->next;
    LNode *rb = Lb->next;
    LNode *rc = Lc; // 指向 Lc 的头结点
    while (ra && rb)
    {
        if (ra->data > rb->data) rb = rb->next;
        else if (ra->data < rb->data) ra = ra->next;
        else
        {
            ListInsert_L(Lc,++len_c,rb->data);
            //如果不用上面的插入函数，就直接插，
//			LNode *s ;
//			s = (LNode*)malloc(sizeof(LNode));
//			s->data = ra->data;
//			s->next = NULL;
//			rc->next = s;
//			rc = s;
            ra = ra->next;
            rb = rb->next;
        }
    }
    return OK;
}

//===========================================
// Print the elements in a list
//===========================================
void LinkedListPrint(LinkList L)
{
    if (L->next == NULL)//鲁棒性问题，
    {
        return;
    }
    LinkList p = L->next;
    while(p)
    {
        printf("%d ",p->data);
        p = p->next;
    }
    printf("\n");
}

int main()  
{  
    int n, m;
    LinkList La, Lb, Lc;
    //初始化指针，修改了链表的头指针，故要传入指针的指针的类型
    InitList_L(&La);
    InitList_L(&Lb);
    InitList_L(&Lc);
    
    scanf("%d", &n);
    int a[n];
    for (int i = 0; i < n; i++)
        scanf("%d", &a[i]);
    CreateList_L(La, a, n);
    
    scanf("%d", &m);
    int b[m];
    for (int i = 0; i < m; i++)
        scanf("%d", &b[i]);
    CreateList_L(Lb, b, m);

    ListIntersection_L(La, Lb, Lc);

    LinkedListPrint(Lc);
    
    return 0;
}

```



#### 2.将链表的最小值移动到链表的头部

```c
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

#define ERROR 0
#define OK 1

typedef int ElemType;
typedef int Status;

// Definition of a node structure for a singly linked list
typedef struct L_node 
{
    ElemType data;           // Data field
    struct L_node *next;     // Pointer field
} LNode, *LinkedList;

//===========================================
// Initialize a singly linked list L with a head node
//===========================================
Status InitList_L(LinkedList *L)
{
    *L = (LNode*)malloc(sizeof(LNode));
    if (!(*L))     return ERROR;
    (*L)->next = NULL;
    return OK;
}

//===========================================
// Create a singly linked list L with a head node, and with n elements
//===========================================
Status CreateList_L(LinkedList *L, ElemType a[], int n)
{
    if (n <= 0)    return ERROR;
    LNode *r = *L;  // r points to the head node
    int j = 0;
    for (; j < n; j++)
    {
        LNode *p = (LNode*)malloc(sizeof(LNode));  // Create a new node
        if (!p)   return ERROR; 
        p->data = a[j];  // Assign data to the new node
        p->next = NULL;  // Set next pointer to NULL

        r->next = p;     // Link the new node to the list
        r = p;           // Move r to the newly added node
    }
    return OK;
}

//===========================================
// Find the minimum value in an array
//===========================================
int find_Min(int arr[], int n)
{
    int min = arr[0], i = 1;
    for (; i < n; i++)
    {
        if (arr[i] < min)     min = arr[i];
    }
    return min;
}

//===========================================
// Move the node containing the minimum value to the head of the linked list
//===========================================
void MoveMinNode_L(LinkedList L, ElemType minval)
{
    // 如果链表为空或者输入无效，无需操作
    if (!L || !L->next)   return;
        
    // 用于跟踪最小值节点前面的节点
    LNode *prev = NULL;

    // 遍历链表的指针
    LNode *cur = L->next;

    // 寻找包含最小值的节点
    while (cur && cur->data != minval)
    {
        prev = cur;
        cur = cur->next;
    }

    // 如果找不到最小值或者最小值已经在链表头部，无需移动
    if (!cur || cur == L->next)    return;

    // 将包含最小值的节点从当前位置分离出来
    prev->next = cur->next;

    // 将分离的节点插入到链表头部
    cur->next = L->next;
    L->next = cur;
}


//void MoveMinNode_L(LinkedList L, ElemType minval)
//
//{
//	if(!L->next) return;
//	LNode* r = L;
//	while(r && r->next->data != minval)	r = r->next;//找到minval的前一个结点 
	//类似于进行一个删除操作 
//	LNode* p = r->next;
//	r->next = p->next;
// 	free(p);
	//类似进行一个插入操作 
// 	LNode *s = L;
//	LNode*q;
//	q = (LNode*)malloc(sizeof(LNode));
//	q->data = minval;
//	q->next = s->next;
//	s->next = q;
//}


//===========================================
// Print the elements in a linked list
//===========================================
void LinkedListPrint(LinkedList L)
{
    LNode *p = L->next;
    while (p)
    {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}

int main()
{
    int n;
    scanf("%d", &n);

    int arr[n];
    int i; 
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    int min = find_Min(arr, n);
    //printf("Minimum value: %d\n", min);
    printf("%d\n",min);

    LinkedList L;
    if (InitList_L(&L) == ERROR)
    {
        printf("Error: Failed to initialize the list.\n");
        return 1;
    }

    if (CreateList_L(&L, arr, n) == ERROR)
    {
        printf("Error: Failed to create the list.\n");
        return 1;
    }

    MoveMinNode_L(L, min);
    //printf("List after moving the minimum value to the head: ");
    LinkedListPrint(L);

    return 0;
}

```



#### 3. 单链表基本操作与应用



```c
#include <stdio.h>
#include <stdlib.h>

// 定义函数执行结果状态代码
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE 0

// 定义新的函数运行结果类型
typedef int Status;

// 动态单链表的结点结构体定义
typedef int ElemType;
typedef struct LNode 
{
    ElemType data;          // 数据域
    struct LNode* next;     // 指针域
} LNode, *LinkList;

// 初始化链表
Status InitList(LinkList *L) 
{
    int x, i;
    // 创建头结点
    *L = (LinkList)malloc(sizeof(LNode));
    if (*L == NULL) 
    {
        printf("内存分配失败\n");
        return ERROR;
    }
    (*L)->next = NULL;

    // 根据键盘输入构建链表
    LinkList r = *L;
    for (i = 0;; i++) 
    {
        scanf("%d", &x);
        if (x == -1)
            break;
        LinkList p = (LinkList)malloc(sizeof(LNode));
        if (!p) 
        {
            printf("初始化失败\n");
            return ERROR;
        }
        p->data = x;
        p->next = NULL;
        r->next = p;
        r = p;
    }
    return OK;
}

// 销毁链表
Status DestroyList(LinkList *L) 
{
    LinkList p;
    while (*L) 
    {
        p = (*L)->next; // p指向下一个结点
        free(*L);       // 释放L
        *L = p;
    }
    return OK;
}

// 判断链表是否为空
Status ListEmpty(LinkList L) 
{
    return (L->next == NULL);
}

// 清空链表
Status ClearList(LinkList L) 
{
    LinkList p, q;
    p = L->next; // p指向链表第一个结点
    while (p)    // 当p指向空时循环结束
    {
        q = p->next;
        free(p);
        p = q;
    }
    L->next = NULL; // 头结点指针域为空
    return OK;
}

// 获取链表的长度
int ListLength(LinkList L) 
{
    LNode *p = L;
    int len = 0;
    while (p->next) 
    {
        len++;
        p = p->next;
    }
    return len;
}

// 删除链表中的第i个元素，并将删除的元素值存储到e中
Status ListDelete(LinkList L, int i, ElemType* e) 
{
    LinkList p = L;
    int j = 0; // 计数器
    // 当第i个结点为空，或者j = i-1时结束循环，此时p指向第i-1个结点
    while (p->next && j < i - 1) 
    {
        p = p->next;
        j++;
    }

    if (!(p->next) || j > i - 1)    return ERROR;

    LinkList q = p->next;   // q保存删除结点地址
    p->next = p->next->next; // 删除
    *e = q->data;           // e存放删除节点的数据
    free(q);                // 释放
    return OK;
}

// 遍历输出链表
Status ListTraverse(LinkList L) 
{
    LinkList p = L->next;
    while (p) // 当p为空时结束循环
    {
        printf("%d ", p->data); // 每一个数据都进行visit函数操作，例如visit可以是打印函数
        p = p->next;
    }
    printf("\n");
    return OK;
}

// 在第i个位置插入元素e
Status ListInsert(LinkList L, int i, ElemType e) 
{
    LinkList p = L;
    int j = 0;
    while (p && j < i - 1) 
    {
        p = p->next;
        ++j;
    }
    if (!p || j > i - 1)   return ERROR;
    LNode *r = (LNode*)malloc(sizeof(LNode));
    if (!r)      return ERROR;
    r->data = e;
    r->next = p->next;
    p->next = r;
    return OK;
}

// 对链表进行操作
Status ListOperate(LinkList L) 
{
    if (ListEmpty(L)) 
    {
        printf("0 0\n");
        return OK;
    }

    int max = L->next->data, min = L->next->data;
    LNode *p = L->next;
    while (p) 
    {
        if (max < p->data)        max = p->data;
        if (min > p->data)		  min = p->data;
        p = p->next;
    }

    ListInsert(L, 1, max);
    ListInsert(L, ListLength(L) + 1, min);
    return OK;
}

int main() 
{
    // 初始化链表
    LinkList L;
    if (InitList(&L) == ERROR)       return 0;
    ListTraverse(L);    // 打印输出初始链表
    printf("%d\n", ListLength(L)); // 打印链表长度

    ListOperate(L);     // 对链表进行操作

    ListTraverse(L);    // 打印输出操作后的链表
    DestroyList(&L);    // 销毁链表

    return 0;
}

```



#### 4.使用链栈检验括号匹配

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 100

typedef int Status;
typedef char SElemType;

// 定义链表栈节点结构
typedef struct StackNode {
    SElemType data;
    struct StackNode *next;
} StackNode, *LinkStack;

// 函数声明
Status InitStack(LinkStack *S);
Status StackEmpty(LinkStack S);
Status Push(LinkStack *S, char ch);
Status Pop(LinkStack *S, char *ch);
Status GetTop(LinkStack S, char *e);
Status match(char element_l, char element_r);

// 初始化链表栈
Status InitStack(LinkStack *S) {
    (*S) = (LinkStack)malloc(sizeof(StackNode));
    if (!(*S))
        return ERROR;
    (*S)->next = NULL;
    return OK;
}

// 判断栈是否为空
Status StackEmpty(LinkStack S) {
    return S->next == NULL ? TRUE : FALSE;
}

// 元素入栈
Status Push(LinkStack *S, char ch) {
    LinkStack s = (LinkStack)malloc(sizeof(StackNode));
    if (!s)
        return ERROR;
    s->data = ch;
    s->next = (*S)->next;
    (*S)->next = s;
    return OK;
}

// 元素出栈
Status Pop(LinkStack *S, char *ch) {
    if (StackEmpty(*S))
        return ERROR;
    LinkStack p = (*S)->next;
    *ch = p->data;
    (*S)->next = p->next;
    free(p);
    return OK;
}

// 获取栈顶元素
Status GetTop(LinkStack S, char *e) {
    if (StackEmpty(S))
        return ERROR;
    *e = S->next->data;
    return OK;
}

// 检查两个括号是否匹配
Status match(char element_l, char element_r) {
    if (element_l == '(') {
        return (element_r == ')') ? TRUE : FALSE;
    } else if (element_l == '[') {
        return (element_r == ']') ? TRUE : FALSE;
    } else if (element_l == '{') {
        return (element_r == '}') ? TRUE : FALSE;
    } else {
        exit(0);
    }
}

int main() {
	//SetConsoleOutputCP(65001);
    LinkStack S;
    char e;
    int length = 0,i;
    char str[MAXSIZE];

    InitStack(&S);
    scanf("%s", str); // 输入一串括号
    length = strlen(str);

    for (i = 0; i < length; i++) {
        switch (str[i]) {
            case '(':
            case '[':
            case '{':
                Push(&S, str[i]);
                break;
            case ')':
            case ']':
            case '}':
                if (StackEmpty(S)) {
                    printf("右括号多余\n");
                    exit(0);
                } else {
                    GetTop(S, &e);
                    if (match(e, str[i])) {
                        Pop(&S, &e);
                    } else {
                        printf("左右括号不匹配\n");
                        exit(0);
                    }
                }
                break;
            default:
                exit(0);
        }
    }

    if (StackEmpty(S)) {
        printf("括号匹配\n");
    } else {
        printf("左括号多余\n");
    }

    return 0;
}


```



#### 5. 合并两个有序链表

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef int ElemType;
typedef int Status;

// Definition of node structure of singly linked list
typedef struct L_node
{
    ElemType data;           // data field 
    struct L_node *next;     // pointer field
} LNode, *LinkedList;

// Initialize a singly linked list L with head node
Status InitLinkList(LinkedList *L)
{
    (*L) = (LNode *) malloc(sizeof(LNode));
    if (!(*L))     return ERROR;
    (*L)->next = NULL;
    return OK;
}

// Create a singly linked list L with head node, and with n elements
Status CreateList_L(LinkedList L, int a[], int n)
{
    LNode *p = L;
    int i = 0;
    for (i = 0; i < n; i++)
    {
        LNode *r = (LNode *) malloc(sizeof(LNode));
        if (!r)
            return ERROR;
        r->data = a[i];
        r->next = NULL;
        p->next = r;
        p = r;
    }
    return OK;
}

// Merge two singly linked lists La and Lb into Lc
void Merge_L(LinkedList *La, LinkedList *Lb, LinkedList *Lc)
{
    LNode *a = (*La)->next;
    LNode *b = (*Lb)->next;
    LNode *c = (*Lc);
    LNode *c1;

    while (a && b)
    {
        c1 = (LNode *) malloc(sizeof(LNode));
        if (!c1)    return; // Allocation failed

        if (a->data <= b->data)
        {
            c1->data = a->data;
            a = a->next;
        } else
        {
            c1->data = b->data;
            b = b->next;
        }
        c1->next = NULL;
        c->next = c1;
        c = c1;
    }

    while (a)
    {
        c1 = (LNode *) malloc(sizeof(LNode));
        if (!c1)    return; // Allocation failed
        c1->data = a->data;
        c1->next = NULL;
        c->next = c1;
        c = c1;
        a = a->next;
    }

    while (b)
    {
        c1 = (LNode *) malloc(sizeof(LNode));
        if (!c1)   return;
		c1->data = b->data;
        c1->next = NULL;
        c->next = c1;
        c = c1;
        b = b->next;
    }
}

// Print the elements in a list
void LinkedListPrint(LinkedList L)
{
    LNode *p = L->next;
    while (p)
    {
        printf("%d ", p->data);
        p = p->next;
    }
}

int main()
{
    LNode *La, *Lb, *Lc;
    InitLinkList(&La);
    InitLinkList(&Lb);
    InitLinkList(&Lc);

    int n, m;
    scanf("%d", &n);
    int a[n];
    int i = 0;
    for (i = 0; i < n; i++)     scanf("%d", &a[i]);

    CreateList_L(La, a, n);

    scanf("%d", &m);
    int b[m];
    for (i = 0; i < m; i++)     scanf("%d", &b[i]);

    CreateList_L(Lb, b, m);

    Merge_L(&La, &Lb, &Lc);

    LinkedListPrint(Lc);

    return OK;
}  

```



#### 6.链表删除



```c
#include <stdio.h>   
#include <stdlib.h>   
#include <malloc.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef int ElemType;
typedef int Status;

// definition of node structure of singly linked list
typedef struct L_node
{
    ElemType data;           // data field 
    struct L_node* next;       // pointer field
}LNode, * LinkList;

//===========================================
// Initialize  a singly linked list L with head node
//===========================================

Status InitList_L(LinkList *L)

{
	(*L) = (LNode*)malloc(sizeof(LNode));
	(*L)->next = NULL;
	return OK;
}

//===========================================
// Create a singly linked list L with head node, and with n elements
//===========================================

Status CreateList_L(LinkList* L, ElemType a[], int n)
{
	LNode *p = *L;
	int j = 0;
	for(;j < n;j ++)
	{
		LNode*r ;
		r = (LNode*)malloc(sizeof(LNode));
		r->data = a[j];
		r->next = NULL;
		p->next = r;
		p = r;
	}
	return OK;
}

void Delete_List(LinkList L,int i)
{
	LNode*prev = L;
	int j = 0;
	while(prev && j < i - 1)
	{
		prev = prev->next;
		j ++;
	}
	if(!prev || j > i - 1) return ;
	LinkList r = prev->next;
	prev->next = r->next;
	free(r);
	return ;
}
//===========================================
//  删除位序为偶数的结点，并返回删除结点的总数
//===========================================

int Delete_L(LinkList *L,int len)
{
	int i = len / 2;
	int j = 2 * i;
	int count = 0;
	for(;j >1;j -=2)	
	{
		Delete_List(*L,j);
		count ++;
	}
	return count;
}
//======================================
// Print the elements in a list
//=======================================

void LinkedListPrint(LinkList L)

{
	LNode *p = L->next;
	while(p)
	{
		printf("%d ",p->data);
		p = p->next;
	}
	return;
}

int main()
{
	LNode *L;
	InitList_L(&L);
	int i = 0,n;
	scanf("%d",&n);
	int arr[n];
	for(;i < n;i ++) scanf("%d",&arr[i]);
	CreateList_L(&L,arr,n);
	int tot = Delete_L(&L,n);
	printf("%d\n",tot);
	LinkedListPrint(L);
	return OK;
}
```



#### 7.链表拼接

```c
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef int ElemType;
typedef int Status;

// definition of node structure of singly linked list
typedef struct L_node
{
    ElemType data;           // data field 
    struct L_node *next;       // pointer field
} LNode, *LinkedList;

//===========================================
// Initialize  a singly linked list L with head node
//===========================================
Status InitList_L(LinkedList *L)
{
    *L = (LNode *) malloc(sizeof(LNode));
    if (!(*L)) return ERROR;
    (*L)->next = NULL;
    return OK;
}

//===========================================
// Create a singly linked list L with head node, and with n elements
//===========================================

Status CreateList_L(LinkedList *L, int a[], int n)
{
    LNode *r = (*L);
    int i = 0;
    for (; i < n; i++)
    {
        LNode *p;
        p = (LNode *) malloc(sizeof(LNode));
        p->data = a[i];
        p->next = NULL;
        r->next = p;
        r = p;
    }
    return OK;
}

//===========================================
//  Merge two singly linked lists 
//===========================================

int Merge_L(LinkedList *ha, int len_a, LinkedList *hb, int len_b, LinkedList *hc)
{
    LNode *a = (*ha)->next;
    LNode *b = (*hb)->next;
    LNode *c = *hc;
    LNode *c1;
    c1 = (LNode *) malloc(sizeof(LNode));
    if (len_a > len_b)
    {
        while (b)
        {
            c1 = b;
            c->next = c1;
            c = c1;
            b = b->next;
        }
        while (a)
        {
            c1 = a;
            c->next = c1;
            c = c1;
            a = a->next;
        }
    } 
    else
    {
        while (a)
        {
            c1 = a;
            c->next = c1;
            c = c1;
            a = a->next;
        }
        while (b)
        {
            c1 = b;
            c->next = c1;
            c = c1;
            b = b->next;
        }
    }
}

//======================================
// Print the elements in a list
//=======================================

void LinkedListPrint(LinkedList L)
{
    LNode *p = L->next;
    while (p)
    {
        printf("%d ", p->data);
        p = p->next;
    }
}

int main()
{
    LNode *La;
    LNode *Lb;
    LNode *Lc;
    InitList_L(&La);
    InitList_L(&Lb);
    InitList_L(&Lc);
    int n, m, i = 0;
    scanf("%d", &n);
    int a[n];
    for (; i < n; i++) scanf("%d", &a[i]);
    CreateList_L(&La, a, n);
    scanf("%d", &m);
    int b[m];
    for (i = 0; i < m; i++) scanf("%d", &b[i]);
    CreateList_L(&Lb, b, m);
    Merge_L(&La, n, &Lb, m, &Lc);
    LinkedListPrint(Lc);
	return OK;
}  
```



#### 双向链表学习代码：

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1

typedef int ElemType;
typedef int Status;

typedef struct DuLNode
{
    ElemType data;          // 数据域
    struct DuLNode *prior;  // 指向直接前驱
    struct DuLNode *next;   // 指向直接后继
} DuLNode, *DuLinkList;

Status GetElem_DuL(DuLinkList L, int i, ElemType *e)
{
    int j;
    DuLinkList p;
    p = L->next; // p指向第一个结点
    j = 1;
    while (p && j < i)
    {
        p = p->next;
        ++j;
    }
    if (!p || j > i)
        return ERROR; // 第i个元素不存在
    *e = p->data;     // 取第i个元素的数据
    return OK;
}

Status ListInsert_DuL(DuLinkList *L, int i, ElemType e)
{
    DuLinkList p, s;
    if (i < 1) // 如果位置不合法
        return ERROR;

    s = (DuLinkList) malloc(sizeof(DuLNode));
    if (!s)
        exit(EXIT_FAILURE); // 内存分配失败，退出程序
    s->data = e;

    if (i == 1 || !(*L)->next)
    { // 在第一个位置插入或者链表为空时
        s->next = (*L)->next;
        if ((*L)->next) // 如果链表不为空
            (*L)->next->prior = s;
        s->prior = *L;
        (*L)->next = s;
        return OK;
    }

    p = (*L)->next;
    while (--i && p) p = p->next; // 找到第 i-1 个节点
    if (!p) // 如果位置超出链表长度
        return ERROR;

    s->next = p->next;
    s->next->prior = s;
    s->prior = p;
    p->next = s;
    return OK;
}


Status ListDelete_DuL(DuLinkList *L, int i)
{
    DuLinkList p, q;
    int j = 1;
    p = *L; // 将 p 指向头节点
    while (p->next && j < i)
    {
        p = p->next;
        ++j;
    }
    if (!p->next || j > i)
        return ERROR; // 第i个元素不存在
    q = p->next;
    p->next = q->next;
    if (q->next) // 如果 q 的下一个节点不为空
        q->next->prior = p;
    free(q);
    return OK;
}


int main()
{
    DuLinkList L;
    L = (DuLinkList) malloc(sizeof(DuLNode));
    if (!L)
        exit(EXIT_FAILURE); // 内存分配失败，退出程序
    L->next = NULL;
    ElemType e;
    if (ListInsert_DuL(&L, 1, 10) == OK)
        printf("Insert successful!\n");
    if (GetElem_DuL(L, 1, &e) == OK)
        printf("The first element is: %d\n", e);
    if (ListDelete_DuL(&L, 1) == OK)
        printf("Delete successful!\n");
    //system("pause");
    return 0;
}

```



### 作业4——栈



#### 学习代码：

```c
#include <stdio.h>
#include <malloc.h>
#include <string.h>

typedef int SElemType ;
typedef int Status;

#define ERROR 0
#define OK 1
#define MAXSIZE 100
typedef struct
{
    SElemType *base;
    SElemType *top;
    int stackSize;
}SqStack;

Status InitStack(SqStack *S)
{
    S->base = (SElemType*) malloc(sizeof (SqStack));
    if(!S->base)    return ERROR;
    S->top = S->base;//top 初始为 base ,空栈
    S->stackSize = MAXSIZE;
    return OK;
}

Status Push(SqStack *S,SElemType e)
{
    if(S->top - S->base == S->stackSize)    return ERROR;//栈满
    *S->top ++= e;//将元素e压入栈顶，栈顶指针加1
    return OK;
}

Status Pop(SqStack *S,SElemType *e)
{
    if(S->base == S->top)   return ERROR;//栈空
    *e = *--S->top;//栈顶指针减1，将栈顶元素赋给e
    return OK;
}

SElemType GetTop(SqStack S)
{//返回S的栈顶元素，不修改栈顶指针
    if(S.top != S.base)   return *(S.top - 1);//返回栈顶元素的值，栈顶指针不变
}

Status destorystack(stack *p)//毁坏
{
	free(p->base);
	p->base=NULL;
	p->top=NULL;
	p->stacksize=0;
	if(!p->base)
		printf("栈被毁坏成功！！！\n");
	return OK;
}

```



#### 1.堆栈练习题

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define OK 1
#define ERROR 0

struct Stack
{
    int top;
    unsigned capacity;
    char *array;
};

struct Stack* createStack(unsigned capacity)
{
    struct Stack *stack = (struct Stack *)malloc(sizeof(struct Stack));
    if (stack == NULL) 
    {
        printf("Memory allocation failed!\n");
        exit(EXIT_FAILURE);
    }
    stack->capacity = capacity;
    stack->top = -1;
    stack->array = (char*)malloc(stack->capacity * sizeof(char));
    if (stack->array == NULL) 
    {
        printf("Memory allocation failed!\n");
        exit(EXIT_FAILURE);
    }
    return stack;
}

int isFull(struct Stack stack)
{
	int full = 0;   
	/*在表达式 (int)stack.capacity 中，stack.capacity 是 unsigned 类型的无符号整数，
	  而 (int) 是将其强制转换为有符号整数类型 int。
	  这个强制转换的目的是为了避免比较不同类型的数据时出现警告或错误*/
	full = (stack.top == (int)stack.capacity - 1)?1:0;
	return full;
}

int isEmpty(struct Stack stack)
{
	return (stack.top == -1) ? 1 :0;
}

void push(struct Stack *stack, char item)
{
    if (!isFull(*stack)) 
    {
        stack->array[++stack->top] = item;
    } 
    else 
    {
        printf("Stack is full. Cannot push element.\n");
    }
}

char pop(struct Stack *stack)
{
    if (!isEmpty(*stack)) 
    {
        return stack->array[stack->top--];
    } 
    else 
    {
        printf("Stack is empty. Cannot pop element.\n");
        return '\0';
    }
}

void reverseStr(char *str)
{
    int length = strlen(str);
    struct Stack* stack = createStack(length + 1);
    for (int i = 0; i < length; i++) 
    {
        push(stack, str[i]);
    }
    for (int i = 0; i < length; i++) 
    {
        str[i] = pop(stack);
    }
    printf("%s\n", str);
}

int main()
{
    char str[] = "ILoveChina, ILoveBJTU, ILoveGJCXSJXL";
    reverseStr(str);
    return 0;
}

```



####    2. 栈-创建堆栈

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef int SElemType;
typedef int Status;

#define STACK_INIT_SIZE   100     // 初始栈大小
#define STACKINCREMENT    10      // 栈增量大小

typedef struct {
    SElemType *base;    // 栈底指针
    SElemType *top;     // 栈顶指针
    int stacksize;      // 当前栈容量
} SqStack;

Status InitStack(SqStack *S) 
{
    S->base = (SElemType *)malloc(sizeof(SElemType) * STACK_INIT_SIZE);
    if (!S->base)      return ERROR;
    S->top = S->base;
    S->stacksize = STACK_INIT_SIZE;
    return OK;
}

Status StackEmpty(SqStack S) 
{
    return (S.top == S.base) ? TRUE : FALSE;
}

int StackLength(SqStack S) 
{
    return (S.top - S.base);
}

Status GetTop(SqStack S, SElemType *e) 
{
  if (StackEmpty(*S))      return ERROR;
    *e = *(S.top - 1);
    return OK;
}

Status Pop(SqStack *S, SElemType *e) 
{
    if (StackEmpty(*S))      return ERROR;
    *e = *(--S->top);
    return OK;
}

Status Push(SqStack *S, SElemType e) 
{
    if (S->top - S->base >= S->stacksize) 
    {
        //内存不够，重新分配空间
        S->base = (SElemType *)realloc(S->base, (S->stacksize + STACKINCREMENT) * sizeof(SElemType));
        if (!S->base)        return ERROR;
        S->top = S->base + S->stacksize;
        S->stacksize += STACKINCREMENT;
    }
    *(S->top++) = e;
    return OK;
}

void PrintStack(SqStack S) 
{
    int len = StackLength(S);
    for (int i = 0; i < len; i++) 
    {
        SElemType e;
        Pop(&S, &e);
        printf("%d ", e);
    }
    printf("\n");
}

int reverseOutput(SqStack S) 
{
    if (StackEmpty(S))      return ERROR;
    PrintStack(S);
    return StackLength(S);
}

int main() 
{
    SqStack S;
    InitStack(&S);
    int n, i = 0;
    scanf("%d", &n);
    int arr[n];
    for (; i < n; i++) 
    {
        scanf("%d", &arr[i]);
        Push(&S, arr[i]);
    }
    printf("%d", reverseOutput(S));
    return OK;
}

```



#### 3. 栈-比较含退格的字符串

```c
#include <stdio.h>
#include <stdlib.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef char ElemType;
typedef int Status;

#define STACK_INIT_SIZE   100          // Initial size for memory allocation
#define STACKINCREMENT    10           // Incremental size

typedef struct 
{
    ElemType  *base;    // Base pointer
    ElemType  *top;     // Top pointer
    int        stacksize;     // Current size
} SqStack;

Status InitStack(SqStack *S) 
{
    S->base = (ElemType *)malloc(STACK_INIT_SIZE * sizeof(ElemType));
    if (!S->base) return ERROR;
    S->top = S->base;
    S->stacksize = STACK_INIT_SIZE;
    return OK;
}

Status StackEmpty(SqStack S)
{
    return S.base == S.top ? TRUE : FALSE;
}

int StackLength(SqStack S) 
{
    return S.top - S.base;
}

Status GetTop(SqStack S, ElemType *e) 
{
    if (StackEmpty(S)) return ERROR;
    *e = *(S.top - 1);
    return OK;
}

Status Pop(SqStack *S, ElemType *e)
{
    if (StackEmpty(*S)) return ERROR;
    *e = *--S->top;
    return OK;
}

Status Push(SqStack *S, ElemType e) 
{
    if (S->top - S->base >= S->stacksize)
    {
        S->base = (ElemType *)realloc(S->base, (S->stacksize + STACKINCREMENT) * sizeof(ElemType));
        if (!S->base) return ERROR;
        S->top = S->base + S->stacksize;
        S->stacksize += STACKINCREMENT;
    }
    *S->top++ = e;
    return OK;
}

int CompareString(char *S,  char *T)
{
    SqStack stack_S, stack_T;
    InitStack(&stack_S);
    InitStack(&stack_T);
    
    for (int i = 0; S[i] != '\0'; i++) 
    {
        if (S[i] != '#')     Push(&stack_S, S[i]);
        else 
        {
            if (!StackEmpty(stack_S)) 
            {
                ElemType temp;
                Pop(&stack_S, &temp);
            }
        }
    }
    
    for (int i = 0; T[i] != '\0'; i++) 
    {
        if (T[i] != '#')        Push(&stack_T, T[i]); 
        else 
        {
            if (!StackEmpty(stack_T)) 
            {
                ElemType temp;
                Pop(&stack_T, &temp);
            }
        }
    }
    
    if (StackLength(stack_S) != StackLength(stack_T))      return FALSE;
    while (!StackEmpty(stack_S)) 
    {
        ElemType charS, charT;
        Pop(&stack_S, &charS);
        Pop(&stack_T, &charT);
        if (charS != charT)      return FALSE;
    }
    return TRUE;
}

int main() 
{
    char s[1000], t[1000];
    scanf("%s", s);
    scanf("%s", t);
    
    int res = CompareString(s, t);
    if (res)   printf("true");
    else 		printf("false");

    return 0;
}

```



#### 4. 820230003栈基本操作与应用



```c
#define BASE 17

#include <stdio.h>
#include <stdlib.h>

#define Status int
#define SElemType char

#define STACK_INIT_SIZE 100        //存储空间的初始分配量
#define STACKINCREMENT  10          //存储空间的分配增量
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0

//栈数据结构
typedef struct Stack 
{
    SElemType *base;    //栈底指针
    SElemType *top;     //栈顶指针
    int stacksize;      //栈可用的最大容量
} SqStack;

//初始化函数
Status InitStack(SqStack *S) 
{
    S->base = (SElemType *)malloc(STACK_INIT_SIZE * sizeof(SElemType));
    if (!S->base) 
    {
        printf("init fail\n");
        return ERROR;
    }
    S->top = S->base;     //栈顶指针与栈底相同
    S->stacksize = STACK_INIT_SIZE;
    return OK;
}

//销毁 
Status DestroyStack(SqStack *S) 
{
    //补全代码
	free(S->base);
	S->base = NULL;
	S->top = NULL;  
	S->stacksize = 0;
	if(S->base)	
	{
		printf("Fail Destroy");
		return ERROR;
	}
	return OK;
}

//清空 
Status ClearStack(SqStack *S) 
{
    S->top = S->base;
    return OK;
}

//判断是否为空 
Status StackEmpty(SqStack S) 
{
    if (S.top == S.base) 
        return TRUE;
    else
        return FALSE;
}

int StackLength(SqStack S) 
{
    return S.top - S.base;
}

//得到栈顶元素，不修改指针
Status GetTop(SqStack S, SElemType *e) 
{ 
    if (S.top == S.base) 
        return ERROR;
    *e = *(S.top - 1);
    return OK;
}

//入栈
Status Push(SqStack *S, SElemType e) 
{
    if (S->top - S->base >= S->stacksize) 
    {  //栈满,追加存储空间
        S->base = (SElemType *)realloc(S->base, (S->stacksize + STACKINCREMENT) * sizeof(SElemType));
        if (!S->base) 
            return ERROR;
        S->top = S->base + S->stacksize;
        S->stacksize += STACKINCREMENT;
    }
    *S->top++ = e;
    return OK;
}

//出栈
Status Pop(SqStack *S, SElemType *e) 
{
    if (S->top == S->base) 
        return ERROR;    //栈空
    *e = *--S->top;
    return OK;
}

//遍历栈
Status StackTraverse(SqStack S) 
{
    if (S.base == NULL)
        return ERROR;
    if (S.top == S.base)
        printf("empty\n");
    SElemType *p;
    p = S.top;
    while (p > S.base) 
    {
        p--;
        printf("%c", *p);//从栈顶开始打印，而且未修改栈顶指针 
    }
    return OK;
}

void conversion(SqStack *S) 
{
    //补全代码
    int decimal = 0;
    scanf("%d",&decimal);
    char base17[20] = "0123456789ABCDEFG";
    while(decimal)
    {
    	int index = decimal % 17;
    	Push(S,base17[index]);
    	decimal /=17;
	}
	StackTraverse(*S);
}

//主函数
int main() 
{
    SqStack S;
    InitStack(&S);
    conversion(&S);
    DestroyStack(&S);
    return 0;
}

```



#### 5. 实验4 栈实验1



```c
#include <stdio.h>

#include <string.h>

#include <stdlib.h>


#define STACK_INIT_SIZE    20     /*存储空间的初始分配量*/

#define STACK_INCREMENT    10     /*存储空间的分配增量*/

//#define CHAR_MAX 127

#define DBL_MAX 100

#define ERROR 0

#define OK 1


/*数据栈结构体定义，要求：

包括栈底指针，栈顶指针和当前分配的存储容量*/

typedef struct
{

    double *Dbase;

    double *Dtop;

    int Dstacksize;

} DataStack;


/*操作符结构体定义，要求包括栈底指针，栈顶指针和当前分配的存储容量*/

typedef struct
{

    char *Obase;

    char *Otop;

    int Ostacksize;

} OpStack;


/*静态二维优先级数组：static char OperationPreceder[7][7]   

定义操作符＋、－、＊、／、（、）、=的运算优先级*/

static char OperationPreceder[7][7] =

        {{'>', '>', '<', '<', '<', '>', '>'},

         {'>', '>', '<', '<', '<', '>', '>'},

         {'>', '>', '>', '>', '<', '>', '>'},

         {'>', '>', '>', '>', '<', '>', '>'},

         {'<', '<', '<', '<', '<', '=', 'x'},

         {'>', '>', '>', '>', 'x', '>', '>'},

         {'<', '<', '<', '<', '<', 'x', '='}

        };


/*函数接口定义为：int TransOPtoCD(char op_temp)   

* 输入参数：操作符x   

* 处理规则及返回值：将操作符转化为运算优先级静态表的坐标，并返回；   

* 输入参数非＋、－、＊、／、（、）、=，则返回－1*/

int TransOPtoCD(char op_temp)
{

    switch (op_temp)
    {

        case '+':
            return (0);

        case '-':
            return (1);

        case '*':
            return (2);

        case '/':
            return (3);

        case '(':
            return (4);

        case ')':
            return (5);

        case '=':
            return (6);

        default:
            return (-1);  /*当输入参数不是四则运算、括号、等号时，返回－1*/

    }


}


/*函数接口定义为：char Precede(char op1, char op2)   

* 输入参数：进行比较的运算符op1和op2；   

* 处理规则及返回值：将op1和op2转化为二维数组OperationPreceder的坐标，查找该坐标存储的符号，并作为返回值输出；   

* 如果无法找到坐标则返回0*/

char Precede(char op1, char op2)
{

    int x, y;

    x = y = -1;

    x = TransOPtoCD(op1);

    y = TransOPtoCD(op2);

    if (x != -1 && y != -1)
    {

        //    printf("%c\n", OperationPreceder[x][y]);       

        return OperationPreceder[x][y];

    } else

        return 0;

}


/*函数接口定义为：int checkch (char c)   

* 输入参数：表达式字符c；   

* 处理规则及返回值：判断字符c是数字还是操作符；   

* 如果c是数字返回1，如果是小数点返回2，如果是运算符返回3，否则为无效字符返回－1；   

* 假设：表达式中的所有云算数均为正数*/

int checkch(char c)
{

    if (c >= '0' && c <= '9')

        return 1;

    if (c == '.')

        return 2;

    if (c == '+' || c == '-' || c == '*' || c == '/' || c == '(' || c == ')' || c == '=')

        return 3;

    else

        return 0;

}


/*函数接口定义为：double Operate(double x,double y, char op)；   

* 输入参数：运算数x，被运算数y，操作符op；   

* 处理规则及返回值：进行x op y运算，返回运算结果；默认返回0.0*/

double Operate(double x, double y, char op)
{

    switch (op)
    {

        case '+':

            return x + y;

        case '-':

            return x - y;

        case '*':

            return x * y;

        case '/':

            if (y != 0)

                return x / y;

            else

                printf("The divisor cannot be 0!\n");

            exit(-1);

        default:

            break;

    }

    return 0.0;

}


/*数据栈初始化函数定义，要求：   

* 函数接口定义为：int InitDataStack(DataStack *DS)   

* 输入参数：数据栈DS   

* 处理规则及返回值：从内存堆中申请STACK_INIT_SIZE个整型空间，将栈顶指针与栈底指针都指向初始地址，给Dstacksize赋值STACK_INIT_SIZE   

* 初始化成功返回1，否则返回0.*/

int InitDataStack(DataStack *DS)
{


    //根据注释, 将该函数补充完整
    DS->Dbase = (double*)malloc(sizeof(double));
    if(!DS->Dbase)	return ERROR;
    DS->Dtop = DS->Dbase;
	DS->Dstacksize =  STACK_INIT_SIZE;
	return OK;
	
	
}


/* 数据栈入栈函数定义，要求：   

* 函数接口定义为：int PushDataStack(DataStack *DS,int e)   

* 输入参数：待操作数据栈DS，插入数据e；   

* 处理规则及返回值：在栈顶指针位置存储e，并将栈顶指针位置后移，返回1；   

如果数据栈不存在或者数据栈上溢，返回错误（0）。*/

int PushDataStack(DataStack *DS, double e)
{
	if(!DS->Dbase)	return ERROR;//数据栈不存在
	if(DS->Dtop - DS->Dbase >= DS->Dstacksize)
	{//据栈上溢,重新分配内存 
		DS->Dbase = (double*)realloc(DS->Dbase,(DS->Dstacksize +STACK_INCREMENT ) * sizeof(double));
		if(!DS->Dbase)	return ERROR;
		DS->Dtop = DS->Dbase + DS->Dstacksize;
		DS->Dstacksize += STACK_INCREMENT;
	}
	*(DS->Dtop++) = e;
	return OK;
   // 根据注释, 将该函数补充完整


}


/*数据栈出栈函数定义，要求：   

* 函数接口定义为：int PopDataStack(DataStack *DS, int *e)   

* 输入参数：数据栈DS, 输出整型指针变量e；   

* 处理规则及返回值：将栈顶指针减1，将该地址存储的变量付给＊e，返回1；   

如果数据栈不存在或数据栈为空，返回0。*/

int PopDataStack(DataStack *DS, double *e)
{

    //根据注释, 将该函数补充完整
    if(!DS->Dbase)	return ERROR;
    *e = *--DS->Dtop;
	return OK; 

}


/*数据栈查看栈顶元素函数定义，要求：   

* 函数接口定义为：int GetDataTop(DataStack *DS)   

* 输入参数：数据栈DS, 记录栈顶元素变量e；   

* 处理规则及返回值：如果数据栈不存在或数据栈为空，返回DBL_MAX; 否则，返回栈顶元素。*/

double GetDataTop(DataStack *DS)
{


    //根据注释, 将该函数补充完整
	if(!DS->Dbase)	return DBL_MAX;
	return *(DS->Dtop - 1);
	
}


/*数据栈销毁函数定义，要求：   

* 函数接口定义为：int DestroyDataStack(DataStack *DS   

* 输入参数：数据栈DS   

* 处理规则及返回值：释放栈底指针所指空间，并将数据栈的栈底和栈顶指针置空，数据栈Dstacksize置为0。最后返回1*/

int DestroyDataStack(DataStack *DS)
{

    //根据注释, 将该函数补充完整
    free(DS->Dbase);
	DS->Dbase = NULL;
	DS->Dtop = NULL;
	DS->Dstacksize = 0;
	if(DS->Dbase)	return ERROR;
	return OK;

}


/*符号栈初始化函数定义，要求：   

* 函数接口定义为：int InitOpStack(OpStack *OS)   

* 输入参数：符号栈OS   

* 处理规则及返回值：从内存堆中申请STACK_INIT_SIZE个整型空间，将栈顶指针与栈底指针都指向初始地址，给Dstacksize赋值STACK_INIT_SIZE   

* 初始化成功返回1，否则返回0.*/

int InitOpStack(OpStack *OS)
{

    //根据注释, 将该函数补充完整
    OS->Obase = (char*)malloc(sizeof(char));
    if(!OS->Obase)	return ERROR;
    OS->Otop = OS->Obase;
    OS->Ostacksize = STACK_INIT_SIZE;
    return OK;

}


/* 符号栈入栈函数定义，要求：   

* 函数接口定义为：int PushOpStack(OpStack *OS,int e)   

* 输入参数：待操作符号栈DS，插入符号e；   

* 处理规则及返回值：在栈顶指针位置存储e，并将栈顶指针位置后移，返回1；   

如果符号栈不存在或者符号栈上溢，返回0。*/

int PushOpStack(OpStack *OS, char e)
{


//    根据注释, 将该函数补充完整
	if(!OS->Obase)	return OK;
	if(OS->Otop - OS->Obase >= OS->Ostacksize)	
	{
		OS->Obase = (char*)realloc(OS->Obase,(OS->Ostacksize + STACK_INCREMENT)*sizeof(char));
		
	}
	*OS->Otop++ = e;
}


/* 符号栈出栈函数定义，要求：   

* 函数接口定义为：int PopOpStack(OpStack *OS, int *e)   

* 输入参数：符号栈DS, 输出符号指针变量e；   

* 处理规则及返回值：将栈顶指针减1，将该地址存储的变量付给＊e，返回1；   

如果符号栈不存在或符号栈为空，返回0。*/

int PopOpStack(OpStack *OS, char *e)
{

    //根据注释, 将该函数补充完整
    if(!OS->Obase)	return ERROR;
    *e = *--OS->Otop;
    return OK;

}


/* 符号栈查看栈顶元素函数定义，要求：   

* 函数接口定义为：char GetOpTop(OpStack *OS)   

* 输入参数：数据栈DS, 记录栈顶元素变量e；   

* 处理规则及返回值：如果数据栈不存在或数据栈为空，返回CHAR_MAX; 否则，返回栈顶元素。*/

char GetOpTop(OpStack *OS)
{


    //根据注释, 将该函数补充完整
	if(!OS->Obase)	return ERROR;
	return *(OS->Otop - 1);

}


/* 符号栈销毁函数定义，要求：   

* 函数接口定义为：int DestroyOpStack(OpStack *OS)   

* 输入参数：符号栈DS   

* 处理规则及返回值：释放栈底指针所指空间，并将符号栈的栈底和栈顶指针置空，符号栈Dstacksize置为0。最后返回1*/

int DestroyOpStack(OpStack *OS)
{

    //根据注释, 将该函数补充完整
	free(OS->Obase);
	OS->Obase = NULL;
	OS->Otop = NULL;
	OS->Ostacksize = 0;
	if(OS->Obase)	return ERROR;
	return OK; 

}


int main()
{

    OpStack OPTR = {0};      /*运算符栈*/

    DataStack OPND = {0};    /*操作数栈*/

    char op = 0;             /*当前运算符*/

    double value = 0.0;        /*数字字符的组合结果*/

    double b = 0.0;         /*当前运算的操作数*/

    double a = 0.0;         /*当前运算的被操作数*/

    char expression[1001] = {0};          /*表达式缓存，表达式长度不大于1000个字符*/

    int i = 0;                            /*表达式缓存的当前读取位置*/



    /*数据栈初始化函数定义，要求：   

    * 函数接口定义为：int InitDataStack(DataStack *DS)   

    * 输入参数：数据栈DS   

    * 处理规则及返回值：从内存堆中申请STACK_INIT_SIZE个整型空间，将栈顶指针与栈底指针都指向初始地址，给Dstacksize赋值STACK_INIT_SIZE   

    * 初始化成功返回1，否则返回0.*/

    if (InitDataStack(&OPND) == 0)
    {

        printf("InitDataStack Wrong\n");

        return 1;

    }



    /*符号栈初始化函数定义，要求：   

    * 函数接口定义为：int InitOpStack(OpStack *OS)   

    * 输入参数：符号栈OS   

    * 处理规则及返回值：从内存堆中申请STACK_INIT_SIZE个整型空间，将栈顶指针与栈底指针都指向初始地址，给Dstacksize赋值STACK_INIT_SIZE   

    * 初始化成功返回1，否则返回0.*/

    if (InitOpStack(&OPTR) == 0)
    {

        printf("InitOpStack Wrong\n");

        return 1;

    }



    /*符号栈栈底压入'＝'*/

    PushOpStack(&OPTR, '=');

    /*提示输入表达式，以等号结束*/

    printf("Please input the expression:\n");

    /*从标准输入获得表达式存入数组expression*/

    gets(expression);

    /*防护代码：当用户遗漏＝时提示*/

    if (expression[strlen(expression) - 1] != '=')
    {

        printf("Error: Please make sure the expression is ended with '='!");

        return 0;

    }


    while (i < strlen(expression) - 1 || GetOpTop(&OPTR) != '=')
    {

        //防护无效输入       

        if (checkch(expression[i]) == 0)
        {

            printf("Error: Invalid Input!");

            return 0;

        }

        //当表达式当前字符是数字时，逐位读入并组合       

        if (checkch(expression[i]) == 1)
        {

            while (checkch(expression[i]) == 1)
            {

                value = 10 * value + expression[i] - '0';

                i++;

            }

            /*如果表达式当前字符是小数，小数点后的数字处理后与小数点之前的数字相加*/

            if (checkch(expression[i]) == 2)
            {

                int r = 10;

                i++;

                while (checkch(expression[i]) == 1)
                {

                    value += (double) (expression[i] - '0') / r;

                    r = 10 * r;

                    i++;

                }

            }

            //数字压入数字栈OPND        

            PushDataStack(&OPND, value);

            value = 0.0;

        }



        /*如果表达式当前字符是运算符，则需要判断当前运算符与符号栈栈顶运算符的优先级*/

        if (checkch(expression[i]) == 3)
        {


            switch (Precede(GetOpTop(&OPTR), expression[i]))
            {

                /*如果符号栈栈顶运算符的优先级 < 表达式当前字符，则将表达式当前字符压入符号栈*/

                case '<':

                    PushOpStack(&OPTR, expression[i]);

                    i++;

                    break;

                    /*如果符号栈栈顶运算符的优先级 = 表达式当前字符，删去该栈顶符号*/

                case '=':

                    PopOpStack(&OPTR, &op);

                    i++;

                    break;

                    /*如果符号栈栈顶运算符的优先级 > 表达式当前字符，则计算栈顶运算符子式*/

                case '>':

                    PopOpStack(&OPTR, &op);

                    PopDataStack(&OPND, &b);

                    PopDataStack(&OPND, &a);

                    PushDataStack(&OPND, Operate(a, b, op));  /*运算结果入数据栈*/

                    break;

                default:

                    break;

            }

        }

    }

    /*打印表达式计算结果*/

    printf("The result is:%.2f\n", GetDataTop(&OPND));

    /*主动释放数据栈和符号栈的空间*/

    DestroyDataStack(&OPND);

    DestroyOpStack(&OPTR);

    return 0;

} 
```





#### 6. 实验4 栈实验2

```c
#include<stdio.h>
#include<stdlib.h>

#define OK 1
#define ERROR 0

typedef int SElemType;

typedef struct StackNode 
{
    SElemType data;
    struct StackNode *next;
} StackNode, *LinkStack;

void InitStack(LinkStack *S) 
{
    *S = (LinkStack)malloc(sizeof(StackNode));
    if(!(*S))	return;
    (*S)->next = NULL; 
}

int StackEmpty(LinkStack S) 
{
    if (S->next == NULL) 
    {
        return 1;
    } 
    else 
    {
        return 0;
    }
}

void Push(LinkStack *S, SElemType e) 
{
    LinkStack p = *S;	
    LinkStack r;
    r = (LinkStack)malloc(sizeof(StackNode));
    if(!r)	return;
    r->data = e;
    r->next = p->next;
    p->next = r;
}

int Pop(LinkStack *S, SElemType *e) 
{
    if(StackEmpty(*S)) return ERROR;
    LinkStack p = *S;
    LinkStack q = p->next;
    *e = q->data;
    p->next = q->next;
    free(q);
    return OK;
}

void Conversion() 
{
    LinkStack S;
    InitStack(&S);
    printf("请输入非负十进制数\n");
    int N;
    N = 1348;
    while (N != 0) 
    {
        int mod = N % 8;
        Push(&S, mod);
        N = N / 8;
    }
    printf("八进制形式为: ");
    int e;
    while (StackEmpty(S) != 1) 
    {
        if(Pop(&S, &e) == OK)//判断是否pop成功
            printf("%d", e);
    }
    printf("\n");
}

int main() 
{
    Conversion();
    return 1;
}

```



#### 7. 栈-棒球比赛



```c
#include <stdio.h>  

#include <stdlib.h>  

#include <malloc.h>

 

#define ERROR 0

#define OK 1

#define TRUE 1

#define FALSE 0

 

typedef int SElemType;  

typedef int Status;

 

typedef struct L_node{

     SElemType     data;  //data field

     struct L_node  *next;   //pointer field

}LNode, *LinkList;

 

typedef struct{

   LinkList  Head;  //head pointer

   int  length;  //length

}LinkStack;

 

//========================================== 

// initialization of linked list based stack

//=========================================== 

Status InitStack(LinkStack *S)
{
	
	S->Head = (LinkList)malloc(sizeof(LNode));
	if(!(S->Head))	return ERROR; 
	S->Head->next = NULL;
	S->length = 0;
	return OK;
}

//========================================

//Test empty stack

//========================================

Status StackEmpty (LinkStack S)
{

	return (S.length == 0)?TRUE:FALSE;

}

 

//===============================================

// Get the length of a stack

//==============================================

int StackLength (LinkStack S)
{
 	               

}

 

//=====================================

// Get top item of a stack

//====================================

int GetTop(LinkStack S)
{
	if(S.length == 0) return ERROR;
	return S.Head->next->data;

}

 

//===================================================

// Delete an item from the stack

//====================================================

Status Pop(LinkStack *S, SElemType *e)
{
	if(S->length == 0)	return ERROR;
	LinkList p = S->Head->next;
	LinkList r = S->Head;
	*e = p->data;
	r->next = p->next;
	S->length --;
	free(p);
	return OK;
}

 

//======================================

// Insert an item into the stack

//=======================================

Status Push(LinkStack *S, SElemType e)
{
	LinkList p = S->Head;
	LinkList r;
	r = (LinkList)malloc(sizeof(LNode));
	if(!r) return ERROR;
	r->data = e;
	r->next = p->next;
	p->next = r;
	S->length ++;
	return OK;

}

 

//======================================

// Print the elements in a stack

//=======================================

void PrintStack (LinkStack S)
{

	LinkList p = S.Head->next;
	while(p)
	{
		printf("%d ",p->data);
		p = p->next;
	 } 
	 
}

//=========================

// 计算分值，s为字符串数组，nSize为数组的长度

//========================

int CalPoints(char *s,  int nSize)

{
	LinkStack Sstack;
	InitStack(&Sstack);
	int count = 0,i = 0,e;
	for(;i < nSize;i ++)
	{
		if(s[i] <= '9' && s[i] >= '0')	Push(&Sstack,s[i] - '0');
		else if(s[i] == '+')	
		{
			LinkList p = Sstack.Head->next;
			//while(p->next->next)	p = p->next;
			Push(&Sstack,p->data + p->next->data);
		}
		else if(s[i] == 'D')	Push(&Sstack,2 * GetTop(Sstack));
		else if(s[i] == 'C')	Pop(&Sstack,&e);
	}
	
	LinkList q = Sstack.Head->next;
	while(q)	
	{
		count +=q->data;
		q = q->next; 
	}
	return count;

} 



int main()  

{  
	int n,i = 0;
	char str[n + 1];
	scanf("%d",&n);
	for(;i < n;i ++)	
	{
		getchar(); 
		scanf("%c",&str[i]);
	}
	str[n] = '\0';
	printf("%s",str); 
	printf("%d",CalPoints(str,n));
	
	return OK;

 } 
```



#### 8. 栈-判断操作序列是否合法

```c
#include <stdio.h>  

#include <stdlib.h>  

#include <malloc.h>

 

#define ERROR 0

#define OK 1

#define TRUE 1

#define FALSE 0

typedef char SElemType;  

typedef int Status;

 

// definition of array based stack

#define STACK_INIT_SIZE   100          //Initial size for memory allocation

#define STACKINCREMENT  10          //incremental size

typedef struct{

   SElemType  *base;    //base pointer

   SElemType  *top;      //top pointer

   int        stacksize;     //current size

}SqStack;

 

//========================================== 

// initialization of array-based stack

//=========================================== 

Status InitStack(SqStack *S)
{

	S->base = (char*)malloc(STACK_INIT_SIZE*sizeof(char));
	if(!S->base)	return ERROR;
	S->top = S->base;
	S->stacksize =  STACK_INIT_SIZE;
	return OK;
}

 

//========================================

//Test empty stack

//========================================

Status StackEmpty (SqStack S)
{

	return (S.base == S.top)?TRUE:FALSE;

}

 

//===============================================

// Get the length of a stack

//==============================================

int StackLength (SqStack S)
{

	return S.top - S.base;                            

}

 

//=====================================

// Get top item of a stack

//====================================

Status GetTop(SqStack S, SElemType *e)
{
	if(StackEmpty(S))	return ERROR;
	*e = *(S.top - 1);
 	return OK;

}

 

//===================================================

// Delete an item from the stack

//====================================================

Status Pop(SqStack *S)
{

	if(StackEmpty(*S))	return ERROR;
	--S->top; 
	return OK;
}

 

//======================================

// Insert an item into the stack

//=======================================

Status Push(SqStack *S,SElemType e)
{

	if(S->stacksize == StackLength(*S)) 
	{
		S->base = (char*)realloc(S->base,(S->stacksize + STACKINCREMENT) *sizeof(char));
		if(!S->base)	return ERROR;
		S->top = S->base + S->stacksize;
		S->stacksize += STACKINCREMENT; 
	 } 
	 *S->top ++ = e;
	return OK;
}

 

//======================================

// Print the elements in a stack

//=======================================

void PrintStack (SqStack S)
{
	
	SElemType *p = S.base;
	while(p < S.top)
	{
		printf("%c",*p++);
	}
	printf("\n"); 
}

 

//======================================

// 检查操作序列是否合法, 如果合法，返回1，否则返回0

//=======================================

int isLegal(char *s)

{
	SqStack T; 
	InitStack(&T);
	
	int i = 0;
	for(;s[i] != '\0';i ++)
	{
		if(s[i] == 'I')	Push(&T,s[i]);
		else if(s[i] == 'O')	if(!Pop(&T)) return ERROR;
	}
	return StackEmpty(T);
}



int main( )  

{  
	char str[10010];
	scanf("%s",str);
	int tag = isLegal(str);
	if(tag)	printf("True");
	else printf("False");
	return OK;


 } 
```



#### 9. 栈-删除元素



```c
#include <stdio.h>  
#include <stdlib.h>  
#include <malloc.h>

#define ERROR 0
#define OK 1
#define TRUE 1
#define FALSE 0

typedef int SElemType;  
typedef int Status;

typedef struct L_node {
    SElemType data;  //data field
    struct L_node *next;   //pointer field
} LNode, *LinkList;

typedef struct {
    LinkList Head;  //head pointer
    int length;  //length
} LinkStack;

//========================================== 
// initialization of linked list based stack
//=========================================== 
Status InitStack(LinkStack *S)
{
   S->Head = (LinkList)malloc(sizeof(LNode));
   if(!S->Head)	return ERROR;
   S->Head->next = NULL;
   S->length = 0;
   return OK; 
}

//========================================
// Test empty stack
//========================================
Status StackEmpty(LinkStack S)
{
	return (!S.length);
}

//===============================================
// Get the length of a stack
//==============================================
int StackLength(LinkStack S)
{
	return S.length;
}

//=====================================
// Get top item of a stack
//====================================
Status GetTop(LinkStack S, SElemType *e)
{
	if(StackEmpty(S))	return ERROR;
	*e = S.Head->next->data;
}

//===================================================
// Delete an item from the stack
//====================================================
Status Pop(LinkStack *S, SElemType *e)
{
	if(StackEmpty(*S))	return ERROR;
	LinkList p = S->Head;
	LinkList r = p->next;
	p->next = r->next;
	*e = r->data;
	free(r);
	S->length --;
	return OK;
}

//======================================
// Insert an item into the stack
//=======================================
Status Push(LinkStack *S, SElemType e)
{
	LinkList p = S->Head;
	LinkList r;
	r = (LinkList)malloc(sizeof(LNode));
	r->data = e;
	r->next = p->next;
	p->next = r;
	S->length ++;
	return OK;
}

//======================================
// Print the elements in a stack
//=======================================
void PrintStack(LinkStack S)
{
	LinkList p = S.Head->next;
	while(p)
	{
		printf("%d ",p->data);
		p = p->next;
	 } 
	 printf("\n");
}

//======================================
// 删除堆栈中值为x的元素（可能有多个），返回堆栈的长度
//=======================================
int DeleteElem(LinkStack *S, SElemType x)
{
	LinkList p = S->Head;
	while(p->next)
	{
		if(p->next->data != x)	p = p->next;
		else
		{
			LinkList r = p->next;
			p->next = r->next;
			free(r);
			 S->length --;
		  }  
	}
	return S->length;
}

int main()  
{  
	LinkStack S;
	InitStack(&S);
	int n,i = 0;
	scanf("%d",&n);
	int arr[n];
	for(;i < n;i ++)	
	{
		scanf("%d",&arr[i]);
		Push(&S,arr[i]);
	}
	int x;
	scanf("%d",&x);
	
	int tag = DeleteElem(&S,x);
	PrintStack(S);
	printf("%d",tag);
}

```

